<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <link href="http://arxiv.org/api/query?search_query%3Dall%3Acs.PL%26id_list%3D%26start%3D0%26max_results%3D1100" rel="self" type="application/atom+xml"/>
  <title type="html">ArXiv Query: search_query=all:cs.PL&amp;id_list=&amp;start=0&amp;max_results=1100</title>
  <id>http://arxiv.org/api/4kWruaGHwqwfaKz+hnqtJdUhEbA</id>
  <updated>2025-03-29T00:00:00-04:00</updated>
  <opensearch:totalResults xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">8486</opensearch:totalResults>
  <opensearch:startIndex xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">0</opensearch:startIndex>
  <opensearch:itemsPerPage xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">1100</opensearch:itemsPerPage>
  <entry>
    <id>http://arxiv.org/abs/cs/0402043v1</id>
    <updated>2004-02-18T06:30:12Z</updated>
    <published>2004-02-18T06:30:12Z</published>
    <title>The UPLNC Compiler: Design and Implementation</title>
    <summary>  The implementation of the compiler of the UPLNC language is presented with a
full source code listing.
</summary>
    <author>
      <name>Evgueniy Vitchev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">134 pages, 2 figures, LaTeX</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0402058v1</id>
    <updated>2004-02-25T19:00:31Z</updated>
    <published>2004-02-25T19:00:31Z</published>
    <title>A Tribute to Alain Colmerauer</title>
    <summary>  The paper describes the contributions of Alain Colmerauer to the areas of
logic programs (LP) and constraint logic programs (CLP).
</summary>
    <author>
      <name>Jacques Cohen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D 3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0512026v1</id>
    <updated>2005-12-07T15:51:26Z</updated>
    <published>2005-12-07T15:51:26Z</published>
    <title>Checking C++ Programs for Dimensional Consistency</title>
    <summary>  I will present my implementation 'n-units' of physical units into C++
programs. It allows the compiler to check for dimensional consistency.
</summary>
    <author>
      <name>I. Josopait</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">submitted to "Computing in Science and Engineering"</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0512026v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0512026v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.2; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.1131v1</id>
    <updated>2010-08-06T07:55:16Z</updated>
    <published>2010-08-06T07:55:16Z</published>
    <title>Computing with Equations</title>
    <summary>  The intention of these notes is to give a mathematical account of how I
believe students could be taught to think about functional programming
languages and to explain how such languages work.
</summary>
    <author>
      <name>Chris Preston</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">240 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.1131v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.1131v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.2339v1</id>
    <updated>2011-02-11T12:53:14Z</updated>
    <published>2011-02-11T12:53:14Z</published>
    <title>A decompilation of the pi-calculus and its application to termination</title>
    <summary>  We study the correspondence between a concurrent lambda-calculus in
administrative, continuation passing style and a pi-calculus and we derive a
termination result for the latter.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1102.2339v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.2339v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.3478v1</id>
    <updated>2011-06-15T08:27:04Z</updated>
    <published>2011-06-15T08:27:04Z</published>
    <title>Conditional Elimination through Code Duplication</title>
    <summary>  We propose an optimizing transformation which reduces program runtime at the
expense of program size by eliminating conditional jumps.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1106.3478v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.3478v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.3128v1</id>
    <updated>2013-09-12T12:04:49Z</updated>
    <published>2013-09-12T12:04:49Z</published>
    <title>Preliminary Notes on Termination and Non-Termination Reasoning</title>
    <summary>  In this preliminary note, we will illustrate our ideas on automated
mechanisms for termination and non-termination reasoning.
</summary>
    <author>
      <name>Ton Chanh Le</name>
    </author>
    <link href="http://arxiv.org/abs/1309.3128v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.3128v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3072v2</id>
    <updated>2014-07-21T14:52:39Z</updated>
    <published>2014-05-13T09:10:32Z</published>
    <title>Haskell for OCaml programmers</title>
    <summary>  This introduction to Haskell is written to optimize learning by programmers
who already know OCaml.
</summary>
    <author>
      <name>Raphael Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3072v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3072v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1407.5670v1</id>
    <updated>2014-07-21T21:20:31Z</updated>
    <published>2014-07-21T21:20:31Z</published>
    <title>Rust for functional programmers</title>
    <summary>  This article provides an introduction to Rust, a systems language by Mozilla,
to programmers already familiar with Haskell, OCaml or other functional
languages.
</summary>
    <author>
      <name>Raphael Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1407.5670v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1407.5670v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.09610v1</id>
    <updated>2018-10-23T00:47:36Z</updated>
    <published>2018-10-23T00:47:36Z</published>
    <title>A Theory of Lazy Imperative Timing</title>
    <summary>  We present a theory of lazy imperative timing.
</summary>
    <author>
      <name>Eric C. R. Hehner</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Toronto</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.282.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.282.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Refine 2018, arXiv:1810.08739</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 282, 2018, pp. 1-9</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1810.09610v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.09610v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.01480v2</id>
    <updated>2017-12-29T17:40:58Z</updated>
    <published>2016-05-05T03:19:11Z</published>
    <title>Towards Understanding Generics in Mainstream OOP</title>
    <summary>  This article reports on steps towards building a simple and accurate
domain-theoretic model of generic nominally-typed OOP.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">29 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.01480v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.01480v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.07271v1</id>
    <updated>2018-04-17T16:17:23Z</updated>
    <published>2018-04-17T16:17:23Z</published>
    <title>EBG: A Lazy Functional Programming Language Implemented on the Java
  Virtual Machine</title>
    <summary>  This technical report describes the implementation of a lazy functional
programming language on the Java VM.
</summary>
    <author>
      <name>Tony Clark</name>
    </author>
    <link href="http://arxiv.org/abs/1804.07271v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.07271v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.03746v1</id>
    <updated>2019-05-08T11:13:49Z</updated>
    <published>2019-05-08T11:13:49Z</published>
    <title>Research Note: An Open Source Bluespec Compiler</title>
    <summary>  In this Research Note we report on an open-source compiler for the Bluespec
hardware description language.
</summary>
    <author>
      <name>David J. Greaves</name>
    </author>
    <link href="http://arxiv.org/abs/1905.03746v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.03746v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2306.01662v1</id>
    <updated>2023-06-02T16:32:01Z</updated>
    <published>2023-06-02T16:32:01Z</published>
    <title>A fixed point theorem for COFEs</title>
    <summary>  A new fixed point principle for complete ordered families of equivalences
(COFEs) is presented, which is stronger than the standard Banach-type fixed
point principle.
</summary>
    <author>
      <name>Stephen Dolan</name>
    </author>
    <link href="http://arxiv.org/abs/2306.01662v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2306.01662v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2411.00037v1</id>
    <updated>2024-10-29T13:46:05Z</updated>
    <published>2024-10-29T13:46:05Z</published>
    <title>Clean for Haskell Programmers</title>
    <summary>  This note is meant to give people who are familiar with the functional
programming language Haskell a concise overview of Clean language elements and
how they differ from Haskell.
</summary>
    <author>
      <name>Mart Lubbers</name>
    </author>
    <author>
      <name>Peter Achten</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2411.00037v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2411.00037v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0107013v2</id>
    <updated>2001-07-12T11:34:06Z</updated>
    <published>2001-07-10T10:24:19Z</published>
    <title>The Logic Programming Paradigm and Prolog</title>
    <summary>  This is a tutorial on logic programming and Prolog appropriate for a course
on programming languages for students familiar with imperative programming.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">37 pages; unpublished</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0107013v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0107013v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0110012v1</id>
    <updated>2001-10-03T09:08:25Z</updated>
    <published>2001-10-03T09:08:25Z</published>
    <title>Proceedings of the 6th Annual Workshop of the ERCIM Working Group on
  Constraints</title>
    <summary>  Homepage of the workshop proceedings, with links to all individually archived
papers
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Roman Bartak</name>
    </author>
    <author>
      <name>Eric Monfroy</name>
    </author>
    <author>
      <name>Francesca Rossi</name>
    </author>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 invited talks, 17 papers</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0110012v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0110012v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0409016v1</id>
    <updated>2004-09-09T01:44:05Z</updated>
    <published>2004-09-09T01:44:05Z</published>
    <title>Using a hierarchy of Domain Specific Languages in complex software
  systems design</title>
    <summary>  A new design methodology is introduced, with some examples on building Domain
Specific Languages hierarchy on top of Scheme.
</summary>
    <author>
      <name>V. S. Lugovsky</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0409016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0409016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;I.2.2;D.3.2;D.2.10" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0411001v1</id>
    <updated>2004-11-01T16:00:07Z</updated>
    <published>2004-11-01T16:00:07Z</published>
    <title>Synchronization from a Categorical Perspective</title>
    <summary>  We introduce a notion of synchronization for higher-dimensional automata,
based on coskeletons of cubical sets. Categorification transports this notion
to the setting of categorical transition systems. We apply the results to study
the semantics of an imperative programming language with message-passing.
</summary>
    <author>
      <name>Krzysztof Worytkiewicz</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0411001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0411001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.2861v1</id>
    <updated>2009-12-15T12:26:02Z</updated>
    <published>2009-12-15T12:26:02Z</published>
    <title>JSC : A JavaScript Object System</title>
    <summary>  The JSC language is a superset of JavaScript designed to ease the development
of large web applications. This language extends JavaScripts own object system
by isolating code in a class declaration, simplifying multiple inheritance and
using method implementation agreements.
</summary>
    <author>
      <name>Artur Ventura</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0912.2861v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.2861v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.4020v1</id>
    <updated>2010-09-21T08:44:49Z</updated>
    <published>2010-09-21T08:44:49Z</published>
    <title>Proceedings of CICLOPS-WLPE 2010</title>
    <summary>  Online proceedings of the Joint Workshop on Implementation of Constraint
Logic Programming Systems and Logic-based Methods in Programming Environments
(CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010.
</summary>
    <author>
      <name>German Vidal</name>
    </author>
    <author>
      <name>Neng-Fa Zhou</name>
    </author>
    <link href="http://arxiv.org/abs/1009.4020v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.4020v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.4993v1</id>
    <updated>2011-12-21T11:31:42Z</updated>
    <published>2011-12-21T11:31:42Z</published>
    <title>Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</title>
    <summary>  These are the revised versions of the papers presented at CICLOPS 2011, a
workshop colocated with ICLP 2011.
</summary>
    <author>
      <name>Salvador Abreu</name>
    </author>
    <author>
      <name>Vitor Santos Costa</name>
    </author>
    <link href="http://arxiv.org/abs/1112.4993v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.4993v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2924v1</id>
    <updated>2012-02-14T03:02:06Z</updated>
    <published>2012-02-14T03:02:06Z</published>
    <title>From Mathematics to Abstract Machine: A formal derivation of an
  executable Krivine machine</title>
    <summary>  This paper presents the derivation of an executable Krivine abstract machine
from a small step interpreter for the simply typed lambda calculus in the
dependently typed programming language Agda.
</summary>
    <author>
      <name>Wouter Swierstra</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Radboud University Nijmegen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.76.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.76.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2012, arXiv:1202.2407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 76, 2012, pp. 163-177</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2924v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2924v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.2017v1</id>
    <updated>2012-07-09T12:05:25Z</updated>
    <published>2012-07-09T12:05:25Z</published>
    <title>dup -- Explicit un-sharing in Haskell</title>
    <summary>  We propose two operations to prevent sharing in Haskell that do not require
modifying the data generating code, demonstrate their use and usefulness, and
compare them to other approaches to preventing sharing. Our claims are
supported by a formal semantics and a prototype implementation.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages, 9 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1207.2017v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.2017v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3; E.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.3203v1</id>
    <updated>2013-08-14T18:30:37Z</updated>
    <published>2013-08-14T18:30:37Z</published>
    <title>Detecting Data Races on OpenCL Kernels with Symbolic Execution</title>
    <summary>  We present an automatic analysis technique for checking data races on OpenCL
kernels. Our method defines symbolic execution techniques based on separation
logic with suitable abstractions to automatically detect non-benign racy
behaviours on kernel
</summary>
    <author>
      <name>Dino Distefano</name>
    </author>
    <author>
      <name>Jeremy Dubreil</name>
    </author>
    <link href="http://arxiv.org/abs/1308.3203v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.3203v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.7256v1</id>
    <updated>2013-11-28T09:58:55Z</updated>
    <published>2013-11-28T09:58:55Z</published>
    <title>The ins and outs of iteration in Mezzo</title>
    <summary>  This is a talk proposal for HOPE 2013. Using iteration over a collection as a
case study, we wish to illustrate the strengths and weaknesses of the prototype
programming language Mezzo.
</summary>
    <author>
      <name>Armaël Guéneau</name>
    </author>
    <author>
      <name>François Pottier</name>
    </author>
    <author>
      <name>Jonathan Protzenko</name>
    </author>
    <link href="http://arxiv.org/abs/1311.7256v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.7256v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.0166v1</id>
    <updated>2014-05-01T14:22:09Z</updated>
    <published>2014-05-01T14:22:09Z</published>
    <title>Proceedings of the 6th European Conference on Python in Science
  (EuroSciPy 2013)</title>
    <summary>  These are the proceedings of the 6th European Conference on Python in
Science, EuroSciPy 2013, that was held in Brussels (21-25 August 2013).
</summary>
    <author>
      <name>Pierre de Buyl</name>
    </author>
    <author>
      <name>Nelle Varoquaux</name>
    </author>
    <link href="http://arxiv.org/abs/1405.0166v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.0166v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1510v1</id>
    <updated>2014-06-05T20:11:27Z</updated>
    <published>2014-06-05T20:11:27Z</published>
    <title>Proceedings of the Eleventh Workshop on Constraint Handling Rules</title>
    <summary>  This volume contains the papers presented at the eleventh Workshop on
Constraint Handling Rules (CHR 2014), which will be held in Vienna at the
occasion of the Vienna Summer of Logic (VSL)
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <author>
      <name>Jon Sneyers</name>
    </author>
    <link href="http://arxiv.org/abs/1406.1510v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1510v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.06526v1</id>
    <updated>2015-08-26T15:09:33Z</updated>
    <published>2015-08-26T15:09:33Z</published>
    <title>A Logical Approach to Event Handling in Imperative Languages</title>
    <summary>  While event handling is a key element in modern interactive programming, it
is unfortunate that its theoretical foundation is rather weak. To solve this
problem, we propose to adopt a game-logical approach of computability logic
\cite{Jap08} to event handling.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.06526v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.06526v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.03350v1</id>
    <updated>2016-08-11T02:17:09Z</updated>
    <published>2016-08-11T02:17:09Z</published>
    <title>Close Encounters of the Higher Kind Emulating Constructor Classes in
  Standard ML</title>
    <summary>  We implement a library for encoding constructor classes in Standard ML,
including elaboration from minimal definitions, and automatic instantiation of
superclasses.
</summary>
    <author>
      <name>Yutaka Nagashima</name>
    </author>
    <author>
      <name>Liam O'Connor</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted by ACM SIGPLAN Workshop on ML, September 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.03350v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.03350v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.06583v1</id>
    <updated>2016-08-23T17:17:08Z</updated>
    <published>2016-08-23T17:17:08Z</published>
    <title>Syntax and analytic semantics of LISA</title>
    <summary>  We provide the syntax and semantics of the LISA (for "Litmus Instruction Set
Architecture") language. The parallel assembly language LISA is implemented in
the herd7 tool (http://virginia.cs.ucl.ac.uk/herd/) for simulating weak
consistency models.
</summary>
    <author>
      <name>Jade ALglave</name>
    </author>
    <author>
      <name>Patrick Cousot</name>
    </author>
    <link href="http://arxiv.org/abs/1608.06583v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.06583v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1711.10301v1</id>
    <updated>2017-11-28T14:19:15Z</updated>
    <published>2017-11-28T14:19:15Z</published>
    <title>The Maximal MAM, a Reasonable Implementation of the Maximal Strategy</title>
    <summary>  This note is about a reasonable abstract machine, called Maximal MAM,
implementing the maximal strategy of the lambda-calculus, that is, the strategy
that always produces a longest evaluation sequence.
</summary>
    <author>
      <name>Beniamino Accattoli</name>
    </author>
    <link href="http://arxiv.org/abs/1711.10301v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1711.10301v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.08329v1</id>
    <updated>2018-08-24T22:41:46Z</updated>
    <published>2018-08-24T22:41:46Z</published>
    <title>When You Should Use Lists in Haskell (Mostly, You Should Not)</title>
    <summary>  We comment on the over-use of lists in functional programming. With this
respect, we review history of Haskell and some of its libraries, and hint at
current developments.
</summary>
    <author>
      <name>Johannes Waldmann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, Accepted for presentation in WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.08329v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.08329v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.05464v1</id>
    <updated>2019-09-12T05:52:35Z</updated>
    <published>2019-09-12T05:52:35Z</published>
    <title>A Formal Semantics of Findel in Coq (Short Paper)</title>
    <summary>  We present the first formal semantics of Findel - a DSL for specifying
financial derivatives. The semantics is encoded in Coq, and we use it to prove
properties of several Findel contracts.
</summary>
    <author>
      <name>Andrei Arusoaie</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented in FROM 2019: http://from2019.projects.uvt.ro/</arxiv:comment>
    <link href="http://arxiv.org/abs/1909.05464v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.05464v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2006.02670v1</id>
    <updated>2020-06-04T07:08:45Z</updated>
    <published>2020-06-04T07:08:45Z</published>
    <title>Automatic Verification of LLVM Code</title>
    <summary>  In this work we present our work in developing a software verification tool
for llvm-code - Lodin - that incorporates both explicit-state model checking,
statistical model checking and symbolic state model checking algorithms.
</summary>
    <author>
      <name>Axel Legay</name>
    </author>
    <author>
      <name>Dirk Nowotka</name>
    </author>
    <author>
      <name>Danny Bøgsted Poulsen</name>
    </author>
    <link href="http://arxiv.org/abs/2006.02670v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2006.02670v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.02519v2</id>
    <updated>2015-02-10T12:03:10Z</updated>
    <published>2015-02-09T15:20:03Z</published>
    <title>Kickstarting Choreographic Programming</title>
    <summary>  We present an overview of some recent efforts aimed at the development of
Choreographic Programming, a programming paradigm for the production of
concurrent software that is guaranteed to be correct by construction from
global descriptions of communication behaviour.
</summary>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <link href="http://arxiv.org/abs/1502.02519v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.02519v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.07155v2</id>
    <updated>2018-07-15T14:38:56Z</updated>
    <published>2018-05-18T11:45:05Z</published>
    <title>Partial Cartesian Graph Product</title>
    <summary>  In this paper we define a new product-like binary operation on directed
graphs, and we discuss some of its properties. We also briefly discuss its
application in constructing the subtyping relation in generic nominally-typed
object-oriented programming languages.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1805.07155v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.07155v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.14840v3</id>
    <updated>2021-07-05T18:39:51Z</updated>
    <published>2021-05-31T09:53:33Z</published>
    <title>Elegant elaboration with function invocation</title>
    <summary>  We present an elegant design of the core language in a dependently-typed
lambda calculus with $\delta$-reduction and an elaboration algorithm.
</summary>
    <author>
      <name>Tesla Zhang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2105.14840v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.14840v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.05707v1</id>
    <updated>2016-07-19T19:38:39Z</updated>
    <published>2016-07-19T19:38:39Z</published>
    <title>Lowering IrGL to CUDA</title>
    <summary>  The IrGL intermediate representation is an explicitly parallel representation
for irregular programs that targets GPUs. In this report, we describe IrGL
constructs, examples of their use and how IrGL is compiled to CUDA by the
Galois GPU compiler.
</summary>
    <author>
      <name>Sreepathi Pai</name>
    </author>
    <author>
      <name>Keshav Pingali</name>
    </author>
    <link href="http://arxiv.org/abs/1607.05707v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.05707v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.05219v1</id>
    <updated>2020-11-05T20:49:16Z</updated>
    <published>2020-11-05T20:49:16Z</published>
    <title>Curious properties of latency distributions</title>
    <summary>  Network latency distributions, their algebra, and use examples. This paper
considers modeling of capacity-insensitive processes and distributed systems.
It provides algebraic properties of the latency distribution algebra and
Haskell code to implement the model.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-031-10461-9_10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-031-10461-9_10" rel="related"/>
    <link href="http://arxiv.org/abs/2011.05219v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.05219v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.01872v1</id>
    <updated>2017-02-07T03:55:07Z</updated>
    <published>2017-02-07T03:55:07Z</published>
    <title>Proceedings ML Family / OCaml Users and Developers workshops</title>
    <summary>  This volume contains the joint post-proceedings of the 2015 edition of the ML
Family Workshop and OCaml Users and Developers Workshop, held in Vancouver,
British Columbia, Canada, in affiliation with ICFP 2015.
</summary>
    <author>
      <name>Jeremy Yallop</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <author>
      <name>Damien Doligez</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.241</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.241" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 241, 2017</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1702.01872v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.01872v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.05909v1</id>
    <updated>2019-05-15T01:30:27Z</updated>
    <published>2019-05-15T01:30:27Z</published>
    <title>Proceedings ML Family / OCaml Users and Developers workshops</title>
    <summary>  This volume contains the joint post-proceedings of the 2017 editions of the
ML Family Workshop and the OCaml Users and Developers Workshop which took place
in Oxford, UK, September 2017, and which were colocated with the ICFP 2017
conference.
</summary>
    <author>
      <name>Sam Lindley</name>
    </author>
    <author>
      <name>Gabriel Scherer</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.294</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.294" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 294, 2019</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1905.05909v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.05909v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.3; D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.5930v1</id>
    <updated>2013-06-25T11:54:48Z</updated>
    <published>2013-06-25T11:54:48Z</published>
    <title>The Green Language</title>
    <summary>  Green is a statically-typed object-oriented language that separates subtyping
from inheritance. It supports garbage collection, classes as first-class
objects, parameterized classes, introspective reflection and a kind of run-time
metaobjects called shells.
</summary>
    <author>
      <name>José de Oliveira Guimarães</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">220 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.5930v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.5930v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.06459v1</id>
    <updated>2015-11-20T00:09:02Z</updated>
    <published>2015-11-20T00:09:02Z</published>
    <title>QINL: Query-integrated Languages</title>
    <summary>  We describe an alternative solution to the impedance-mismatch problem between
programming and query languages: rather than embed queries in a programming
language, as done in LINQ systems, we embed programs in a query language, and
dub the result QINL.
</summary>
    <author>
      <name>Patrick Schultz</name>
    </author>
    <author>
      <name>David I. Spivak</name>
    </author>
    <author>
      <name>Ryan Wisnesky</name>
    </author>
    <link href="http://arxiv.org/abs/1511.06459v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.06459v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.05307v2</id>
    <updated>2018-11-18T15:49:24Z</updated>
    <published>2018-11-07T07:56:04Z</published>
    <title>On the extreme power of nonstandard programming languages</title>
    <summary>  Suenaga and Hasuo introduced a nonstandard programming language ${\bf
While}^{{\bf dt}}$ which models hybrid systems. We demonstrate why ${\bf
While}^{{\bf dt}}$ is not suitable for modeling actual computations.
</summary>
    <author>
      <name>Takuma Imamura</name>
    </author>
    <link href="http://arxiv.org/abs/1811.05307v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.05307v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="34A38, 68Q10, 03H10" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.01069v2</id>
    <updated>2018-12-06T21:03:30Z</updated>
    <published>2018-12-03T20:26:55Z</published>
    <title>Undecidability of Inferring Linear Integer Invariants</title>
    <summary>  We show that the problem of determining the existence of an inductive
invariant in the language of quantifier free linear integer arithmetic (QFLIA)
is undecidable, even for transition systems and safety properties expressed in
QFLIA.
</summary>
    <author>
      <name>Sharon Shoham</name>
    </author>
    <link href="http://arxiv.org/abs/1812.01069v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.01069v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.10891v1</id>
    <updated>2018-12-28T04:40:03Z</updated>
    <published>2018-12-28T04:40:03Z</published>
    <title>Proceedings ML Family Workshop / OCaml Users and Developers workshops</title>
    <summary>  This volume contains the joint post-proceedings of the 2016 edition of the ML
Family Workshop and OCaml Users and Developers Workshop, held in Nara, Japan,
in affiliation with ICFP 2016.
</summary>
    <author>
      <name>Kenichi Asai</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Ochanomizu University</arxiv:affiliation>
    </author>
    <author>
      <name>Mark Shinwell</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Jane Street Europe</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.285</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.285" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 285, 2018</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1812.10891v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.10891v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.02458v2</id>
    <updated>2021-12-20T11:53:01Z</updated>
    <published>2021-09-06T13:41:45Z</published>
    <title>On non-structural subtype entailment</title>
    <summary>  We prove that the non-structural subtype entailment problem for finite and
regular type expressions is in PSPACE. In this way we close a decidability and
complexity gap pending since 1996.
</summary>
    <author>
      <name>Aleksy Schubert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The paper contains error in formulation of Lemma 5.5, which
  invalidates the further construction</arxiv:comment>
    <link href="http://arxiv.org/abs/2109.02458v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.02458v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.02129v2</id>
    <updated>2023-07-11T18:44:04Z</updated>
    <published>2022-07-05T15:53:25Z</published>
    <title>Implementing Dependent Types in pi-forall</title>
    <summary>  These lecture notes describe the design of a minimal dependently-typed
language called "pi-forall" and walk through the implementation of its type
checker. They are based on lectures given at the Oregon Programming Languages
Summer School during July 2023.
</summary>
    <author>
      <name>Stephanie Weirich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">54 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.02129v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.02129v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.07423v1</id>
    <updated>2022-07-15T12:02:47Z</updated>
    <published>2022-07-15T12:02:47Z</published>
    <title>GopCaml: A Structural Editor for OCaml</title>
    <summary>  This talk presents Gopcaml-mode, the first structural editing plugin for
OCaml. We will give a tour of the main plugin features, discussing the plugin's
internal design and its integration with existing OCaml and GNU Emacs
toolchains.
</summary>
    <author>
      <name>Kiran Gopinathan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at OCaml workshop at ICFP 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.07423v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.07423v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.17136v2</id>
    <updated>2023-10-27T01:44:07Z</updated>
    <published>2023-10-26T04:19:17Z</published>
    <title>Core Challenge 2023: Solver and Graph Descriptions</title>
    <summary>  This paper collects all descriptions of solvers and ISR instances submitted
to CoRe Challenge 2023.
</summary>
    <author>
      <name>Takehide Soh</name>
    </author>
    <author>
      <name>Tomoya Tanjo</name>
    </author>
    <author>
      <name>Yoshio Okamoto</name>
    </author>
    <author>
      <name>Takehiro Ito</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: text overlap with arXiv:2208.02495,
  arXiv:2207.13959</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.17136v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.17136v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2402.15511v1</id>
    <updated>2023-12-19T08:28:06Z</updated>
    <published>2023-12-19T08:28:06Z</published>
    <title>Sixth International Workshop on Languages for Modelling Variability
  (MODEVAR 2024)</title>
    <summary>  This is the proceedings of the Sixth International Workshop on Languages for
Modelling Variability (MODEVAR 2024) which was held at Bern, Switzerland,
February 06th 2024.
</summary>
    <author>
      <name>Jessie Galasso-Carbonnel</name>
    </author>
    <author>
      <name>Chico Sundermann</name>
    </author>
    <link href="http://arxiv.org/abs/2402.15511v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2402.15511v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2409.03397v1</id>
    <updated>2024-09-05T10:14:59Z</updated>
    <published>2024-09-05T10:14:59Z</published>
    <title>Dynamic String Generation and C++-style Output in Fortran</title>
    <summary>  Using standard components of modern Fortran we present a technique to
dynamically generate strings with as little coding overhead as possible on the
application side. Additionally we demonstrate how this can be extended to allow
for output generation with a C++ stream-like look and feel.
</summary>
    <author>
      <name>Marcus Mohr</name>
    </author>
    <link href="http://arxiv.org/abs/2409.03397v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2409.03397v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2410.07918v1</id>
    <updated>2024-10-10T13:44:21Z</updated>
    <published>2024-10-10T13:44:21Z</published>
    <title>Accessible bridge between category theory and functional programming</title>
    <summary>  Monadic programming presents a significant challenge for many programmers. In
light of category theory, we offer a new perspective on the use of monads in
functional programming. This perspective is clarified through numerous examples
coded in Haskell.
</summary>
    <author>
      <name>Fethi Kadhi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in French language, Conference SMT 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2410.07918v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2410.07918v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2412.16161v1</id>
    <updated>2024-10-31T16:31:26Z</updated>
    <published>2024-10-31T16:31:26Z</published>
    <title>Antiassociative algebra in R: introducing the evitaicossa package</title>
    <summary>  In this short article I introduce the evitaicossa package which provides
functionality for antiassociative algebras in the R programming language; it is
available on CRAN at https://CRAN.R-project.org/package=evitaicossa.
</summary>
    <author>
      <name>Robin K. S. Hankinn</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2412.16161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2412.16161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2502.11344v1</id>
    <updated>2025-02-17T01:54:30Z</updated>
    <published>2025-02-17T01:54:30Z</published>
    <title>A Coq implementation of a Theory of Tagged Objects</title>
    <summary>  We present a first step towards the Coq implementation of the Theory of
Tagged Objects formalism. The concept of tagged types is encoded, and the
soundness proofs are discussed with some future work suggestions.
</summary>
    <author>
      <name>Matthew Gates</name>
    </author>
    <author>
      <name>Alex Potanin</name>
    </author>
    <link href="http://arxiv.org/abs/2502.11344v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2502.11344v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2502.15382v1</id>
    <updated>2025-02-21T11:06:24Z</updated>
    <published>2025-02-21T11:06:24Z</published>
    <title>Verified Parameterized Choreographies Technical Report</title>
    <summary>  This technical report contains the full set of definitions and projection
rules of the paper ``Verified Parameterized Choreographies'' by Rubbens et al.
It also supplements the artefact.
</summary>
    <author>
      <name>Robert Rubbens</name>
    </author>
    <author>
      <name>Petra van den Bos</name>
    </author>
    <author>
      <name>Marieke Huisman</name>
    </author>
    <link href="http://arxiv.org/abs/2502.15382v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2502.15382v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.6196v2</id>
    <updated>2012-06-11T07:11:09Z</updated>
    <published>2011-06-30T11:51:25Z</published>
    <title>On the behaviours produced by instruction sequences under execution</title>
    <summary>  We study several aspects of the behaviours produced by instruction sequences
under execution in the setting of the algebraic theory of processes known as
ACP. We use ACP to describe the behaviours produced by instruction sequences
under execution and to describe two protocols implementing these behaviours in
the case where the processing of instructions takes place remotely. We also
show that all finite-state behaviours considered in ACP can be produced by
instruction sequences under execution.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.3233/FI-2012-753</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.3233/FI-2012-753" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">36 pages, consolidates material from arXiv:0811.0436 [cs.PL],
  arXiv:0902.2859 [cs.PL], and arXiv:0905.2257 [cs.PL]; abstract and
  introduction rewritten, examples and proofs added</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Fundamenta Informaticae, 120(2):111--144, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1106.6196v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.6196v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N19, 68N30, 68Q05, 68Q10, 68Q55, 68Q85" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; D.2.1; F.1.1; F.1.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0111037v2</id>
    <updated>2001-11-16T07:07:24Z</updated>
    <published>2001-11-14T08:43:50Z</published>
    <title>User-friendly explanations for constraint programming</title>
    <summary>  In this paper, we introduce a set of tools for providing user-friendly
explanations in an explanation-based constraint programming system. The idea is
to represent the constraints of a problem as an hierarchy (a tree). Users are
then represented as a set of understandable nodes in that tree (a cut).
Classical explanations (sets of system constraints) just need to get projected
on that representation in order to be understandable by any user. We present
here the main interests of this idea.
</summary>
    <author>
      <name>Narendra Jussien</name>
    </author>
    <author>
      <name>Samir Ouis</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In A. Kusalik (ed), proceedings of the Eleventh International
  Workshop on Logic Programming Environments (WLPE'01), December 1, 2001,
  Paphos, Cyprus. cs.PL/0111042</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0111037v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0111037v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6;D.3.3; F.4.1;D.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2501.13194v1</id>
    <updated>2025-01-22T19:55:43Z</updated>
    <published>2025-01-22T19:55:43Z</published>
    <title>Corecursive Coding of High Computational Derivatives and Power Series</title>
    <summary>  We discuss the functional lazy techniques in generation and handling of
arbitrarily long sequences of derivatives of numerical expressions in one
``variable''; the domain to which the paper belongs is usually nicknamed
``Automatic differentiation''. Two models thereof are considered, the chains of
``pure'' derivatives, and the infinite power series, similar, but
algorithmically a bit different. We deal with their arithmetic/algebra, and
with more convoluted procedures, such as composition and reversion. Some more
specific applications of these structures are also presented.
</summary>
    <author>
      <name>Jerzy Karczmarczuk</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages, 2 figures. Category: cs.PL</arxiv:comment>
    <link href="http://arxiv.org/abs/2501.13194v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2501.13194v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9401102v1</id>
    <updated>1994-01-01T00:00:00Z</updated>
    <published>1994-01-01T00:00:00Z</published>
    <title>Mini-indexes for literate programs</title>
    <summary>  This paper describes how to implement a documentation technique that helps
readers to understand large programs or collections of programs, by providing
local indexes to all identifiers that are visible on every two-page spread. A
detailed example is given for a program that finds all Hamiltonian circuits in
an undirected graph.
</summary>
    <author>
      <name>Donald E. Knuth</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Software -- Concepts and Tools 15 (1994), 2--11</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9401102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9401102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9911001v2</id>
    <updated>1999-11-26T12:54:51Z</updated>
    <published>1999-11-04T11:14:45Z</published>
    <title>Semantics of Programming Languages: A Tool-Oriented Approach</title>
    <summary>  By paying more attention to semantics-based tool generation, programming
language semantics can significantly increase its impact. Ultimately, this may
lead to ``Language Design Assistants'' incorporating substantial amounts of
semantic knowledge.
</summary>
    <author>
      <name>Jan Heering</name>
    </author>
    <author>
      <name>Paul Klint</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures. Submitted to ACM SIGPLAN Notices</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM SIGPLAN Notices V. 35(3) March 2000 pp. 39-48</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/9911001v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9911001v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2; D.3.1; D.3.4; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0009029v1</id>
    <updated>2000-09-29T14:24:39Z</updated>
    <published>2000-09-29T14:24:39Z</published>
    <title>The Concurrent Language Aldwych</title>
    <summary>  Aldwych is proposed as the foundation of a general purpose language for
parallel applications. It works on a rule-based principle, and has aspects
variously of concurrent functional, logic and object-oriented languages, yet it
forms an integrated whole. It is intended to be applicable both for small-scale
parallel programming, and for large-scale open systems.
</summary>
    <author>
      <name>Matthew Huntbach</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at RULE 2000, First International Workshop on Rule-Based
  Programming, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0009029v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0009029v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010008v1</id>
    <updated>2000-10-03T15:38:46Z</updated>
    <published>2000-10-03T15:38:46Z</published>
    <title>The Light Lexicographic path Ordering</title>
    <summary>  We introduce syntactic restrictions of the lexicographic path ordering to
obtain the Light Lexicographic Path Ordering. We show that the light
lexicographic path ordering leads to a characterisation of the functions
computable in space bounded by a polynomial in the size of the inputs.
</summary>
    <author>
      <name>E. A. Cichon</name>
    </author>
    <author>
      <name>J-Y. Marion</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0010008v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010008v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.3; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105015v1</id>
    <updated>2001-05-08T13:13:04Z</updated>
    <published>2001-05-08T13:13:04Z</published>
    <title>The alldifferent Constraint: A Survey</title>
    <summary>  The constraint of difference is known to the constraint programming community
since Lauriere introduced Alice in 1978. Since then, several solving strategies
have been designed for this constraint. In this paper we give both a practical
overview and an abstract comparison of these different strategies.
</summary>
    <author>
      <name>W. J. van Hoeve</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 3 figures, paper accepted at the 6th Annual workshop of the
  ERCIM Working Group on Constraints</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109066v1</id>
    <updated>2001-09-24T15:39:57Z</updated>
    <published>2001-09-24T15:39:57Z</published>
    <title>CLP Approaches to 2D Angle Placements</title>
    <summary>  The paper presents two CLP approaches to 2D angle placements, implemented in
CHIP v.5.3. The first is based on the classical (rectangular) cumulative global
constraint, the second on the new trapezoidal cumulative global constraint.
Both approaches are applied to a specific presented.
</summary>
    <author>
      <name>Tomasz Szczygiel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at the 6th Annual Workshop of the ERCIM Working Group on
  Constraints, 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0109066v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109066v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0310020v1</id>
    <updated>2003-10-10T18:46:15Z</updated>
    <published>2003-10-10T18:46:15Z</published>
    <title>Pure Prolog Execution in 21 Rules</title>
    <summary>  A simple mathematical definition of the 4-port model for pure Prolog is
given. The model combines the intuition of ports with a compact representation
of execution state. Forward and backward derivation steps are possible. The
model satisfies a modularity claim, making it suitable for formal reasoning.
</summary>
    <author>
      <name>Marija Kulas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages. Appeared in Proc. of the 5th Workshop on Rule-Based
  Constraint Reasoning and Programming (RCoRP'03), within CP'03, Kinsale,
  September 2003</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0310020v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0310020v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.1; D.2.5; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0311002v1</id>
    <updated>2003-11-04T12:43:54Z</updated>
    <published>2003-11-04T12:43:54Z</published>
    <title>Computing Convex Hulls with a Linear Solver</title>
    <summary>  A programming tactic involving polyhedra is reported that has been widely
applied in the polyhedral analysis of (constraint) logic programs. The method
enables the computations of convex hulls that are required for polyhedral
analysis to be coded with linear constraint solving machinery that is available
in many Prolog systems.
  To appear in Theory and Practice of Logic Programming (TPLP)
</summary>
    <author>
      <name>Florence Benoy</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0311002v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0311002v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0311032v1</id>
    <updated>2003-11-21T06:18:19Z</updated>
    <published>2003-11-21T06:18:19Z</published>
    <title>A Very Short Self-Interpreter</title>
    <summary>  In this paper we would like to present a very short (possibly the shortest)
self-interpreter, based on a simplistic Turing-complete imperative language.
This interpreter explicitly processes the statements of the language, which
means the interpreter constitutes a description of the language inside that
same language. The paper does not require any specific knowledge; however,
experience in programming and a vivid imagination are beneficial.
</summary>
    <author>
      <name>Oleg Mazonka</name>
    </author>
    <author>
      <name>Daniel B. Cristofani</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0311032v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0311032v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0408045v1</id>
    <updated>2004-08-19T17:24:49Z</updated>
    <published>2004-08-19T17:24:49Z</published>
    <title>On computing the fixpoint of a set of boolean equations</title>
    <summary>  This paper presents a method for computing a least fixpoint of a system of
equations over booleans. The resulting computation can be significantly shorter
than the result of iteratively evaluating the entire system until a fixpoint is
reached.
</summary>
    <author>
      <name>Viktor Kuncak</name>
    </author>
    <author>
      <name>K. Rustan M. Leino</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0408045v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0408045v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0412043v1</id>
    <updated>2004-12-10T15:52:29Z</updated>
    <published>2004-12-10T15:52:29Z</published>
    <title>Widening Operators for Weakly-Relational Numeric Abstractions (Extended
  Abstract)</title>
    <summary>  We discuss the divergence problems recently identified in some extrapolation
operators for weakly-relational numeric domains. We identify the cause of the
divergences and point out that resorting to more concrete, syntactic domains
can be avoided by researching suitable algorithms for the elimination of
redundant constraints in the chosen representation.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Patricia M. Hill</name>
    </author>
    <author>
      <name>Elena Mazzi</name>
    </author>
    <author>
      <name>Enea Zaffanella</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0412043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0412043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0511092v1</id>
    <updated>2005-11-28T07:20:43Z</updated>
    <published>2005-11-28T07:20:43Z</published>
    <title>The SL synchronous language, revisited</title>
    <summary>  We revisit the SL synchronous programming model introduced by Boussinot and
De Simone (IEEE, Trans. on Soft. Eng., 1996). We discuss an alternative design
of the model including thread spawning and recursive definitions and we explore
some basic properties of the revised model: determinism, reactivity, CPS
translation to a tail recursive form, computational expressivity, and a
compositional notion of program equivalence.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Logic and Algebraic Programming 70 (15/02/2007) 121-150</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0511092v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0511092v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0512058v1</id>
    <updated>2005-12-14T13:42:17Z</updated>
    <published>2005-12-14T13:42:17Z</published>
    <title>Reactive concurrent programming revisited</title>
    <summary>  In this note we revisit the so-called reactive programming style, which
evolves from the synchronous programming model of the Esterel language by
weakening the assumption that the absence of an event can be detected
instantaneously. We review some research directions that have been explored
since the emergence of the reactive model ten years ago. We shall also outline
some questions that remain to be investigated.
</summary>
    <author>
      <name>Roberto Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Gerard Boudol</name>
    </author>
    <author>
      <name>Ilaria Castellani</name>
    </author>
    <author>
      <name>Frederic Boussinot</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop on Process Algebra (29/09/2006) 49-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0512058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0512058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701082v1</id>
    <updated>2007-01-12T18:43:48Z</updated>
    <published>2007-01-12T18:43:48Z</published>
    <title>Recurrence with affine level mappings is P-time decidable for CLP(R)</title>
    <summary>  In this paper we introduce a class of constraint logic programs such that
their termination can be proved by using affine level mappings. We show that
membership to this class is decidable in polynomial time.
</summary>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <author>
      <name>Alexander Serebrenik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701082v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701082v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701148v1</id>
    <updated>2007-01-24T07:03:17Z</updated>
    <published>2007-01-24T07:03:17Z</published>
    <title>Proceedings of the 16th Workshop in Logic-based Methods in Programming
  Environments (WLPE2006)</title>
    <summary>  This volume contains the papers presented at WLPE'06: the 16th Workshop on
Logic-based Methods in Programming Environments held on August 16, 2006 in the
Seattle Sheraton Hotel and Towers, Seattle, Washington (USA). It was organised
as a satellite workshop of ICLP'06, the 22th International Conference on Logic
Programming.
</summary>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <author>
      <name>Susana Munoz-Hernandez</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0701148v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701148v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701191v1</id>
    <updated>2007-01-30T15:20:07Z</updated>
    <published>2007-01-30T15:20:07Z</published>
    <title>The parallel implementation of the Astrée static analyzer</title>
    <summary>  The Astr\'{e}e static analyzer is a specialized tool that can prove the
absence of runtime errors, including arithmetic overflows, in large critical
programs. Keeping analysis times reasonable for industrial use is one of the
design objectives. In this paper, we discuss the parallel implementation of the
analysis.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/11575467_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/11575467_7" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">APLAS: Programming languages and systems (2005) 86-96</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701191v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701191v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.2145v2</id>
    <updated>2007-05-22T09:52:57Z</updated>
    <published>2007-05-15T13:44:35Z</published>
    <title>Elementary transformation analysis for Array-OL</title>
    <summary>  Array-OL is a high-level specification language dedicated to the definition
of intensive signal processing applications. Several tools exist for
implementing an Array-OL specification as a data parallel program. While
Array-OL can be used directly, it is often convenient to be able to deduce part
of the specification from a sequential version of the application. This paper
proposes such an analysis and examines its feasibility and its limits.
</summary>
    <author>
      <name>Paul Feautrier</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIP, INRIA Rhône-Alpes</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0705.2145v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.2145v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0706.0252v1</id>
    <updated>2007-06-02T06:18:48Z</updated>
    <published>2007-06-02T06:18:48Z</published>
    <title>Applying the Z-transform for the static analysis of floating-point
  numerical filters</title>
    <summary>  Digital linear filters are used in a variety of applications (sound
treatment, control/command, etc.), implemented in software, in hardware, or a
combination thereof. For safety-critical applications, it is necessary to bound
all variables and outputs of all filters. We give a compositional, effective
abstraction for digital linear filters expressed as block diagrams, yielding
sound, precise bounds for fixed-point or floating-point implementations of the
filters.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0706.0252v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0706.0252v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0707.1059v1</id>
    <updated>2007-07-06T23:58:45Z</updated>
    <published>2007-07-06T23:58:45Z</published>
    <title>Projection semantics for rigid loops</title>
    <summary>  A rigid loop is a for-loop with a counter not accessible to the loop body or
any other part of a program. Special instructions for rigid loops are
introduced on top of the syntax of the program algebra PGA. Two different
semantic projections are provided and proven equivalent. One of these is taken
to have definitional status on the basis of two criteria: `normative semantic
adequacy' and `indicative algorithmic adequacy'.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0707.1059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0707.1059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0710.4683v1</id>
    <updated>2007-10-25T09:07:39Z</updated>
    <published>2007-10-25T09:07:39Z</published>
    <title>The Challenges of Hardware Synthesis from C-Like Languages</title>
    <summary>  MANY TECHNIQUES for synthesizing digital hardware from C-like languages have
been proposed, but none have emerged as successful as Verilog or VHDL for
register-transfer-level design. This paper looks at two of the fundamental
challenges: concurrency and timing control.
</summary>
    <author>
      <name>Stephen A. Edwards</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted on behalf of EDAA (http://www.edaa.com/)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans Design, Automation and Test in Europe - DATE'05, Munich :
  Allemagne (2005)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0710.4683v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0710.4683v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0712.3116v1</id>
    <updated>2007-12-19T08:28:12Z</updated>
    <published>2007-12-19T08:28:12Z</published>
    <title>Proceedings of the 17th Workshop on Logic-based methods in Programming
  Environments (WLPE 2007)</title>
    <summary>  This volume contains the papers presented at WLPE 2007: the 17th Workshop on
Logic-based Methods in Programming Environments on 13th September, 2007 in
Porto, Portugal. It was held as a satellite workshop of ICLP 2007, the 23th
International Conference on Logic Programming.
</summary>
    <author>
      <name>Patricia Hill</name>
    </author>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <link href="http://arxiv.org/abs/0712.3116v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0712.3116v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0812.4973v1</id>
    <updated>2008-12-29T21:07:52Z</updated>
    <published>2008-12-29T21:07:52Z</published>
    <title>A Simple, Linear-Time Algorithm for x86 Jump Encoding</title>
    <summary>  The problem of space-optimal jump encoding in the x86 instruction set, also
known as branch displacement optimization, is described, and a linear-time
algorithm is given that uses no complicated data structures, no recursion, and
no randomization. The only assumption is that there are no array declarations
whose size depends on the negative of the size of a section of code (Hyde
2006), which is reasonable for real code.
</summary>
    <author>
      <name>Neil G. Dickson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0812.4973v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0812.4973v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.3920v1</id>
    <updated>2009-06-22T05:49:12Z</updated>
    <published>2009-06-22T05:49:12Z</published>
    <title>Reasoning About a Service-oriented Programming Paradigm</title>
    <summary>  This paper is about a new way for programming distributed applications: the
service-oriented one. It is a concept paper based upon our experience in
developing a theory and a language for programming services. Both the
theoretical formalization and the language interpreter showed us the evidence
that a new programming paradigm exists. In this paper we illustrate the basic
features it is characterized by.
</summary>
    <author>
      <name>Claudio Guidi</name>
    </author>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.2.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.2.6" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 2, 2009, pp. 67-81</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0906.3920v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.3920v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.5162v1</id>
    <updated>2009-07-29T15:38:02Z</updated>
    <published>2009-07-29T15:38:02Z</published>
    <title>Programming with Quantum Communication</title>
    <summary>  This work develops a formal framework for specifying, implementing, and
analysing quantum communication protocols. We provide tools for developing
simple proofs and analysing programs which involve communication, both via
quantum channels and exhibiting the LOCC (local operations, classical
communication) paradigm.
</summary>
    <author>
      <name>Anya Tafliovich</name>
    </author>
    <author>
      <name>Eric C. R. Hehner</name>
    </author>
    <link href="http://arxiv.org/abs/0907.5162v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.5162v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0908.4005v1</id>
    <updated>2009-08-27T13:02:23Z</updated>
    <published>2009-08-27T13:02:23Z</published>
    <title>jYang : A YANG parser in java</title>
    <summary>  The NETCONF configuration protocol of the IETF Network Work- ing Group
provides mechanisms to manipulate the configuration of network devices. YANG is
the language currently under consideration within the IETF to specify the data
models to be used in NETCONF . This report describes the design and development
of a syntax and semantics parser for YANG in java.
</summary>
    <author>
      <name>Emmanuel Nataf</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Festor</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0908.4005v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0908.4005v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0910.3321v1</id>
    <updated>2009-10-17T18:52:53Z</updated>
    <published>2009-10-17T18:52:53Z</published>
    <title>Iterators, Recursors and Interaction Nets</title>
    <summary>  We propose a method for encoding iterators (and recursion operators in
general) using interaction nets (INs). There are two main applications for
this: the method can be used to obtain a visual nota- tion for functional
programs; and it can be used to extend the existing translations of the
lambda-calculus into INs to languages with recursive types.
</summary>
    <author>
      <name>Ian Mackie</name>
    </author>
    <author>
      <name>Jorge Sousa Pinto</name>
    </author>
    <author>
      <name>Miguel Vilaca</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ISBN: 978-972-9348-18-1</arxiv:comment>
    <link href="http://arxiv.org/abs/0910.3321v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0910.3321v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.3583v1</id>
    <updated>2009-12-18T04:35:24Z</updated>
    <published>2009-12-18T04:35:24Z</published>
    <title>A Metamodel of Unit Testing for Object-Oriented Programming Languages</title>
    <summary>  A unit test is a method for verifying the accuracy and the proper functioning
of a portion of a program. This work consists to study the relation and the
approaches to test Object-Oriented Programming (OOP) programs and to propose a
metamodel that enables the programmer to write the tests while writing the
source code to be tested by exploiting the key features of OOP programming
languages such as inheritance, polymorphism, etc.
</summary>
    <author>
      <name>Martin Levesque</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0912.3583v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.3583v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.1022v1</id>
    <updated>2010-01-07T04:18:02Z</updated>
    <published>2010-01-07T04:18:02Z</published>
    <title>LXG Compiler - Design and Implementation</title>
    <summary>  LXG is a simple Pascal-like language. It is a functional programming language
developed for studying compiler design and implementation. The language
supports procedure and variable declarations, but no classes. This paper
reports the design and implementation of an LXG compiler. Test results are
presented as well.
</summary>
    <author>
      <name>Emil Vassev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">37 pages, 2 figures, grammar in BNF</arxiv:comment>
    <link href="http://arxiv.org/abs/1001.1022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.1022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1003.5758v1</id>
    <updated>2010-03-30T08:11:40Z</updated>
    <published>2010-03-30T08:11:40Z</published>
    <title>Proceedings Tenth International Workshop on Rule-Based Programming</title>
    <summary>  This volume contains the proceedings of RULE 2009: the tenth International
Workshop on Rule-Based Programming. It took place in June 28th 2009, Brasilia,
Brazil, as a satellite event of RDP 2009. The first Rule workshop was held in
Montreal in 2000, and subsequent editions took place in Firenze, Pittsburgh,
Valencia, Aachen, Nara, Seattle, Paris, and Hagenberg.
</summary>
    <author>
      <name>Ian Mackie</name>
    </author>
    <author>
      <name>Anamaria Martins Moreira</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.21</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.21" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 21, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1003.5758v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1003.5758v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.4109v1</id>
    <updated>2010-04-23T12:02:51Z</updated>
    <published>2010-04-23T12:02:51Z</published>
    <title>Operator-oriented programming: a new paradigm for implementing window
  interfaces and parallel algorithms</title>
    <summary>  We present a new programming paradigm which can be useful, in particular, for
implementing window interfaces and parallel algorithms. This paradigm allows a
user to define operators which can contain nested operators. The new paradigm
is called operator-oriented. One of the goals of this paradigm is to escape the
complexity of objects definitions inherent in many object-oriented languages
and to move to transparent algorithms definitions.
</summary>
    <author>
      <name>Pavel Ruzankin</name>
    </author>
    <link href="http://arxiv.org/abs/1004.4109v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.4109v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.0159v1</id>
    <updated>2010-07-01T13:14:39Z</updated>
    <published>2010-07-01T13:14:39Z</published>
    <title>Empowering Collections with Swarm Behavior</title>
    <summary>  Often, when modelling a system there are properties and operations that are
related to a group of objects rather than to a single object. In this paper we
extend Java with Swarm Behavior, a new composition operator that associates
behavior with a collection of instances. The lookup resolution of swarm
behavior is based on the element type of a collection and is thus orthogonal to
the collection hierarchy.
</summary>
    <author>
      <name>Adrian Kuhn</name>
    </author>
    <author>
      <name>David Erni</name>
    </author>
    <author>
      <name>Marcus Denker</name>
    </author>
    <link href="http://arxiv.org/abs/1007.0159v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.0159v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.2850v1</id>
    <updated>2010-10-14T08:14:10Z</updated>
    <published>2010-10-14T08:14:10Z</published>
    <title>Steering Fragments of Instruction Sequences</title>
    <summary>  A steering fragment of an instruction sequence consists of a sequence of
steering instructions. These are decision points involving the check of a
propositional statement in sequential logic. The question is addressed why
composed propositional statements occur in steering fragments given the fact
that a straightforward transformation allows their elimination. A survey is
provided of constraints that may be implicitly assumed when composed
propositional statements occur in a meaningful instruction sequence.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <link href="http://arxiv.org/abs/1010.2850v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.2850v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5569v1</id>
    <updated>2010-10-27T05:04:27Z</updated>
    <published>2010-10-27T05:04:27Z</published>
    <title>Static vs Dynamic SAGAs</title>
    <summary>  SAGAs calculi (or simply SAGAs) have been proposed by Bruni et al. as a model
for long-running transactions. The approach therein can be considered static,
while a dynamic approach has been proposed by Lanese and Zavattaro. In this
paper we first extend both static SAGAs (in the centralized interruption
policy) and dynamic SAGAs to deal with nesting, then we compare the two
approaches.
</summary>
    <author>
      <name>Ivan Lanese</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Focus Team, University of Bologna/INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.38.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.38.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2010, arXiv:1010.5308</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 38, 2010, pp. 51-65</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5569v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5569v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5694v1</id>
    <updated>2010-10-27T14:20:46Z</updated>
    <published>2010-10-27T14:20:46Z</published>
    <title>Events! (Reactivity in urbiscript)</title>
    <summary>  Urbi SDK is a software platform for the development of portable robotic
applications. It features the Urbi UObject C++ middleware, to manage hardware
drivers and/or possibly remote software components, and urbiscript, a domain
specific programming language to orchestrate them. Reactivity is a key feature
of Urbi SDK, embodied in events in urbiscript. This paper presents the support
for events in urbiscript.
</summary>
    <author>
      <name>Jean-Christophe Baillie</name>
    </author>
    <author>
      <name>Akim Demaille</name>
    </author>
    <author>
      <name>Quentin Hocquet</name>
    </author>
    <author>
      <name>Matthieu Nottale</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">DSLRob'10</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.5694v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5694v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.1783v3</id>
    <updated>2011-09-27T14:12:46Z</updated>
    <published>2010-11-08T12:16:37Z</published>
    <title>OCamlJIT 2.0 - Faster Objective Caml</title>
    <summary>  This paper presents the current state of an ongoing research project to
improve the performance of the OCaml byte-code interpreter using Just-In-Time
native code generation. Our JIT engine OCamlJIT2 currently runs on x86-64
processors, mimicing precisely the behavior of the OCaml virtual machine. Its
design and implementation is described, and performance measures are given.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, 12 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.1783v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.1783v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.5560v1</id>
    <updated>2010-12-27T06:30:03Z</updated>
    <published>2010-12-27T06:30:03Z</published>
    <title>Strategic programming on graph rewriting systems</title>
    <summary>  We describe a strategy language to control the application of graph rewriting
rules, and show how this language can be used to write high-level declarative
programs in several application areas. This language is part of a graph-based
programming tool built within the port-graph transformation and visualisation
environment PORGY.
</summary>
    <author>
      <name>Maribel Fernández</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Namet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.44.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.44.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings IWS 2010, arXiv:1012.5337</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 44, 2010, pp. 1-20</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1012.5560v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.5560v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0363v1</id>
    <updated>2011-07-28T17:46:20Z</updated>
    <published>2011-07-28T17:46:20Z</published>
    <title>Typesafe Modeling in Text Mining</title>
    <summary>  Based on the concept of annotation-based agents, this report introduces tools
and a formal notation for defining and running text mining experiments using a
statically typed domain-specific language embedded in Scala. Using machine
learning for classification as an example, the framework is used to develop and
document text mining experiments, and to show how the concept of generic,
typesafe annotation corresponds to a general information model that goes beyond
text processing.
</summary>
    <author>
      <name>Fabian Steeg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">63 pages, in German</arxiv:comment>
    <link href="http://arxiv.org/abs/1108.0363v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0363v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.IR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.4; I.2.5; I.2.7" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0323v1</id>
    <updated>2011-09-01T22:59:50Z</updated>
    <published>2011-09-01T22:59:50Z</published>
    <title>Proceedings IFIP Working Conference on Domain-Specific Languages</title>
    <summary>  This volume is the proceedings of the second IFIP Working Conference on
Domain-Specific Languages (DSL 2011). It contains 2 abstracts of invited
presentations, 7 peer-reviewed articles selected by the program committee from
14 submissions, and 6 lecture notes for the distilled tutorials that we
solicited.
</summary>
    <author>
      <name>Olivier Danvy</name>
    </author>
    <author>
      <name>Chung-chieh Shan</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This volume is dedicated to the memory of Anne-Fran\c{c}oise Le Meur
  (1972--2011)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0323v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0323v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.4048v1</id>
    <updated>2011-09-19T14:51:27Z</updated>
    <published>2011-09-19T14:51:27Z</published>
    <title>Implementing Continuation based language in GCC</title>
    <summary>  We have implemented C like Continuation based programming language.
Continuation based C, CbC was implemented using micro-C on various
architecture, and we have tried several CbC programming experiments. Here we
report new implementation of CbC compiler based on GCC 4.2.3. Since it contains
full C capability, we can use CbC and C in a mixture.
</summary>
    <author>
      <name>Shinji Kono</name>
    </author>
    <author>
      <name>Kento Yogi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Continuation Festa 2008 Tokyo</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.4048v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.4048v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.1866v1</id>
    <updated>2011-10-09T18:46:04Z</updated>
    <published>2011-10-09T18:46:04Z</published>
    <title>Putting Instruction Sequences into Effect</title>
    <summary>  An attempt is made to define the concept of execution of an instruction
sequence. It is found to be a special case of directly putting into effect of
an instruction sequence. Directly putting into effect of an instruction
sequences comprises interpretation as well as execution. Directly putting into
effect is a special case of putting into effect with other special cases
classified as indirectly putting into effect.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <link href="http://arxiv.org/abs/1110.1866v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.1866v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.2350v2</id>
    <updated>2013-01-16T13:40:51Z</updated>
    <published>2011-10-11T12:35:00Z</published>
    <title>Certifying and reasoning about cost annotations of functional programs</title>
    <summary>  We present a so-called labelling method to insert cost annotations in a
higher-order functional program, to certify their correctness with respect to a
standard compilation chain to assembly code including safe memory management,
and to reason on them in a higher-order Hoare logic.
</summary>
    <author>
      <name>Roberto M. Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Yann Regis-Gianas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS, INRIA Paris - Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Higher-Order and Symbolic Computation (2013)</arxiv:comment>
    <link href="http://arxiv.org/abs/1110.2350v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.2350v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4742v1</id>
    <updated>2011-11-21T05:24:59Z</updated>
    <published>2011-11-21T05:24:59Z</published>
    <title>Solving the TTC 2011 Compiler Optimization Case with GrGen.NET</title>
    <summary>  The challenge of the Compiler Optimization Case is to perform local
optimizations and instruction selection on the graph-based intermediate
representation of a compiler. The case is designed to compare participating
tools regarding their performance. We tackle this task employing the general
purpose graph rewrite system GrGen.NET (www.grgen.net).
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 42-53</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4742v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4742v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4757v1</id>
    <updated>2011-11-21T05:27:20Z</updated>
    <published>2011-11-21T05:27:20Z</published>
    <title>Saying Hello World with GrGen.NET - A Solution to the TTC 2011
  Instructive Case</title>
    <summary>  We introduce the graph transformation tool GrGen.NET (www.grgen.net) by
solving the Hello World Case of the Transformation Tool Contest 2011 which
consists of a collection of small transformation tasks; for each task a section
is given explaining our implementation.
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 281-294</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4757v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4757v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.3247v1</id>
    <updated>2012-02-15T09:41:45Z</updated>
    <published>2012-02-15T09:41:45Z</published>
    <title>Lambda-lifting and CPS conversion in an imperative language</title>
    <summary>  This paper is a companion technical report to the article
"Continuation-Passing C: from threads to events through continuations". It
contains the complete version of the proofs of correctness of lambda-lifting
and CPS-conversion presented in the article.
</summary>
    <author>
      <name>Gabriel Kerneis</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Juliusz Chroboczek</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1011.4558</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.3247v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.3247v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.4269v1</id>
    <updated>2012-02-20T09:44:47Z</updated>
    <published>2012-02-20T09:44:47Z</published>
    <title>Live-Musikprogrammierung in Haskell</title>
    <summary>  We aim to compose algorithmic music in an interactive way with multiple
participants. To this end we develop an interpreter for a sub-language of the
non-strict functional programming language Haskell that allows to modify the
program during its execution. Our system can be used both for musical
live-coding and for demonstration and education of functional programming.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures, 5. Arbeitstagung Programmiersprachen 2012,
  ATPS'12</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.4269v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.4269v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.2566v1</id>
    <updated>2012-04-11T20:52:29Z</updated>
    <published>2012-04-11T20:52:29Z</published>
    <title>Synthesising Choreographies from Local Session Types (extended version)</title>
    <summary>  Designing and analysing multiparty distributed interactions can be achieved
either by means of a global view (e.g. in choreography-based approaches) or by
composing available computational entities (e.g. in service orchestration).
This paper proposes a typing systems which allows, under some conditions, to
synthesise a choreography (i.e. a multiparty global type) from a set of local
session types which describe end-point behaviours (i.e. local types).
</summary>
    <author>
      <name>Julien Lange</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <link href="http://arxiv.org/abs/1204.2566v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.2566v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1211.3476v1</id>
    <updated>2012-11-15T01:33:41Z</updated>
    <published>2012-11-15T01:33:41Z</published>
    <title>Proceedings 6th Workshop on Membrane Computing and Biologically Inspired
  Process Calculi</title>
    <summary>  This volume contains the papers presented at the 6th Membrane Computing and
Biologically Inspired Process Calculi (MeCBIC 2012), a satellite workshop of
the 23rd International Conference on Concurrency Theory (CONCUR) held on 8th
September 2012 in Newcastle upon Tyne, UK.
</summary>
    <author>
      <name>Gabriel Ciobanu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Romanian Academy, Institute of Computer Science</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.100</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.100" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 100, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1211.3476v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1211.3476v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; F.3.2; G.3; J.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.6836v1</id>
    <updated>2013-01-29T06:02:21Z</updated>
    <published>2013-01-29T06:02:21Z</published>
    <title>Towards Interactive Object-Oriented Programming</title>
    <summary>  To represent interactive objects, we propose a choice-disjunctive declaration
statement of the form S R where S;R are the (procedure or field) declaration
statements within a class. This statement has the following semantics: request
the user to choose one between S and R when an object of this class is created.
This statement is useful for representing interactive objects that require
interactions with the user.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Kyunghwan Park</name>
    </author>
    <author>
      <name>Mi-Young Park</name>
    </author>
    <link href="http://arxiv.org/abs/1301.6836v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.6836v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.5768v1</id>
    <updated>2013-03-22T20:02:38Z</updated>
    <published>2013-03-22T20:02:38Z</published>
    <title>Live music programming in Haskell</title>
    <summary>  We aim for composing algorithmic music in an interactive way with multiple
participants. To this end we have developed an interpreter for a sub-language
of the non-strict functional programming language Haskell that allows the
modification of a program during its execution. Our system can be used both for
musical live-coding and for demonstration and education of functional
programming.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 2 figures, Linux Audio Conference 2013. This is a
  translation and update of the ATPS-2012 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1303.5768v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.5768v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.4957v1</id>
    <updated>2013-05-21T20:35:20Z</updated>
    <published>2013-05-21T20:35:20Z</published>
    <title>Propositional Encoding of Constraints over Tree-Shaped Data</title>
    <summary>  We present a functional programming language for specifying constraints over
tree-shaped data. The language allows for Haskell-like algebraic data types and
pattern matching. Our constraint compiler CO4 translates these programs into
satisfiability problems in propositional logic. We present an application from
the area of automated analysis of (non-)termination of rewrite systems.
</summary>
    <author>
      <name>Alexander Bau</name>
    </author>
    <author>
      <name>Johannes Waldmann</name>
    </author>
    <link href="http://arxiv.org/abs/1305.4957v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.4957v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.6108v2</id>
    <updated>2013-08-03T12:18:41Z</updated>
    <published>2013-05-27T05:22:24Z</published>
    <title>Bounded Choice Queries for Logic Programming</title>
    <summary>  Adding versatile interactions to goals and queries in logic programming is an
essential task. Unfortunately, existing logic languages can take input from the
user only via the $read$ construct.
  We propose to add a new interactive goal to allow for more controlled and
more guided participation from the user. We illustrate our idea via \muprolog,
an extension of Prolog with bounded choice goals.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.6108v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.6108v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.2328v1</id>
    <updated>2013-07-09T03:45:41Z</updated>
    <published>2013-07-09T03:45:41Z</published>
    <title>A Haskell Library for Term Rewriting</title>
    <summary>  We present a Haskell library for first-order term rewriting covering basic
operations on positions, terms, contexts, substitutions and rewrite rules. This
effort is motivated by the increasing number of term rewriting tools that are
written in Haskell.
</summary>
    <author>
      <name>Bertram Felgenhauer</name>
    </author>
    <author>
      <name>Martin Avanzini</name>
    </author>
    <author>
      <name>Christian Sternagel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">1st International Workshop on Haskell And Rewriting Techniques, HART
  2013, 6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.2328v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.2328v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4655v1</id>
    <updated>2013-07-17T14:42:55Z</updated>
    <published>2013-07-17T14:42:55Z</published>
    <title>Compilation for QCSP</title>
    <summary>  We propose in this article a framework for compilation of quantified
constraint satisfaction problems (QCSP). We establish the semantics of this
formalism by an interpretation to a QCSP. We specify an algorithm to compile a
QCSP embedded into a search algorithm and based on the inductive semantics of
QCSP. We introduce an optimality property and demonstrate the optimality of the
interpretation of the compiled QCSP.
</summary>
    <author>
      <name>Igor Stéphan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4655v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4655v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.2055v3</id>
    <updated>2013-08-22T06:21:25Z</updated>
    <published>2013-08-09T09:03:57Z</published>
    <title>Proceedings of the 23rd Workshop on Logic-based methods in Programming
  Environments (WLPE 2013)</title>
    <summary>  This volume contains the papers presented at the 23rd Workshop on Logic-based
Methods in Programming Environments (WLPE 2013), which was held in Istanbul,
Turkey, on August 24 &amp; 25 2013 as a satellite event of the 29th International
Conference on Logic Programming, (ICLP 2013).
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <author>
      <name>Jose Morales</name>
    </author>
    <link href="http://arxiv.org/abs/1308.2055v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.2055v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1251v1</id>
    <updated>2013-09-05T07:45:00Z</updated>
    <published>2013-09-05T07:45:00Z</published>
    <title>Pattern Matching via Choice Existential Quantifications in Imperative
  Languages</title>
    <summary>  Selection statements -- if-then-else, switch and try-catch -- are commonly
used in modern imperative programming languages. We propose another selection
statement called a {\it choice existentially quantified statement}. This
statement turns out to be quite useful for pattern matching among several
merits. Examples will be provided for this statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.1251v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1251v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5500v1</id>
    <updated>2013-09-21T16:48:22Z</updated>
    <published>2013-09-21T16:48:22Z</published>
    <title>PRoMoTo 2013 proceedings</title>
    <summary>  Programming for Mobile and Touch (PRoMoTo'13) was held at the 2013 ACM
SIGPLAN conference on Systems, Programming, Languages and Applications (SPLASH
2013), October 2013 in Indianapolis, USA. Submissions for this event were
invited in the general area of mobile and touch-oriented programming languages
and programming environments, and teaching of programming for mobile devices.
These are proceedings of the PRoMoTo'13.
</summary>
    <author>
      <name>Judith Bishop</name>
    </author>
    <author>
      <name>Nikolai Tillmann</name>
    </author>
    <author>
      <name>Arno Puder</name>
    </author>
    <author>
      <name>Vinayak Naik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Published in PRoMoTo'13</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.5500v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5500v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.3; D.2.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.4283v2</id>
    <updated>2014-06-13T12:28:39Z</updated>
    <published>2013-10-16T07:16:49Z</published>
    <title>Abstract interpretation as anti-refinement</title>
    <summary>  This article shows a correspondence between abstract interpretation of
imperative programs and the refinement calculus: in the refinement calculus, an
abstract interpretation of a program is a specification which is a function.
  This correspondence can be used to guide the design of mechanically verified
static analyses, keeping the correctness proof well separated from the
heuristic parts of the algorithms.
</summary>
    <author>
      <name>Arnaud Spiwack</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Working paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1310.4283v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.4283v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.4454v2</id>
    <updated>2013-12-19T07:39:12Z</updated>
    <published>2013-12-16T18:39:55Z</published>
    <title>Exploiting Parallelism in Coalgebraic Logic Programming</title>
    <summary>  We present a parallel implementation of Coalgebraic Logic Programming (CoALP)
in the programming language Go. CoALP was initially introduced to reflect
coalgebraic semantics of logic programming, with coalgebraic derivation
algorithm featuring both corecursion and parallelism. Here, we discuss how the
coalgebraic semantics influenced our parallel implementation of logic
programming.
</summary>
    <author>
      <name>Ekaterina Komendantskaya</name>
    </author>
    <author>
      <name>Martin Schmidt</name>
    </author>
    <author>
      <name>Jónathan Heras</name>
    </author>
    <link href="http://arxiv.org/abs/1312.4454v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.4454v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.0076v1</id>
    <updated>2014-04-01T00:37:24Z</updated>
    <published>2014-04-01T00:37:24Z</published>
    <title>Towards a GPU-based implementation of interaction nets</title>
    <summary>  We present ingpu, a GPU-based evaluator for interaction nets that heavily
utilizes their potential for parallel evaluation. We discuss advantages and
challenges of the ongoing implementation of ingpu and compare its performance
to existing interaction nets evaluators.
</summary>
    <author>
      <name>Eugen Jiresch</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Technische Universität Wien</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.143.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.143.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2012, arXiv:1403.7579</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 143, 2014, pp. 41-53</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1404.0076v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.0076v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.4666v1</id>
    <updated>2014-04-17T22:36:44Z</updated>
    <published>2014-04-17T22:36:44Z</published>
    <title>Object-Oriented Parallel Programming</title>
    <summary>  We introduce an object-oriented framework for parallel programming, which is
based on the observation that programming objects can be naturally interpreted
as processes. A parallel program consists of a collection of persistent
processes that communicate by executing remote methods. We discuss code
parallelization and process persistence, and explain the main ideas in the
context of computations with very large data objects.
</summary>
    <author>
      <name>Edward Givelberg</name>
    </author>
    <link href="http://arxiv.org/abs/1404.4666v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.4666v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3099v1</id>
    <updated>2014-05-13T10:47:12Z</updated>
    <published>2014-05-13T10:47:12Z</published>
    <title>The Correctness of Launchbury's Natural Semantics for Lazy Evaluation</title>
    <summary>  In his seminal paper "A Natural Semantics for Lazy Evaluation", John
Launchbury proves his semantics correct with respect to a denotational
semantics. We machine-checked the proof and found it to fail, and provide two
ways to fix it: One by taking a detour via a modified natural semantics with an
explicit stack, and one by adjusting the denotational semantics of heaps.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3099v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3099v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.00720v1</id>
    <updated>2015-01-04T21:02:34Z</updated>
    <published>2015-01-04T21:02:34Z</published>
    <title>Concept-oriented programming: from classes to concepts and from
  inheritance to inclusion</title>
    <summary>  For the past several decades, programmers have been modeling things in the
world with trees using hierarchies of classes and object-oriented programming
(OOP) languages. In this paper, we describe a novel approach to programming,
called concept-oriented programming (COP), which generalizes classes and
inheritance by introducing concepts and inclusion, respectively.
</summary>
    <author>
      <name>Alexandr Savinov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures. arXiv admin note: text overlap with
  arXiv:1409.3947</arxiv:comment>
    <link href="http://arxiv.org/abs/1501.00720v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.00720v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00527v1</id>
    <updated>2015-04-02T12:40:18Z</updated>
    <published>2015-04-02T12:40:18Z</published>
    <title>Functional Programming is Free</title>
    <summary>  A paper has recently been published in SIAM-JC. This paper is faulty: 1) The
standard requirements about the definition of an algorithm are not respected,
2) The main point in the complexity study, namely the functional programming
component, is absent. The Editorial Board of the SIAM JC had been warned a
confirmed publication would be openly commented, it is the role of this text.
</summary>
    <author>
      <name>Francis Sergeraert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">26 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.00527v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00527v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="14Q20, 55-04" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00977v1</id>
    <updated>2015-04-04T03:30:22Z</updated>
    <published>2015-04-04T03:30:22Z</published>
    <title>Declaratively solving Google Code Jam problems with Picat</title>
    <summary>  In this paper we present several examples of solving algorithmic problems
from the Google Code Jam programming contest with Picat programming language
using declarative techniques: constraint logic programming and tabled logic
programming. In some cases the use of Picat simplifies the implementation
compared to conventional imperative programming languages, while in others it
allows to directly convert the problem statement into an efficiently solvable
declarative problem specification without inventing an imperative algorithm.
</summary>
    <author>
      <name>Sergii Dymchenko</name>
    </author>
    <author>
      <name>Mariia Mykhailova</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-19686-2_4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-19686-2_4" rel="related"/>
    <link href="http://arxiv.org/abs/1504.00977v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00977v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.02603v1</id>
    <updated>2015-04-10T09:31:32Z</updated>
    <published>2015-04-10T09:31:32Z</published>
    <title>A Simple Parallel Implementation of Interaction Nets in Haskell</title>
    <summary>  Due to their "inherent parallelism", interaction nets have since their
introduction been considered as an attractive implementation mechanism for
functional programming. We show that a simple highly-concurrent implementation
in Haskell can achieve promising speed-ups on multiple cores.
</summary>
    <author>
      <name>Wolfram Kahl</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.179.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.179.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2014, arXiv:1504.01927</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 179, 2015, pp. 33-47</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.02603v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.02603v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.00723v3</id>
    <updated>2015-12-07T16:26:15Z</updated>
    <published>2015-07-02T12:34:20Z</published>
    <title>Theory of Programs</title>
    <summary>  A general theory of programs, programming and programming languages built up
from a few concepts of elementary set theory. Derives, as theorems, properties
treated as axioms by classic approaches to programming. Covers sequential and
concurrent computation.
</summary>
    <author>
      <name>Bertrand Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/1507.00723v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.00723v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; D.1.5; D.1.3; D.2.1; D.2.4; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08093v1</id>
    <updated>2015-07-29T10:24:33Z</updated>
    <published>2015-07-29T10:24:33Z</published>
    <title>Property irrelevant predicates</title>
    <summary>  Although slicing removes code which has no bearing on property checking.
However even after that, our study has found that there are predicates in
program which have no bearing on property validation, although slicing could
not eliminate them. We have cope up with a criteria to identify such predicates
and then give a process to leverage them in scale up of property checking.
</summary>
    <author>
      <name>Shrawan Kumar</name>
    </author>
    <link href="http://arxiv.org/abs/1507.08093v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08093v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03263v4</id>
    <updated>2018-05-07T10:45:07Z</updated>
    <published>2015-08-13T16:34:22Z</published>
    <title>Logic Programming with Macro Connectives</title>
    <summary>  Logic programming such as Prolog is often sequential and slow because each
execution step processes only a single, $micro$ connective. To fix this
problem, we propose to use $macro$ connectives as the means of improving both
readability and performance.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, some new connectives are added to version 3</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.03263v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03263v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03837v2</id>
    <updated>2018-01-24T05:13:48Z</updated>
    <published>2015-08-16T15:36:30Z</published>
    <title>Incorporating User Interaction into Imperative Languages</title>
    <summary>  In this paper, we present two new forms of the $write$ statement: one of the
form $write(x);G$ where $G$ is a statement and the other of the form
$write(x);D$ where $D$ is a module. The former is a generalization of
traditional $write$ statement and is quite useful. The latter is useful for
implementing interactive modules.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages. arXiv admin note: text overlap with arXiv:1709.08193</arxiv:comment>
    <link href="http://arxiv.org/abs/1508.03837v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03837v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07161v1</id>
    <updated>2016-08-23T06:51:27Z</updated>
    <published>2016-08-23T06:51:27Z</published>
    <title>A Simple Guide to S3 Methods</title>
    <summary>  Writing functions in R is an important skill for anyone using R. S3 methods
allow for functions to be generalised across different classes and are easy to
implement. Whilst many R users are be adept at creating their own functions, it
seems that there is room for many more to take advantage of R's S3 methods.
This paper provides a simple and targeted guide to explain what S3 methods are,
why people should them, and how they can do it.
</summary>
    <author>
      <name>Nicholas Tierney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.07161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07531v2</id>
    <updated>2016-08-30T15:32:33Z</updated>
    <published>2016-08-26T17:28:06Z</published>
    <title>Syntax and semantics of the weak consistency model specification
  language cat</title>
    <summary>  We provide the syntax and semantics of the cat language, a domain specific
language to describe consistency properties of parallel/distributed programs.
The language is implemented in the herd7 too
(http://diy.inria.fr/doc/herd.html)l.
</summary>
    <author>
      <name>Jade Alglave</name>
    </author>
    <author>
      <name>Patrick Cousot</name>
    </author>
    <author>
      <name>Luc Maranget</name>
    </author>
    <link href="http://arxiv.org/abs/1608.07531v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07531v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.08651v1</id>
    <updated>2016-11-26T02:45:35Z</updated>
    <published>2016-11-26T02:45:35Z</published>
    <title>Proceedings of the 4th and 5th International Workshop on Trends in
  Functional Programming in Education</title>
    <summary>  This volume contains the proceedings of the Fourth and Fifth International
Workshops on Trends in Functional Programming in Education, TFPIE 2015 and
TFPIE 2016, which were held on June 2, 2015 in Sophia-Antipolis, France, and on
June 7, 2016 at the University of Maryland College Park in the USA,
respectively.
</summary>
    <author>
      <name>Johan Jeuring</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Utrecht University and Open University, The Netherlands</arxiv:affiliation>
    </author>
    <author>
      <name>Jay McCarthy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Massachusetts Lowell</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.230</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.230" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 230, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1611.08651v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.08651v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.06892v1</id>
    <updated>2017-10-18T18:43:38Z</updated>
    <published>2017-10-18T18:43:38Z</published>
    <title>Typesafe Abstractions for Tensor Operations</title>
    <summary>  We propose a typesafe abstraction to tensors (i.e. multidimensional arrays)
exploiting the type-level programming capabilities of Scala through
heterogeneous lists (HList), and showcase typesafe abstractions of common
tensor operations and various neural layers such as convolution or recurrent
neural networks. This abstraction could lay the foundation of future typesafe
deep learning frameworks that runs on Scala/JVM.
</summary>
    <author>
      <name>Tongfei Chen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3136000.3136001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3136000.3136001" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Tongfei Chen (2017): Typesafe Abstractions for Tensor Operations
  (Short Paper). In Proceedings of the 8th ACM SIGPLAN International Symposium
  on Scala. pp. 45-50</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1710.06892v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.06892v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.01344v1</id>
    <updated>2018-08-03T20:22:53Z</updated>
    <published>2018-08-03T20:22:53Z</published>
    <title>A Compiler-Compiler for DSL Embedding</title>
    <summary>  In this paper, we present a framework to generate compilers for embedded
domain-specific languages (EDSLs). This framework provides facilities to
automatically generate the boilerplate code required for building DSL compilers
on top of extensible optimizing compilers. We evaluate the practicality of our
framework by demonstrating several use-cases successfully built with it.
</summary>
    <author>
      <name>Amir Shaikhha</name>
    </author>
    <author>
      <name>Vojin Jovanovic</name>
    </author>
    <author>
      <name>Christoph Koch</name>
    </author>
    <link href="http://arxiv.org/abs/1808.01344v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.01344v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.07770v1</id>
    <updated>2018-08-23T14:07:39Z</updated>
    <published>2018-08-23T14:07:39Z</published>
    <title>Transpiling Programmable Computable Functions to Answer Set Programs</title>
    <summary>  Programming Computable Functions (PCF) is a simplified programming language
which provides the theoretical basis of modern functional programming
languages. Answer set programming (ASP) is a programming paradigm focused on
solving search problems. In this paper we provide a translation from PCF to
ASP. Using this translation it becomes possible to specify search problems
using PCF.
</summary>
    <author>
      <name>Ingmar Dasseville</name>
    </author>
    <author>
      <name>Marc Denecker</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, Accepted for presentation in WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.07770v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.07770v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.00724v1</id>
    <updated>2018-10-01T14:34:14Z</updated>
    <published>2018-10-01T14:34:14Z</published>
    <title>Pre-proceedings of the 26th International Workshop on Functional and
  Logic Programming (WFLP 2018)</title>
    <summary>  This volume constitutes the pre-proceedings of the 26th International
Workshop on Functional and Logic Programming (WFLP 2018). It is formed of those
papers selected by the program committee for presentation at the workshop.
After discussion at the workshop, the program committee will select a number of
papers to be invited for the second round of refereeing and selection for the
formal proceedings.
</summary>
    <author>
      <name>Josep Silva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Papers selected for presentation at WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1810.00724v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.00724v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.01190v1</id>
    <updated>2018-10-02T12:00:41Z</updated>
    <published>2018-10-02T12:00:41Z</published>
    <title>Inference Over Programs That Make Predictions</title>
    <summary>  This abstract extends on the previous work (arXiv:1407.2646,
arXiv:1606.00075) on program induction using probabilistic programming. It
describes possible further steps to extend that work, such that, ultimately,
automatic probabilistic program synthesis can generalise over any reasonable
set of inputs and outputs, in particular in regard to text, image and video
data.
</summary>
    <author>
      <name>Yura Perov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The International Conference on Probabilistic Programming, 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1810.01190v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.01190v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.ML" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.02254v1</id>
    <updated>2018-10-04T14:51:58Z</updated>
    <published>2018-10-04T14:51:58Z</published>
    <title>Deriving sorting algorithms via abductive logic program transformation</title>
    <summary>  Logic program transformation by the unfold/fold method ad- vocates the
writing of correct logic programs via the application of some rules to a naive
program. This work focuses on how to overcome subgoal- introduction
difficulties in synthesizing efficient sorting algorithms from an naive sorting
algorithm, through logic program transformation and abductive reasoning.
</summary>
    <author>
      <name>Manuel Hernández</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">19 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1810.02254v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.02254v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.09367v1</id>
    <updated>2018-10-22T15:36:39Z</updated>
    <published>2018-10-22T15:36:39Z</published>
    <title>Canonicity and normalisation for Dependent Type Theory</title>
    <summary>  We show canonicity and normalization for dependent type theory with a
cumulative sequence of universes and a type of Boolean. The argument follows
the usual notion of reducibility, going back to Godel's Dialectica
interpretation and the work of Tait. A key feature of our approach is the use
of a proof relevant notion of reducibility.
</summary>
    <author>
      <name>Thierry Coquand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1810.09367v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.09367v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.09613v1</id>
    <updated>2018-10-23T00:48:21Z</updated>
    <published>2018-10-23T00:48:21Z</published>
    <title>Refining Santa: An Exercise in Efficient Synchronization</title>
    <summary>  The Santa Claus Problem is an intricate exercise for concurrent programming.
This paper outlines the refinement steps to develop a highly efficient
implementation with concurrent objects, starting from a simple specification.
The efficiency of the implementation is compared to those in other languages.
</summary>
    <author>
      <name>Emil Sekerinski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University</arxiv:affiliation>
    </author>
    <author>
      <name>Shucai Yao</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McMaster University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.282.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.282.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Refine 2018, arXiv:1810.08739</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 282, 2018, pp. 68-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1810.09613v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.09613v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.05969v1</id>
    <updated>2019-09-12T22:23:43Z</updated>
    <published>2019-09-12T22:23:43Z</published>
    <title>A Note On Compliance Relations And Fixed Points</title>
    <summary>  We study compliance relations between behavioural contracts in a syntax
independent setting based on Labelled Transition Systems. We introduce a
fix-point based family of compliance relations, and show that many compliance
relations appearing in literature belong to this family.
</summary>
    <author>
      <name>Maurizio Murgia</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università degli Studi di Cagliari</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.304.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.304.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2019, arXiv:1909.05242</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 304, 2019, pp. 38-47</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1909.05969v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.05969v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.05970v1</id>
    <updated>2019-09-12T22:24:02Z</updated>
    <published>2019-09-12T22:24:02Z</published>
    <title>Rusty Variation: Deadlock-free Sessions with Failure in Rust</title>
    <summary>  Rusty Variation (RV) is a library for session-typed communication in Rust
which offers strong compile-time correctness guarantees. Programs written using
RV are guaranteed to respect a specified protocol, and are guaranteed to be
free from deadlocks and races.
</summary>
    <author>
      <name>Wen Kokke</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Edinburgh</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.304.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.304.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2019, arXiv:1909.05242</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 304, 2019, pp. 48-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1909.05970v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.05970v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2006.09294v1</id>
    <updated>2020-05-30T07:55:07Z</updated>
    <published>2020-05-30T07:55:07Z</published>
    <title>CC-Light eQASM Architecture Specification</title>
    <summary>  This document is the specification of the CC-Light instantiation of
executable QASM (eQASM), a quantum instruction set architecture (QISA)
developed in QuTech targeting to control a seven-qubit superconducting quantum
processor. This document can serve as a reference manual for low-level
programmers, compiler backend developers, and microarchitecture implementers of
eQASM. The design of CC-Light eQASM is under the Apache 2.0 License.
</summary>
    <author>
      <name>Xiang Fu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">35 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2006.09294v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2006.09294v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.06497v1</id>
    <updated>2017-06-20T14:50:03Z</updated>
    <published>2017-06-20T14:50:03Z</published>
    <title>Alignment Elimination from Adams' Grammars</title>
    <summary>  Adams' extension of parsing expression grammars enables specifying
indentation sensitivity using two non-standard grammar constructs ---
indentation by a binary relation and alignment. This paper proposes a
step-by-step transformation of well-formed Adams' grammars for elimination of
the alignment construct from the grammar. The idea that alignment could be
avoided was suggested by Adams but no process for achieving this aim has been
described before.
</summary>
    <author>
      <name>Härmel Nestra</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.06497v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.06497v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.4; F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.08193v1</id>
    <updated>2017-09-24T13:04:34Z</updated>
    <published>2017-09-24T13:04:34Z</published>
    <title>Anonymous Variables in Imperative Languages</title>
    <summary>  In this paper, we bring anonymous variables into imperative languages.
Anonymous variables represent don't-care values and have proven useful in logic
programming. To bring the same level of benefits into imperative languages, we
describe an extension to C wth anonymous variables.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, We describe some usage of blind universal/existential
  quantifiers in imperative languages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.08193v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.08193v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1411.5110v1</id>
    <updated>2014-11-19T04:34:35Z</updated>
    <published>2014-11-19T04:34:35Z</published>
    <title>Mutually Exclusive Procedures in Imperative Languages</title>
    <summary>  To represent mutually exclusive procedures, we propose a choice-conjunctive
declaration statement of the form $uchoo(S,R)$ where $S, R$ are the procedure
declaration statements within a module. This statement has the following
semantics: request the machine to choose a successful one between $S$ and $R$.
This statement is useful for representing objects with mutually exclusive
procedures. We illustrate our idea via C^uchoo, an extension of the core C with
a new statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1411.5110v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1411.5110v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.1393v1</id>
    <updated>2014-12-03T16:34:11Z</updated>
    <published>2014-12-03T16:34:11Z</published>
    <title>CLAZY: Lazy Calling for Common Lisp</title>
    <summary>  This document contains a description of a Common Lisp extension that allows a
programmer to write functional programs that use "normal order" evaluation, as
in "non-strict" languages like Haskell. The extension is relatively
straightforward, and it appears to be the first one such that is integrated in
the overall Common Lisp framework.
</summary>
    <author>
      <name>Marco Antoniotti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A version of this note was presented at the 1st European Lisp
  Symposium 2008, Bordeaux, France</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.1393v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.1393v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.3729v1</id>
    <updated>2014-12-10T12:20:13Z</updated>
    <published>2014-12-10T12:20:13Z</published>
    <title>Non-termination of Dalvik bytecode via compilation to CLP</title>
    <summary>  We present a set of rules for compiling a Dalvik bytecode program into a
logic program with array constraints. Non-termination of the resulting program
entails that of the original one, hence the techniques we have presented before
for proving non-termination of constraint logic programs can be used for
proving non-termination of Dalvik programs.
</summary>
    <author>
      <name>Etienne Payet</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, presented at the 13th International Workshop on Termination
  (WST) 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.3729v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.3729v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4184v1</id>
    <updated>2014-12-13T02:39:20Z</updated>
    <published>2014-12-13T02:39:20Z</published>
    <title>Procedural and Non-Procedural Implementation of Search Strategies in
  Control Network Programming</title>
    <summary>  This report presents the general picture of how Control Network Programming
can be effectively used for implementing various search strategies, both blind
and informed. An interesting possibility is non - procedural solutions that can
be developed for most local search algorithms. A generic solution is described
for procedural implementations.
</summary>
    <author>
      <name>Kostadin Kratchanov</name>
    </author>
    <author>
      <name>Emilia Golemanova</name>
    </author>
    <author>
      <name>Tzanko Golemanov</name>
    </author>
    <author>
      <name>Tuncay Ercan</name>
    </author>
    <author>
      <name>Burak Ekici</name>
    </author>
    <link href="http://arxiv.org/abs/1412.4184v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4184v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4550v1</id>
    <updated>2014-12-15T11:32:54Z</updated>
    <published>2014-12-15T11:32:54Z</published>
    <title>Modeling Hybrid Systems in Hy-tccp</title>
    <summary>  Concurrent,reactive and hybrid systems require quality modeling languages to
be described and analyzed. The Timed Concurrent Constraint Language (tccp) was
introduced as a simple but powerful model for reactive systems. In this paper,
we present hybrid tccp (hy-tccp), an extension of tccp over continuous time
which includes new con- structs to model the continuous dynamics of hybrid
systems.
</summary>
    <author>
      <name>Damian Adalid</name>
    </author>
    <author>
      <name>Maria del Mar Gallardo</name>
    </author>
    <author>
      <name>Laura Titolo</name>
    </author>
    <link href="http://arxiv.org/abs/1412.4550v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4550v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.02642v1</id>
    <updated>2015-05-11T14:40:29Z</updated>
    <published>2015-05-11T14:40:29Z</published>
    <title>Featherweight PINQ</title>
    <summary>  Differentially private mechanisms enjoy a variety of composition properties.
Leveraging these, McSherry introduced PINQ (SIGMOD 2009), a system empowering
non-experts to construct new differentially private analyses. PINQ is an
LINQ-like API which provides automatic privacy guarantees for all programs
which use it to mediate sensitive data manipulation. In this work we introduce
featherweight PINQ, a formal model capturing the essence of PINQ. We prove that
any program interacting with featherweight PINQ's API is differentially
private.
</summary>
    <author>
      <name>Hamid Ebadi</name>
    </author>
    <author>
      <name>David Sands</name>
    </author>
    <link href="http://arxiv.org/abs/1505.02642v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.02642v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.04013v1</id>
    <updated>2015-12-13T07:32:01Z</updated>
    <published>2015-12-13T07:32:01Z</published>
    <title>Comparing Weakest Precondition and Weakest Liberal Precondition</title>
    <summary>  In this article we investigate the relationships between the classical
notions of weakest precondition and weakest liberal precondition, and provide
several results, namely that in general, weakest liberal precondition is
neither stronger nor weaker than weakest precondition, however, given a
deterministic and terminating sequential while program and a postcondition,
they are equivalent. Hence, in such situation, it does not matter which
definition is used.
</summary>
    <author>
      <name>Andrew E. Santosa</name>
    </author>
    <link href="http://arxiv.org/abs/1512.04013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.04013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.02480v1</id>
    <updated>2016-04-08T20:50:15Z</updated>
    <published>2016-04-08T20:50:15Z</published>
    <title>Refinement Types for TypeScript</title>
    <summary>  We present Refined TypeScript (RSC), a lightweight refinement type system for
TypeScript, that enables static verification of higher-order, imperative
programs. We develop a formal core of RSC that delineates the interaction
between refinement types and mutability. Next, we extend the core to account
for the imperative and dynamic features of TypeScript. Finally, we evaluate RSC
on a set of real world benchmarks, including parts of the Octane benchmarks,
D3, Transducers, and the TypeScript compiler.
</summary>
    <author>
      <name>Panagiotis Vekris</name>
    </author>
    <author>
      <name>Benjamin Cosman</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <link href="http://arxiv.org/abs/1604.02480v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.02480v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.06381v1</id>
    <updated>2016-06-21T00:46:13Z</updated>
    <published>2016-06-21T00:46:13Z</published>
    <title>A Modular Structural Operational Semantics for Delimited Continuations</title>
    <summary>  It has been an open question as to whether the Modular Structural Operational
Semantics framework can express the dynamic semantics of call/cc. This paper
shows that it can, and furthermore, demonstrates that it can express the more
general delimited control operators control and shift.
</summary>
    <author>
      <name>Neil Sculthorpe</name>
    </author>
    <author>
      <name>Paolo Torrini</name>
    </author>
    <author>
      <name>Peter D. Mosses</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.212.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.212.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WoC 2015, arXiv:1606.05839</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 212, 2016, pp. 63-80</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.06381v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.06381v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05185v1</id>
    <updated>2017-03-15T14:40:21Z</updated>
    <published>2017-03-15T14:40:21Z</published>
    <title>Designing a pi-based Programming Language in the .NET framework: CLR
  interoperability from the Programmer's point of view</title>
    <summary>  Interoperability is the ability of a programming language to work with
systems based on different languages and paradigms. These days, many widely
used high-level language impementations provide access to external
functionalities. In this paper, we present some ideas on CLR interoperability
focusing on the kind of constructs desirable by a programmer to this regard.
</summary>
    <author>
      <name>Manuel Mazzara</name>
    </author>
    <link href="http://arxiv.org/abs/1703.05185v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05185v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05227v2</id>
    <updated>2017-03-16T08:09:52Z</updated>
    <published>2017-03-15T16:07:38Z</published>
    <title>Compiling Purely Functional Structured Programs</title>
    <summary>  We present a marriage of functional and structured imperative programming
that embeds in pure lambda calculus. We describe how we implement the core of
this language in a monadic DSL which is structurally equivalent to our intended
source language and which, when evaluated, generates pure lambda terms in
continuation-passing-style.
</summary>
    <author>
      <name>Phil Scott</name>
    </author>
    <author>
      <name>Steven Obua</name>
    </author>
    <author>
      <name>Jacques Fleuriot</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1703.05227v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05227v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1803.11229v2</id>
    <updated>2018-08-24T19:34:30Z</updated>
    <published>2018-03-29T19:30:49Z</published>
    <title>The process of purely event-driven programs</title>
    <summary>  Using process algebra, this paper describes the formalisation of the
process/semantics behind the purely event-driven programming language.
</summary>
    <author>
      <name>Bas van den Heuvel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Supervisors: Dr. A. Ponse and Dr. ir. B. Diertens; 15 pages, 3
  figures in appendix; Updated most process descriptions to the style of PSF.
  Also fixed some design errors that came to light during testing</arxiv:comment>
    <link href="http://arxiv.org/abs/1803.11229v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1803.11229v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.04650v2</id>
    <updated>2018-07-31T18:15:06Z</updated>
    <published>2018-05-12T04:36:07Z</published>
    <title>π: Towards a Simple Formal Semantic Framework for Compiler
  Construction</title>
    <summary>  This paper proposes {\pi}, a formal semantic framework for compiler
construction together with program validation. {\pi} is comprised by {\pi} Lib,
a set of programming languages constructs inspired by Peter Mosses'
Component-Based Semantics and {\pi} Automata, an automata-based formalism to
describe the operational semantics of programming languages, that generalizes
Gordon Plotkin's Interpreting Automata.
</summary>
    <author>
      <name>Christiano Braga</name>
    </author>
    <link href="http://arxiv.org/abs/1805.04650v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.04650v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.05516v1</id>
    <updated>2018-05-15T01:19:40Z</updated>
    <published>2018-05-15T01:19:40Z</published>
    <title>Domain Analysis &amp; Description - The Implicit and Explicit Semantics
  Problem</title>
    <summary>  A domain analysis &amp; description calculus is introduced. It is shown to
alleviate the issue of implicit semantics. The claim is made that domain
descriptions, whether informal, or as also here, formal, amount to an explicit
semantics for what is otherwise implicit if not described.
</summary>
    <author>
      <name>Dines Bjørner</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Technical University of Denmark</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.271.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.271.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings IMPEX 2017 and FM&amp;MDD 2017, arXiv:1805.04636</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 271, 2018, pp. 1-23</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1805.05516v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.05516v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.08106v1</id>
    <updated>2018-05-21T15:03:24Z</updated>
    <published>2018-05-21T15:03:24Z</published>
    <title>The sufficiently smart compiler is a theorem prover</title>
    <summary>  That the Haskell Compiler GHC is capable of proving non-trivial equalities
between Haskell code, by virtue of its aggressive optimizer, in particular the
term rewriting engine in the simplifier. We demonstrate this with a surprising
little code in a GHC plugin, explains the knobs we had to turn, discuss the
limits of the approach and related applications of the same idea, namely
testing that promises from Haskell libraries with domain-specific optimizations
hold.
</summary>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Published in the IFL 2017 pre-proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/1805.08106v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.08106v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1806.04709v3</id>
    <updated>2021-04-27T20:56:16Z</updated>
    <published>2018-06-12T18:45:55Z</published>
    <title>Syntax and Semantics of Cedille</title>
    <summary>  This document presents the syntax, classification rules, realizability
semantics, and soundness theorem for Cedille, an extrinsic (i.e., Curry-style)
type theory extending the Calculus of Constructions, and designed for deriving
of inductive datatypes, with their induction principles.
</summary>
    <author>
      <name>Aaron Stump</name>
    </author>
    <author>
      <name>Christopher Jenkins</name>
    </author>
    <link href="http://arxiv.org/abs/1806.04709v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1806.04709v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.04691v1</id>
    <updated>2020-07-09T10:34:39Z</updated>
    <published>2020-07-09T10:34:39Z</published>
    <title>Kanren Light: A Dynamically Semi-Certified Interactive Logic Programming
  System</title>
    <summary>  We present an experimental system strongly inspired by miniKanren,
implemented on top of the tactics mechanism of the HOL~Light theorem prover.
Our tool is at the same time a mechanism for enabling the logic programming
style for reasoning and computing in a theorem prover, and a framework for
writing logic programs that produce solutions endowed with a formal proof of
correctness.
</summary>
    <author>
      <name>Marco Maggesi</name>
    </author>
    <author>
      <name>Massimo Nocentini</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted for communication to miniKanren 2020 - miniKanren and
  Relational Programming Workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.04691v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.04691v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.11751v1</id>
    <updated>2021-03-22T12:08:45Z</updated>
    <published>2021-03-22T12:08:45Z</published>
    <title>Functional Pearl: Witness Me -- Constructive Arguments Must Be Guided
  with Concrete Witness</title>
    <summary>  Beloved Curry--Howard correspondence tells that types are intuitionistic
propositions, and in constructive math, a proof of proposition can be seen as
some kind of a construction, or witness, conveying the information of the
proposition. We demonstrate how useful this point of view is as the guiding
principle for developing dependently-typed programs.
</summary>
    <author>
      <name>Hiromi Ishii</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to Haskell'21</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.11751v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.11751v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.16105v1</id>
    <updated>2021-03-30T06:30:40Z</updated>
    <published>2021-03-30T06:30:40Z</published>
    <title>Expected-Cost Analysis for Probabilistic Programs and Semantics-Level
  Adaption of Optional Stopping Theorems</title>
    <summary>  In this article, we present a semantics-level adaption of the Optional
Stopping Theorem, sketch an expected-cost analysis as its application, and
survey different variants of the Optional Stopping Theorem that have been used
in static analysis of probabilistic programs.
</summary>
    <author>
      <name>Di Wang</name>
    </author>
    <author>
      <name>Jan Hoffmann</name>
    </author>
    <author>
      <name>Thomas Reps</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:2001.10150</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.16105v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.16105v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.14769v2</id>
    <updated>2021-07-12T15:09:11Z</updated>
    <published>2021-05-31T08:01:45Z</published>
    <title>Gillian: A Multi-Language Platform for Unified Symbolic Analysis</title>
    <summary>  This is an evolving document describing the meta-theory, the implementation,
and the instantiations of Gillian, a multi-language symbolic analysis platform.
</summary>
    <author>
      <name>Petar Maksimović</name>
    </author>
    <author>
      <name>José Fragoso Santos</name>
    </author>
    <author>
      <name>Sacha-Élie Ayoun</name>
    </author>
    <author>
      <name>Philippa Gardner</name>
    </author>
    <link href="http://arxiv.org/abs/2105.14769v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.14769v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.04315v1</id>
    <updated>2015-09-14T20:46:49Z</updated>
    <published>2015-09-14T20:46:49Z</published>
    <title>Implementing a teleo-reactive programming system</title>
    <summary>  This thesis explores the teleo-reactive programming paradigm for controlling
autonomous agents, such as robots. Teleo-reactive programming provides a
robust, opportunistic method for goal-directed programming that continuously
reacts to the sensed environment. In particular, the TR and TeleoR systems are
investigated. They influence the design of a teleo-reactive system programming
in Python, for controlling autonomous agents via the Pedro communications
architecture. To demonstrate the system, it is used as a controller in a simple
game.
</summary>
    <author>
      <name>Robert Webb</name>
    </author>
    <link href="http://arxiv.org/abs/1509.04315v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.04315v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.08949v2</id>
    <updated>2016-04-12T10:49:48Z</updated>
    <published>2016-03-29T20:30:27Z</published>
    <title>The While language</title>
    <summary>  This article presents a formalisation of a simple imperative programming
language. The objective is to study and develop "hands-on" a formal
specifcation of a programming language, namely its syntax, operational
semantics and type system. To have an executable version of the language, we
implemented in Racket its operational semantics and type system.
</summary>
    <author>
      <name>Cláudio Vasconcelos</name>
    </author>
    <author>
      <name>António Ravara</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 21 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.08949v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.08949v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.05274v2</id>
    <updated>2016-11-07T14:13:28Z</updated>
    <published>2016-05-17T18:13:37Z</published>
    <title>Java Generics are Turing Complete</title>
    <summary>  This paper describes a reduction from the halting problem of Turing machines
to subtype checking in Java. It follows that subtype checking in Java is
undecidable, which answers a question posed by Kennedy and Pierce in 2007. It
also follows that Java's type checker can recognize any recursive language,
which improves a result of Gil and Levy from 2016. The latter point is
illustrated by a parser generator for fluent interfaces.
</summary>
    <author>
      <name>Radu Grigore</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">POPL2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.05274v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.05274v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.03733v1</id>
    <updated>2016-07-08T05:36:18Z</updated>
    <published>2016-07-08T05:36:18Z</published>
    <title>Data as processes: introducing measurement data into CARMA models</title>
    <summary>  Measurement data provides a precise and detailed description of components
within a complex system but it is rarely used directly as a component of a
system model. In this paper we introduce a model-based representation of
measurement data and use it together with modeller-defined components expressed
in the CARMA modelling language. We assess both liveness and safety properties
of these models with embedded data.
</summary>
    <author>
      <name>Stephen Gilmore</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.217.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.217.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FORECAST 2016, arXiv:1607.02001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 217, 2016, pp. 31-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.03733v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.03733v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.08801v1</id>
    <updated>2017-05-24T14:49:25Z</updated>
    <published>2017-05-24T14:49:25Z</published>
    <title>Properties of Normalization for a math based intermediate representation</title>
    <summary>  The Normalization transformation plays a key role in the compilation of
Diderot programs. The transformations are complicated and it would be easy for
a bug to go undetected. To increase our confidence in normalization part of the
compiler we provide a formal analysis on the rewriting system. We proof that
the rewrite system is type preserving, value preserving (for tensor-valued
expressions), and terminating.
</summary>
    <author>
      <name>Charisee Chiw</name>
    </author>
    <author>
      <name>John Reppy</name>
    </author>
    <link href="http://arxiv.org/abs/1705.08801v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.08801v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.03894v1</id>
    <updated>2017-12-11T17:12:34Z</updated>
    <published>2017-12-11T17:12:34Z</published>
    <title>Coqatoo: Generating Natural Language Versions of Coq Proofs</title>
    <summary>  Due to their numerous advantages, formal proofs and proof assistants, such as
Coq, are becoming increasingly popular. However, one disadvantage of using
proof assistants is that the resulting proofs can sometimes be hard to read and
understand, particularly for less-experienced users. To address this issue, we
have implemented a tool capable of generating natural language versions of Coq
proofs called Coqatoo, which we present in this paper.
</summary>
    <author>
      <name>Andrew Bedford</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">International Workshop on Coq for Programming Languages (CoqPL 2018)</arxiv:comment>
    <link href="http://arxiv.org/abs/1712.03894v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.03894v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.00119v1</id>
    <updated>2018-03-31T04:43:31Z</updated>
    <published>2018-03-31T04:43:31Z</published>
    <title>Generic Description of Well-Scoped, Well-Typed Syntaxes</title>
    <summary>  We adapt the technique of type-generic programming via descriptions pointing
into a universe to the domain of typed languages with binders and variables,
implementing a notion of "syntax-generic programming" in a dependently typed
programming language. We present an Agda library implementation of
type-preserving renaming and substitution (including proofs about their
behaviour) "once and for all" over all applicable languages using our
technique.
</summary>
    <author>
      <name>Gergő Érdi</name>
    </author>
    <link href="http://arxiv.org/abs/1804.00119v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.00119v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.08242v1</id>
    <updated>2018-07-22T06:14:55Z</updated>
    <published>2018-07-22T06:14:55Z</published>
    <title>Analysis of Logarithmic Amortised Complexity</title>
    <summary>  We introduce a novel amortised resource analysis based on a potential-based
type system. This type system gives rise to logarithmic and polynomial bounds
on the runtime complexity and is the first such system to exhibit logarithmic
amortised complexity. We relate the thus obtained automatable amortised
resource analysis to manual amortised analyses of self-adjusting data
structures, like splay trees, that can be found in the literature.
</summary>
    <author>
      <name>Martin Hofmann</name>
    </author>
    <author>
      <name>Georg Moser</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1807.08242v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.08242v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.11819v1</id>
    <updated>2020-01-22T01:00:35Z</updated>
    <published>2020-01-22T01:00:35Z</published>
    <title>Joint Distributions for TensorFlow Probability</title>
    <summary>  A central tenet of probabilistic programming is that a model is specified
exactly once in a canonical representation which is usable by inference
algorithms. We describe JointDistributions, a family of declarative
representations of directed graphical models in TensorFlow Probability.
</summary>
    <author>
      <name>Dan Piponi</name>
    </author>
    <author>
      <name>Dave Moore</name>
    </author>
    <author>
      <name>Joshua V. Dillon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Based on extended abstract submitted to PROBPROG 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2001.11819v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.11819v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.CO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.ML" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.09478v1</id>
    <updated>2020-05-15T09:32:48Z</updated>
    <published>2020-05-15T09:32:48Z</published>
    <title>Monads and "do" notation in the Wolfram Language</title>
    <summary>  This paper describes a categorical interpretation of the Wolfram Language and
introduces a simple implementation of monadic types and the "do" notation. The
monadic style of programming combined with the many built in functions of the
Wolfram Language has potential to be a powerful tool in writing Wolfram
Language code. Additionally, using pure functions and the "do" notation can
result in programs that are very predictable and easy to parallelize.
</summary>
    <author>
      <name>Kacper Topolnicki</name>
    </author>
    <link href="http://arxiv.org/abs/2005.09478v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.09478v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.03070v1</id>
    <updated>2020-11-05T19:35:09Z</updated>
    <published>2020-11-05T19:35:09Z</published>
    <title>Multicloud API binding generation from documentation</title>
    <summary>  We present industry experience from implementing retargetable cloud API
binding generator.
  The analysis is implemented in Haskell, using type classes, types a la carte,
and code generation monad.
  It also targets Haskell, and allows us to bind cloud APIs on short notice,
and unprecedented scale.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <author>
      <name>Vitor Vitali Barrozzi</name>
    </author>
    <author>
      <name>Gabriel Araujo</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-031-10461-9_11</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-031-10461-9_11" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented on XP 2020: Agility in Microservices workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2011.03070v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.03070v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.03076v2</id>
    <updated>2021-01-12T17:17:39Z</updated>
    <published>2020-11-05T19:53:42Z</published>
    <title>Towards a more perfect union type</title>
    <summary>  We present a principled theoretical framework for inferring and checking the
union types, and show its work in practice on JSON data structures. The
framework poses a union type inference as a learning problem from multiple
examples. The categorical framework is generic and easily extensible.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5281/zenodo.3929474</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5281/zenodo.3929474" rel="related"/>
    <link href="http://arxiv.org/abs/2011.03076v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.03076v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.05194v2</id>
    <updated>2020-11-12T04:31:29Z</updated>
    <published>2020-11-10T15:49:45Z</published>
    <title>MotePy: A domain specific language for low-overhead machine learning and
  data processing</title>
    <summary>  A domain specific language (DSL), named MotePy is presented. The DSL offers a
high level syntax with low overheads for ML/data processing in time constrained
or memory constrained systems. The DSL-to-C compiler has a novel static memory
allocator that tracks object lifetimes and reuses the static memory, which we
call the compiler-managed heap.
</summary>
    <author>
      <name>Jayaraj Poroor</name>
    </author>
    <link href="http://arxiv.org/abs/2011.05194v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.05194v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.08242v1</id>
    <updated>2020-11-16T19:38:11Z</updated>
    <published>2020-11-16T19:38:11Z</published>
    <title>Opportunities and Challenges for Circuit Board Level Hardware
  Description Languages</title>
    <summary>  Board-level hardware description languages (HDLs) are one approach to
increasing automation and raising the level of abstraction for designing
electronics. These systems borrow programming languages concepts like
generators and type systems, but also must be designed with human factors in
mind to serve existing hardware engineers. In this work, we look at one recent
prototype system, and discuss open questions spanning from fundamental models
through usable interfaces.
</summary>
    <author>
      <name>Richard Lin</name>
    </author>
    <author>
      <name>Björn Hartmann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">HATRA 2020 workshop paper</arxiv:comment>
    <link href="http://arxiv.org/abs/2011.08242v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.08242v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.12879v1</id>
    <updated>2022-03-24T06:38:12Z</updated>
    <published>2022-03-24T06:38:12Z</published>
    <title>Lang-n-Send: Processes That Send Languages</title>
    <summary>  We present Lang-n-Send, a pi-calculus that is equipped with language
definitions. Processes can define languages in operational semantics, and use
them to execute programs. Furthermore, processes can send and receive pieces of
operational semantics through channels.
  We present a reduction semantics for Lang-n-Send, and we offer examples that
demonstrate some of the scenarios that Lang-n-Send captures.
</summary>
    <author>
      <name>Matteo Cimini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Massachusetts Lowell, USA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.356.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.356.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2022, arXiv:2203.12142</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 356, 2022, pp. 46-56</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2203.12879v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.12879v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.17125v1</id>
    <updated>2022-03-31T15:48:17Z</updated>
    <published>2022-03-31T15:48:17Z</published>
    <title>An Affine Type System with Hindley-Milner Style Type Inference</title>
    <summary>  This article first provides an algorithm W based type inference algorithm for
an affine type system. Then the article further assumes the language equipped
with the above type system uses lazy evaluation, and explores the possibility
of representing the !-modality as a user-defined type synonym with the power of
the newly gained polymorphism.
</summary>
    <author>
      <name>Gonglin Li</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2203.17125v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.17125v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.4078v1</id>
    <updated>2014-09-14T17:26:34Z</updated>
    <published>2014-09-14T17:26:34Z</published>
    <title>The distributed Language Hello White Paper</title>
    <summary>  Hello is a general-purpose, object-oriented, protocol-agnostic distributed
programming language. This paper explains the ideas that guided design of
Hello. It shows the spirit of Hello using two brief expressive programs and
provides a summary of language features. In addition, it explores historical
parallels between the binary programming of early computers and the distributed
programming of modern networks.
</summary>
    <author>
      <name>Boris Burshteyn</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1409.4078v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.4078v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7514v3</id>
    <updated>2014-10-06T12:18:11Z</updated>
    <published>2014-09-26T09:29:09Z</published>
    <title>Coffman deadlocks in SCOOP</title>
    <summary>  In this paper we address the deadlock detection problem in the context of
SCOOP - an OO-programming model for concurrency, recently formalized in Maude.
We present the integration of a deadlock detection mechanism on top of the
aforementioned formalization and analyze how an abstract semantics of SCOOP
based on a notion of "may alias expressions" can contribute to improving the
deadlock detection procedure.
</summary>
    <author>
      <name>Georgiana Caltais</name>
    </author>
    <author>
      <name>Bertrand Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/1409.7514v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7514v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.08154v1</id>
    <updated>2017-02-27T06:01:12Z</updated>
    <published>2017-02-27T06:01:12Z</published>
    <title>Beyond-Regular Typestate</title>
    <summary>  We present an extension for regular typestates, called Beyond- Regular
Typestate(BR-Typestate), which is expressive enough to model non-regular
properties of programs and protocols over data. We model the BR-Typestate
system over a dependently typed, state based, impera- tive core language, and
we prove its soundness and tractability. We have implemented a prototype
typechecker for the language, and we show how several important, real world
non-regular properties of programs and protocols can be verified.
</summary>
    <author>
      <name>Ashish Mishra</name>
    </author>
    <author>
      <name>Y. N. Srikant</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">submitted to CAV'17</arxiv:comment>
    <link href="http://arxiv.org/abs/1702.08154v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.08154v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.08178v1</id>
    <updated>2019-05-20T15:46:34Z</updated>
    <published>2019-05-20T15:46:34Z</published>
    <title>Partial Redundancy Elimination using Lazy Code Motion</title>
    <summary>  Partial Redundancy Elimination (PRE) is a compiler optimization that
eliminates expressions that are redundant on some but not necessarily all paths
through a program. In this project, we implemented a PRE optimization pass in
LLVM and measured results on a variety of applications. We chose PRE because it
is a powerful technique that subsumes Common Subexpression Elimination (CSE)
and Loop Invariant Code Motion (LICM), and hence has the potential to greatly
improve performance.
</summary>
    <author>
      <name>Sandeep Dasgupta</name>
    </author>
    <author>
      <name>Tanmay Gangwani</name>
    </author>
    <link href="http://arxiv.org/abs/1905.08178v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.08178v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.08921v1</id>
    <updated>2019-05-17T16:12:06Z</updated>
    <published>2019-05-17T16:12:06Z</published>
    <title>D2d -- XML for Authors</title>
    <summary>  D2d is an input format which allows experienced authors to create type
correct xml text objects with minimal disturbance of the creative flow of
writing. This paper contains the complete specification of the parsing process,
including the generation of error messages.
</summary>
    <author>
      <name>Markus Lepper</name>
    </author>
    <author>
      <name>Baltasar Trancón y Widemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 4 tables (Technical Report -- Bad Honnef 2013)</arxiv:comment>
    <link href="http://arxiv.org/abs/1905.08921v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.08921v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="J.5; J.1; K.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.00898v1</id>
    <updated>2019-08-02T15:01:07Z</updated>
    <published>2019-08-02T15:01:07Z</published>
    <title>The meaning of a program change is a change to the program's meaning</title>
    <summary>  Programming is the activity of modifying a program in order to bring about
specific changes in its behaviour. Yet programming language theory almost
exclusively focuses on the meaning of programs. We motivate a "change-oriented"
viewpoint from which the meaning of a program change is a change to the
program's meaning.
</summary>
    <author>
      <name>Roly Perera</name>
    </author>
    <link href="http://arxiv.org/abs/1908.00898v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.00898v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.06723v1</id>
    <updated>2019-08-16T05:53:26Z</updated>
    <published>2019-08-16T05:53:26Z</published>
    <title>Proceedings Seventh International Workshop on Verification and Program
  Transformation</title>
    <summary>  This volume contains a final and revised selection of papers presented at the
Seventh International Workshop on Verification and Program Transformation (VPT
2019), which took place in Genova, Italy, on April 2nd, 2019, affiliated with
Programming 2019.
</summary>
    <author>
      <name>Alexei Lisitsa</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Liverpool</arxiv:affiliation>
    </author>
    <author>
      <name>Andrei Nemytykh</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Program Systems Institute of RAS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.299</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.299" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 299, 2019</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1908.06723v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.06723v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.11343v1</id>
    <updated>2019-08-23T14:38:36Z</updated>
    <published>2019-08-23T14:38:36Z</published>
    <title>Modular Runtime Complexity Analysis of Probabilistic While Programs</title>
    <summary>  We are concerned with the average case runtime complexity analysis of a
prototypical imperative language endowed with primitives for sampling and
probabilistic choice. Taking inspiration from known approaches from to the
modular resource analysis of non-probabilistic programs, we investigate how a
modular runtime analysis is obtained for probabilistic programs.
</summary>
    <author>
      <name>Martin Avanzini</name>
    </author>
    <author>
      <name>Michael Schaper</name>
    </author>
    <author>
      <name>Georg Moser</name>
    </author>
    <link href="http://arxiv.org/abs/1908.11343v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.11343v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2104.00378v1</id>
    <updated>2021-04-01T10:13:42Z</updated>
    <published>2021-04-01T10:13:42Z</published>
    <title>The Comprehensive Blub Archive Network: Towards Design Principals for
  Open Source Programming Language Repositories</title>
    <summary>  Many popular open source programming languages (Perl, Ruby or Python for
example) have systems for distributing packaged source code that software
developers can use when working in that particular programming language. This
paper will consider the design principals that should be followed if designing
such an open source code repository.
</summary>
    <author>
      <name>Seamus Brady</name>
    </author>
    <link href="http://arxiv.org/abs/2104.00378v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2104.00378v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2104.00379v1</id>
    <updated>2021-04-01T10:18:52Z</updated>
    <published>2021-04-01T10:18:52Z</published>
    <title>Immutability and Design Patterns in Ruby</title>
    <summary>  Functional Programming has seen a resurgence in interest in the last few
years and is often mentioned in opposition to Object-Orientated Programming.
However, Object-Orientated Programming can actually absorb some of the lessons
of Functional Programming to improve performance and reliability. This paper
examines three ways in which Immutability, a common Functional Programming
technique, can be used to develop immutable objects in Ruby.
</summary>
    <author>
      <name>Seamus Brady</name>
    </author>
    <link href="http://arxiv.org/abs/2104.00379v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2104.00379v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2106.01250v1</id>
    <updated>2021-06-02T16:01:33Z</updated>
    <published>2021-06-02T16:01:33Z</published>
    <title>Generic Programming with Combinators and Objects</title>
    <summary>  We present a generic programming framework for OCAML which makes it possible
to implement extensible transformations for a large scale of type definitions.
Our framework makes use of objectoriented features of OCAML, utilising late
binding to override the default behaviour of generated transformations. The
support for polymorphic variant types complements the ability to describe
composable data types with the ability to implement composable transformations.
</summary>
    <author>
      <name>Dmitrii Kosarev</name>
    </author>
    <author>
      <name>Dmitry Boulytchev</name>
    </author>
    <link href="http://arxiv.org/abs/2106.01250v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2106.01250v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.05771v1</id>
    <updated>2021-10-12T07:01:34Z</updated>
    <published>2021-10-12T07:01:34Z</published>
    <title>Toward SMT-Based Refinement Types in Agda</title>
    <summary>  Dependent types offer great versatility and power, but developing proofs with
them can be tedious and requires considerable human guidance. We propose to
integrate Satisfiability Modulo Theories (SMT)-based refinement types into the
dependently-typed language Agda in an effort to ease some of the burden of
programming with dependent types and combine the strengths of the two
approaches to mechanized theorem proving.
</summary>
    <author>
      <name>Gan Shen</name>
    </author>
    <author>
      <name>Lindsey Kuper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted for publication at HATRA 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2110.05771v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.05771v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.5586v1</id>
    <updated>2013-02-22T13:43:12Z</updated>
    <published>2013-02-22T13:43:12Z</published>
    <title>PENCIL: Towards a Platform-Neutral Compute Intermediate Language for
  DSLs</title>
    <summary>  We motivate the design and implementation of a platform-neutral compute
intermediate language (PENCIL) for productive and performance-portable
accelerator programming.
</summary>
    <author>
      <name>Riyadh Baghdadi</name>
    </author>
    <author>
      <name>Albert Cohen</name>
    </author>
    <author>
      <name>Serge Guelton</name>
    </author>
    <author>
      <name>Sven Verdoolaege</name>
    </author>
    <author>
      <name>Jun Inoue</name>
    </author>
    <author>
      <name>Tobias Grosser</name>
    </author>
    <author>
      <name>Georgia Kouveli</name>
    </author>
    <author>
      <name>Alexey Kravets</name>
    </author>
    <author>
      <name>Anton Lokhmotov</name>
    </author>
    <author>
      <name>Cedric Nugteren</name>
    </author>
    <author>
      <name>Fraser Waters</name>
    </author>
    <author>
      <name>Alastair F. Donaldson</name>
    </author>
    <link href="http://arxiv.org/abs/1302.5586v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.5586v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.7472v1</id>
    <updated>2014-10-28T00:41:47Z</updated>
    <published>2014-10-28T00:41:47Z</published>
    <title>A note on two notions of compliance</title>
    <summary>  We establish a relation between two models of contracts: binary session
types, and a model based on event structures and game-theoretic notions. In
particular, we show that compliance in session types corresponds to the
existence of certain winning strategies in game-based contracts.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>Tiziana Cimoli</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>G. Michele Pinna</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cagliari</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.166.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.166.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2014, arXiv:1410.7013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 166, 2014, pp. 86-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1410.7472v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.7472v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.GT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.04906v1</id>
    <updated>2015-03-17T03:58:23Z</updated>
    <published>2015-03-17T03:58:23Z</published>
    <title>A Finite Model Property for Intersection Types</title>
    <summary>  We show that the relational theory of intersection types known as BCD has the
finite model property; that is, BCD is complete for its finite models. Our
proof uses rewriting techniques which have as an immediate by-product the
polynomial time decidability of the preorder &lt;= (although this also follows
from the so called beta soundness of BCD).
</summary>
    <author>
      <name>Rick Statman</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.177.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.177.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2014, arXiv:1503.04377</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 177, 2015, pp. 1-9</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1503.04906v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.04906v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.06067v1</id>
    <updated>2016-10-19T15:31:34Z</updated>
    <published>2016-10-19T15:31:34Z</published>
    <title>Fairness as a Program Property</title>
    <summary>  We explore the following question: Is a decision-making program fair, for
some useful definition of fairness? First, we describe how several algorithmic
fairness questions can be phrased as program verification problems. Second, we
discuss an automated verification technique for proving or disproving fairness
of decision-making programs with respect to a probabilistic model of the
population.
</summary>
    <author>
      <name>Aws Albarghouthi</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <author>
      <name>Samuel Drews</name>
    </author>
    <author>
      <name>Aditya Nori</name>
    </author>
    <link href="http://arxiv.org/abs/1610.06067v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.06067v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.07696v1</id>
    <updated>2016-10-25T01:00:47Z</updated>
    <published>2016-10-25T01:00:47Z</published>
    <title>Proceedings 14th International Workshop Quantitative Aspects of
  Programming Languages and Systems</title>
    <summary>  This volume contains the post-proceedings of the 14th International Workshop
on Quantitative Aspects of Programming Languages and Systems (QAPL), held as a
satellite workshop of ETAPS 2016 in Eindhoven, The Netherlands, on 2-3 April
2016.
</summary>
    <author>
      <name>Mirco Tribastone</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IMT School for Advanced Studies Lucca, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Herbert Wiklicky</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.227</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.227" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 227, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1610.07696v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.07696v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.01579v1</id>
    <updated>2018-01-04T23:15:28Z</updated>
    <published>2018-01-04T23:15:28Z</published>
    <title>Hygienic Source-Code Generation Using Functors</title>
    <summary>  Existing source-code-generating tools such as Lex and Yacc suffer from
practical inconveniences because they use disembodied code to implement
actions. To prevent this problem, such tools could generate closed functors
that are then instantiated by the programmer with appropriate action code. This
results in all code being type checked in its appropriate context, and it
assists the type checker in localizing errors correctly. We have implemented a
lexer generator and parser generator based on this technique for Standard ML,
OCaml, and Haskell.
</summary>
    <author>
      <name>Karl Crary</name>
    </author>
    <link href="http://arxiv.org/abs/1801.01579v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.01579v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1809.02161v1</id>
    <updated>2018-09-06T18:29:54Z</updated>
    <published>2018-09-06T18:29:54Z</published>
    <title>Future Directions for Optimizing Compilers</title>
    <summary>  As software becomes larger, programming languages become higher-level, and
processors continue to fail to be clocked faster, we'll increasingly require
compilers to reduce code bloat, eliminate abstraction penalties, and exploit
interesting instruction sets. At the same time, compiler execution time must
not increase too much and also compilers should never produce the wrong output.
This paper examines the problem of making optimizing compilers faster, less
buggy, and more capable of generating high-quality output.
</summary>
    <author>
      <name>Nuno P. Lopes</name>
    </author>
    <author>
      <name>John Regehr</name>
    </author>
    <link href="http://arxiv.org/abs/1809.02161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1809.02161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.00632v1</id>
    <updated>2018-11-01T20:58:56Z</updated>
    <published>2018-11-01T20:58:56Z</published>
    <title>Loop Optimization Framework</title>
    <summary>  The LLVM compiler framework supports a selection of loop transformations such
as vectorization, distribution and unrolling. Each transformation is
carried-out by specialized passes that have been developed independently. In
this paper we propose an integrated approach to loop optimizations: A single
dedicated pass that mutates a Loop Structure DAG. Each transformation can make
use of a common infrastructure such as dependency analysis, transformation
preconditions, etc.
</summary>
    <author>
      <name>Michael Kruse</name>
    </author>
    <author>
      <name>Hal Finkel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">LCPC'18 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1811.00632v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.00632v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.05536v1</id>
    <updated>2018-11-13T21:45:20Z</updated>
    <published>2018-11-13T21:45:20Z</published>
    <title>Staging Human-computer Dialogs: An Application of the Futamura
  Projections</title>
    <summary>  We demonstrate an application of the Futamura Projections to human-computer
interaction, and particularly to staging human-computer dialogs. Specifically,
by providing staging analogs to the classical Futamura Projections, we
demonstrate that the Futamura Projections can be applied to the staging of
human-computer dialogs in addition to the execution of programs.
</summary>
    <author>
      <name>Brandon M. Williams</name>
    </author>
    <author>
      <name>Saverio Perugini</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages, 6 figures, and 3 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1811.05536v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.05536v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.05369v1</id>
    <updated>2019-02-14T14:24:59Z</updated>
    <published>2019-02-14T14:24:59Z</published>
    <title>Introducing Yet Another REversible Language</title>
    <summary>  Yarel is a core reversible programming language that implements a class of
permutations, defined recursively, which are primitive recursive complete. The
current release of Yarel syntax and operational semantics, implemented by
compiling Yarel to Java, is 0.1.0, according to Semantic Versioning 2.0.0.
Yarel comes with Yarel-IDE, developed as an Eclipse plug-in by means of XText.
</summary>
    <author>
      <name>Claudio Grandi</name>
    </author>
    <author>
      <name>Dariush Moshiri</name>
    </author>
    <author>
      <name>Luca Roversi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages. On-line at https://yarel-di.github.io/yarel/</arxiv:comment>
    <link href="http://arxiv.org/abs/1902.05369v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.05369v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.07425v1</id>
    <updated>2019-04-16T03:10:48Z</updated>
    <published>2019-04-16T03:10:48Z</published>
    <title>The Geometry of Bayesian Programming</title>
    <summary>  We give a geometry of interaction model for a typed lambda-calculus endowed
with operators for sampling from a continuous uniform distribution and soft
conditioning, namely a paradigmatic calculus for higher-order Bayesian
programming. The model is based on the category of measurable spaces and
partial measurable functions, and is proved adequate with respect to both a
distribution-based and a sampling based operational semantics.
</summary>
    <author>
      <name>Ugo Dal Lago</name>
    </author>
    <author>
      <name>Naohiko Hoshino</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0960129521000396</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0960129521000396" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Math. Struct. Comp. Sci. 31 (2021) 633-681</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1904.07425v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.07425v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.08722v1</id>
    <updated>2019-04-18T12:20:55Z</updated>
    <published>2019-04-18T12:20:55Z</published>
    <title>Quantitative Expressiveness of Instruction Sequence Classes for
  Computation on Single Bit Registers</title>
    <summary>  The number of instructions of an instruction sequence is taken for its
logical SLOC, and is abbreviated with LLOC. A notion of quantitative
expressiveness is based on LLOC and in the special case of operation over a
family of single bit registers a collection of elementary properties are
established. A dedicated notion of interface is developed and is used for
stating relevant properties of classes of instruction sequences
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <link href="http://arxiv.org/abs/1904.08722v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.08722v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.11741v1</id>
    <updated>2019-10-25T14:09:45Z</updated>
    <published>2019-10-25T14:09:45Z</published>
    <title>Implementing choreography extraction</title>
    <summary>  Choreography extraction deals with the generation of a choreography (a global
description of communication behaviour) from a set of local process behaviours.
In this work, we implement a previously proposed theory for extraction and show
that, in spite of its theoretical exponential complexity, it is usable in
practice. We discuss the data structures needed for an efficient
implementation, introduce some optimizations, and perform a systematic
practical evaluation.
</summary>
    <author>
      <name>Luís Cruz-Filipe</name>
    </author>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <author>
      <name>Larisa Safina</name>
    </author>
    <link href="http://arxiv.org/abs/1910.11741v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.11741v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.11924v1</id>
    <updated>2019-10-25T20:31:18Z</updated>
    <published>2019-10-25T20:31:18Z</published>
    <title>A Calculus for Language Transformations</title>
    <summary>  In this paper we propose a calculus for expressing algorithms for programming
languages transformations. We present the type system and operational semantics
of the calculus, and we prove that it is type sound. We have implemented our
calculus, and we demonstrate its applicability with common examples in
programming languages. As our calculus manipulates inference systems, our work
can, in principle, be applied to logical systems.
</summary>
    <author>
      <name>Benjamin Mourad</name>
    </author>
    <author>
      <name>Matteo Cimini</name>
    </author>
    <link href="http://arxiv.org/abs/1910.11924v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.11924v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.02951v1</id>
    <updated>2019-12-06T02:08:07Z</updated>
    <published>2019-12-06T02:08:07Z</published>
    <title>User Experience with Language-Independent Formal Verification</title>
    <summary>  The goal of this paper is to help mainstream programmers routinely use formal
verification on their smart contracts by 1) proposing a new YAML-format for
writing general-purpose formal specifications, 2) demonstrating how a formal
specification can be incrementally built up without needing advanced training,
and 3) showing how formal specifications can be tested by using program
mutation.
</summary>
    <author>
      <name>Suhabe Bugrara</name>
    </author>
    <link href="http://arxiv.org/abs/1912.02951v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.02951v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.08923v1</id>
    <updated>2020-08-20T12:21:53Z</updated>
    <published>2020-08-20T12:21:53Z</published>
    <title>Proceedings Eighth and Ninth International Workshop on Trends in
  Functional Programming in Education</title>
    <summary>  This volume contains five papers, accepted after post-reviewing, based on
presentations submitted to TFPIE 2019 and TFPIE 2020 that took places in
Vancouver, Canada and Krakow, Poland respectively. TFPIE stands for Trends in
Functional Programming in Education, where authors present research and
experiences in teaching concepts of functional programming at any level.
</summary>
    <author>
      <name>Jurriaan Hage</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Utrecht University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.321</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.321" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 321, 2020</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2008.08923v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.08923v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.08095v1</id>
    <updated>2021-01-20T12:34:25Z</updated>
    <published>2021-01-20T12:34:25Z</published>
    <title>Automatic Differentiation via Effects and Handlers: An Implementation in
  Frank</title>
    <summary>  Automatic differentiation (AD) is an important family of algorithms which
enables derivative based optimization. We show that AD can be simply
implemented with effects and handlers by doing so in the Frank language. By
considering how our implementation behaves in Frank's operational semantics, we
show how our code performs the dynamic creation of programs during evaluation.
</summary>
    <author>
      <name>Jesse Sigal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared as short paper in PEPM'21, see
  https://www.youtube.com/watch?v=BmBSJFkfL2M for associated talk</arxiv:comment>
    <link href="http://arxiv.org/abs/2101.08095v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.08095v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.3; G.1.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.00093v1</id>
    <updated>2021-06-21T14:58:31Z</updated>
    <published>2021-06-21T14:58:31Z</published>
    <title>Automatic Synthesis of Experiment Designs from Probabilistic Environment
  Specifications</title>
    <summary>  This paper presents an extension to the probabilistic programming language
ProbRobScene, allowing users to automatically synthesize uniform experiment
designs directly from environment specifications. We demonstrate its
effectiveness on a number of environment specification snippets from tabletop
manipulation, and show that our method generates reliably low-discrepancy
designs.
</summary>
    <author>
      <name>Craig Innes</name>
    </author>
    <author>
      <name>Yordan Hristov</name>
    </author>
    <author>
      <name>Georgios Kamaras</name>
    </author>
    <author>
      <name>Subramanian Ramamoorthy</name>
    </author>
    <link href="http://arxiv.org/abs/2107.00093v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.00093v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.00564v1</id>
    <updated>2021-06-24T04:23:13Z</updated>
    <published>2021-06-24T04:23:13Z</published>
    <title>A Note on Exhaustive State Space Search for Efficient Code Generation</title>
    <summary>  This note explores state space search to find efficient instruction sequences
that perform particular data manipulations. Once found, the instruction
sequences are hard-wired in the code generator that needs these data
manipulations. Since state space is only searched while developing the
compiler, search time is not at a premium, which allows exhaustively searching
for the best possible instruction sequences.
</summary>
    <author>
      <name>Aart J. C. Bik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">white paper</arxiv:comment>
    <link href="http://arxiv.org/abs/2107.00564v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.00564v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.04629v1</id>
    <updated>2021-09-10T02:41:35Z</updated>
    <published>2021-09-10T02:41:35Z</published>
    <title>An Overview of the HFL Model Checking Project</title>
    <summary>  In this article, we give an overview of our project on higher-order program
verification based on HFL (higher-order fixpoint logic) model checking. After a
brief introduction to HFL, we explain how it can be applied to program
verification, and summarize the current status of the project.
</summary>
    <author>
      <name>Naoki Kobayashi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Tokyo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.344.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.344.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings HCVS 2021, arXiv:2109.03988</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 344, 2021, pp. 1-12</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2109.04629v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.04629v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.01397v2</id>
    <updated>2022-02-13T15:06:06Z</updated>
    <published>2021-12-02T16:35:41Z</published>
    <title>Efficient Calling Conventions for Irregular Architectures</title>
    <summary>  We empirically evaluated thousands of different C calling conventions for
irregular microcontroller architectures, and found potential for improvement
over the calling conventions previously used in the Small Device C Compiler
(SDCC). The improvements in code size and speed are substantial enough that
SDCC made changes to its default calling convention, breaking ABI
compatibility.
</summary>
    <author>
      <name>Philipp K. Krause</name>
    </author>
    <link href="http://arxiv.org/abs/2112.01397v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.01397v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.03653v1</id>
    <updated>2021-12-07T12:05:00Z</updated>
    <published>2021-12-07T12:05:00Z</published>
    <title>A Specification for Typed Template Haskell</title>
    <summary>  Multi-stage programming is a proven technique that provides predictable
performance characteristics by controlling code generation. We propose a core
semantics for Typed Template Haskell, an extension of Haskell that supports
multi staged programming that interacts well with polymorphism and qualified
types. Our semantics relates a declarative source language with qualified types
to a core language based on the the polymorphic lambda calculus augmented with
multi-stage constructs.
</summary>
    <author>
      <name>Matthew Pickering</name>
    </author>
    <author>
      <name>Andres Löh</name>
    </author>
    <author>
      <name>Nicolas Wu</name>
    </author>
    <link href="http://arxiv.org/abs/2112.03653v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.03653v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.05957v1</id>
    <updated>2022-06-13T08:05:50Z</updated>
    <published>2022-06-13T08:05:50Z</published>
    <title>The $\aleph$-Calculus: A declarative model of reversible programming</title>
    <summary>  A novel model of reversible computing, the $\aleph$-calculus, is introduced.
It is declarative, reversible-Turing complete, and has a local term-rewriting
semantics. Unlike previously demonstrated reversible term-rewriting systems, it
does not require the accumulation of history data. Terms in the
$\aleph$-calculus, in combination with the program definitions, encapsulate all
program state. An interpreter was also written.
</summary>
    <author>
      <name>Hannah Earley</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages, 1 listing, 14th Conference on Reversible Computation</arxiv:comment>
    <link href="http://arxiv.org/abs/2206.05957v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.05957v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.03894v1</id>
    <updated>2022-07-08T13:28:18Z</updated>
    <published>2022-07-08T13:28:18Z</published>
    <title>Copy Propagation subsumes Constant Propagation</title>
    <summary>  Constant propagation and copy propagation are code transformations that may
avoid some load operations and can enable other optimizations. In literature,
constant and copy propagations are considered two independent transformations
requiring two different data flow analyses. Here we give a generic definition
for copy propagation which enables us to view constant propagation as a
particular case of copy propagation and formulate a novel data flow analysis
that unifies these two transformations.
</summary>
    <author>
      <name>Sreekala S.</name>
    </author>
    <author>
      <name>Vineeth Paleri</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages, 2 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.03894v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.03894v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.08972v1</id>
    <updated>2022-07-18T23:01:35Z</updated>
    <published>2022-07-18T23:01:35Z</published>
    <title>Implementation of a Didactic Compiler for a superset of PL/0</title>
    <summary>  This article describes the features of a compiler for a superset language of
the well-known PL/0 created by Niklaus Wirth. The main feature is that it
implements the build phases in such a way that the information passed between
each one is reflected as an XML file.
</summary>
    <author>
      <name> Navas-López</name>
    </author>
    <author>
      <name>Eduardo Adam</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Spanish language. Presented at "Congreso de Electr\'onica e
  Inform\'atica 2010", Universidad Centroamericana "Jos\'e Sime\'on Ca\~nas"</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.08972v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.08972v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; E.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.11600v1</id>
    <updated>2022-07-23T20:55:41Z</updated>
    <published>2022-07-23T20:55:41Z</published>
    <title>Proceedings Tenth and Eleventh International Workshop on Trends in
  Functional Programming In Education</title>
    <summary>  This volume contains the papers, accepted after post-reviewing, based on
presentations submitted to TFPIE 2021 and TFPIE 2022 that took place online, in
collaboration with LambdaDays 2021/22 in Krak\'ow, Poland. TFPIE stands for
Trends in Functional Programming in Education, where authors present research
and experiences in teaching concepts of functional programming at any level.
</summary>
    <author>
      <name>Peter Achten</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Radboud University, Nijmegen, Netherlands</arxiv:affiliation>
    </author>
    <author>
      <name>Elena Machkasova</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Minnesota Morris, USA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.363</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.363" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 363, 2022</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2207.11600v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.11600v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.12137v1</id>
    <updated>2022-07-25T12:40:33Z</updated>
    <published>2022-07-25T12:40:33Z</published>
    <title>Evolving Recursive Definitions with Applications to Dynamic Programming</title>
    <summary>  Inspired by computability logic\cite{Jap03}, we refine recursive function
definitions into two kinds: blindly-quantified (BQ) ones and parallel
universally quantified (PUQ) ones. BQ definitions corresponds to the
traditional ones where recursive definitions are $not$ evolving. PUQ
definitions are {\it evolving} in the course of computation, leading to
automatic memoization. In addition, based on this idea, we propose a new,
high-level object-oriented language.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.12137v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.12137v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.12049v1</id>
    <updated>2022-08-25T12:21:15Z</updated>
    <published>2022-08-25T12:21:15Z</published>
    <title>Electronic Appendix to "Input Invariants"</title>
    <summary>  In this electronic appendix to our paper "Input Invariants," accepted at
ESEC/FSE'22, we provide additional examples, formal definitions, theorems, and
proof sketches to complement our paper. Furthermore, we show the invariants
that ISLearn mined in our evaluation.
</summary>
    <author>
      <name>Dominic Steinhöfel</name>
    </author>
    <author>
      <name>Andreas Zeller</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages. The main paper "Input Invariants" appeared at ESEC/FSE 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2208.12049v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.12049v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.2.5; F.4.2; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.14755v1</id>
    <updated>2022-08-31T10:11:42Z</updated>
    <published>2022-08-31T10:11:42Z</published>
    <title>Python Type Hints are Turing Complete</title>
    <summary>  Grigore showed that Java generics are Turing complete by describing a
reduction from Turing machines to Java subtyping. We apply Grigore's algorithm
to Python type hints and deduce that they are Turing complete. In addition, we
present an alternative reduction in which the Turing machines are simulated in
real time, resulting in significantly lower compilation times. Our work is
accompanied by a Python implementation of both reductions that compiles Turing
machines into Python subtyping machines.
</summary>
    <author>
      <name>Ori Roth</name>
    </author>
    <link href="http://arxiv.org/abs/2208.14755v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.14755v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.01259v1</id>
    <updated>2022-09-02T20:12:45Z</updated>
    <published>2022-09-02T20:12:45Z</published>
    <title>Category Theory for Programming</title>
    <summary>  In these lecture notes, we give a brief introduction to some elements of
category theory. The choice of topics is guided by applications to functional
programming. Firstly, we study initial algebras, which provide a mathematical
characterization of datatypes and recursive functions on them. Secondly, we
study monads, which give a mathematical framework for effects in functional
languages. The notes include many problems and solutions.
</summary>
    <author>
      <name>Benedikt Ahrens</name>
    </author>
    <author>
      <name>Kobe Wullaert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Source code and updates available from
  https://github.com/benediktahrens/CT4P</arxiv:comment>
    <link href="http://arxiv.org/abs/2209.01259v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.01259v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2211.11550v2</id>
    <updated>2023-02-03T14:09:05Z</updated>
    <published>2022-11-21T15:16:32Z</published>
    <title>Refactoring = Substitution + Rewriting</title>
    <summary>  We present an approach to describing refactorings that abstracts away from
particular refactorings to classes of similar transformations, and presents an
implementation of these that works by substitution and subsequent rewriting.
Substitution is language-independent under this approach, while the rewrites
embody language-specific aspects. Intriguingly, it also goes back to work on
API migration by Huiqing Li and the first author, and sets refactoring in that
general context.
</summary>
    <author>
      <name>Simon Thompson</name>
    </author>
    <author>
      <name>Dániel Horpácsi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9pp</arxiv:comment>
    <link href="http://arxiv.org/abs/2211.11550v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2211.11550v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2211.16597v5</id>
    <updated>2023-06-14T10:25:07Z</updated>
    <published>2022-11-29T21:20:34Z</published>
    <title>Right and wrong: ten choices in language design</title>
    <summary>  A description of language design choices that have profound effects on
software quality, criticism of how ordinary OO languages address them, and
explanation of the thinking behind Eiffel's corresponding mechanisms.
</summary>
    <author>
      <name>Bertrand Meyer</name>
    </author>
    <link href="http://arxiv.org/abs/2211.16597v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2211.16597v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.02605v1</id>
    <updated>2022-12-05T21:22:25Z</updated>
    <published>2022-12-05T21:22:25Z</published>
    <title>Proving False in Object-Oriented Verification Programs by Exploiting
  Non-Termination</title>
    <summary>  We looked at three different object-oriented program verifiers: Gobra, KeY,
and Dafny. We show that all three can be made to prove false by using a simple
trick with ghost variable declaration and non-terminating code. This shows that
verifiers for these languages can produce unsound results without much
difficulty and that this is possibly common throughout all OO verifiers.
</summary>
    <author>
      <name>Jaymon Furniss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Unsound 2022 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/2212.02605v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.02605v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2302.09403v1</id>
    <updated>2023-02-18T18:35:01Z</updated>
    <published>2023-02-18T18:35:01Z</published>
    <title>Functional Programming and Streams</title>
    <summary>  This document is intended as a stand-alone textbook chapter to be used for
introducing some functional programming concepts into a course in which the
primary teaching language is Java. For details of the approach, please see the
paper "Functional programming, in the data structures course, in Java" by J.
MacCormick, which appears in the Journal of Computing Sciences in Colleges
(2023).
</summary>
    <author>
      <name>John MacCormick</name>
    </author>
    <link href="http://arxiv.org/abs/2302.09403v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2302.09403v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="K.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.04574v1</id>
    <updated>2023-04-10T13:27:34Z</updated>
    <published>2023-04-10T13:27:34Z</published>
    <title>Defunctionalization with Dependent Types</title>
    <summary>  The defunctionalization translation that eliminates higher-order functions
from programs forms a key part of many compilers. However, defunctionalization
for dependently-typed languages has not been formally studied. We present the
first formally-specified defunctionalization translation for a
dependently-typed language and establish key metatheoretical properties such as
soundness and type preservation. The translation is suitable for incorporation
into type-preserving compilers for dependently-typed languages
</summary>
    <author>
      <name>Yulong Huang</name>
    </author>
    <author>
      <name>Jeremy Yallop</name>
    </author>
    <link href="http://arxiv.org/abs/2304.04574v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.04574v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.04937v1</id>
    <updated>2023-04-11T02:38:46Z</updated>
    <published>2023-04-11T02:38:46Z</published>
    <title>Tracing OCaml Programs</title>
    <summary>  This presentation will cover a framework for application-level tracing of
OCaml programs. We outline a solution to the main technical challenge, which is
being able to log typed values with lower overhead and maintenance burden than
existing approaches. We then demonstrate the tools we have built around this
for visualizing and exploring executions.
</summary>
    <author>
      <name>Darius Foo</name>
    </author>
    <author>
      <name>Wei-Ngan Chin</name>
    </author>
    <link href="http://arxiv.org/abs/2304.04937v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.04937v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2308.06110v1</id>
    <updated>2023-08-11T12:53:54Z</updated>
    <published>2023-08-11T12:53:54Z</published>
    <title>Proceedings Twelfth International Workshop on Trends in Functional
  Programming in Education</title>
    <summary>  This volume contains the papers, accepted after post-reviewing, based on
presentations submitted to TFPIE 2023 that took place at UMAss Boston in
Boston, Massachusetts, USA on January 12th 2023. TFPIE stands for Trends in
Functional Programming in Education, where authors present research and
experiences in teaching concepts of functional programming at any level.
</summary>
    <author>
      <name>Elena Machkasova</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Minnesota, Morris</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.382</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.382" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 382, 2023</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2308.06110v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2308.06110v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.03912v1</id>
    <updated>2023-08-09T22:08:11Z</updated>
    <published>2023-08-09T22:08:11Z</published>
    <title>__host__ __device__ -- Generic programming in Cuda</title>
    <summary>  We present patterns for Cuda/C++ to write save generic code which works both
on the host and device side. Writing templated functions in Cuda/C++ both for
the CPU and the GPU bears the problem that in general both __host__ and
__device__ functions are instantiated, which leads to lots of compiler warnings
or errors.
</summary>
    <author>
      <name>Thomas Mejstrik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">First draft</arxiv:comment>
    <link href="http://arxiv.org/abs/2309.03912v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.03912v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.09004v1</id>
    <updated>2023-10-13T10:58:16Z</updated>
    <published>2023-10-13T10:58:16Z</published>
    <title>Nondeterminism and Guarded Commands</title>
    <summary>  The purpose of this paper is to discuss the relevance of nondeterminism in
computer science, with a special emphasis on Dijkstra's guarded commands
language.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Ernst-Rüdiger Olderog</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">34 pages. This is authors' version of Chapter 8 of the book K.R. Apt
  and C.A.R. Hoare (editors), Edsger Wybe Dijkstra: His Life, Work, and Legacy,
  volume 45 of ACM Books. ACM/Morgan &amp; Claypool, 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.09004v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.09004v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.05658v2</id>
    <updated>2024-02-07T15:32:13Z</updated>
    <published>2023-11-09T01:41:43Z</published>
    <title>Three non-cubical applications of extension types</title>
    <summary>  The development of cubical type theory inspired the idea of "extension types"
which has been found to have applications in other type theories that are
unrelated to homotopy type theory or cubical type theory.
  This article describes these applications, including on records,
metaprogramming, controlling unfolding, and some more exotic ones.
</summary>
    <author>
      <name>Tesla Zhang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2311.05658v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.05658v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03B38, 68N15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.14443v1</id>
    <updated>2023-11-24T12:36:35Z</updated>
    <published>2023-11-24T12:36:35Z</published>
    <title>Petit programming language and compiler</title>
    <summary>  Petit is an educational programming language for learning compilers. Students
embark on the journey of learning compilers through a series of six tutorials,
progressing from topics like lexical analysis and syntactic analysis to
semantic analysis and code generation. The initial tutorials in this series
cover the practical applications of the lex and yacc tools, while the
concluding tutorial focuses on generating LLVM intermediate representation.
</summary>
    <author>
      <name>Raul Barbosa</name>
    </author>
    <link href="http://arxiv.org/abs/2311.14443v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.14443v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2401.03570v1</id>
    <updated>2024-01-07T19:32:55Z</updated>
    <published>2024-01-07T19:32:55Z</published>
    <title>A Note on Dynamic Bidirected Dyck-Reachability with Cycles</title>
    <summary>  Recently, Li et al. [2022] presented a dynamic Dyck-reachability algorithm
for bidirected graphs. The basic idea is based on updating edge weights in a
data structure called the merged graph $G_m$. As noted in Krishna et al.
[2023], the edge deletion procedure described in the algorithm of Li et al.
[2022] cannot properly update the weights in the presence of cycles in $G_m$.
This note discusses the cycle case and the time complexity.
</summary>
    <author>
      <name>Qirun Zhang</name>
    </author>
    <link href="http://arxiv.org/abs/2401.03570v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2401.03570v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2404.06646v1</id>
    <updated>2024-04-09T22:51:39Z</updated>
    <published>2024-04-09T22:51:39Z</published>
    <title>Game Semantics for Higher-Order Unitary Quantum Computation</title>
    <summary>  We develop a symmetric monoidal closed category of games, incorporating sums
and products, to model quantum computation at higher types. This model is
expressive, capable of representing all unitary operators at base types. It is
compatible with base types and realizable by unitary operators.
</summary>
    <author>
      <name>Samson Abramsky</name>
    </author>
    <author>
      <name>Radha Jagadeesan</name>
    </author>
    <link href="http://arxiv.org/abs/2404.06646v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2404.06646v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2406.01792v1</id>
    <updated>2024-06-03T21:16:06Z</updated>
    <published>2024-06-03T21:16:06Z</published>
    <title>The SemGuS Toolkit</title>
    <summary>  Semantics-Guided Synthesis (SemGuS) is a programmable framework for defining
synthesis problems in a domain- and solver-agnostic way. This paper presents
the standardized SemGuS format, together with an open-source toolkit that
provides a parser, a verifier, and enumerative SemGuS solvers. The paper also
describes an initial set of SemGuS benchmarks, which form the basis for
comparing SemGuS solvers, and presents an evaluation of the baseline
enumerative solvers.
</summary>
    <author>
      <name>Keith J. C. Johnson</name>
    </author>
    <author>
      <name>Andrew Reynolds</name>
    </author>
    <author>
      <name>Thomas Reps</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <link href="http://arxiv.org/abs/2406.01792v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2406.01792v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2407.06885v1</id>
    <updated>2024-07-09T14:13:45Z</updated>
    <published>2024-07-09T14:13:45Z</published>
    <title>Meerkat: A Distributed Reactive Programming Language with Live Updates</title>
    <summary>  We propose a novel type-safe reactive programming language with live updates
that extends an existing work to support multiple distributed evolution queues.
Dependency sets of definitions are incorporated in the type system to protect
the interaction between the frontend user interface and the backend database.
Distributed live updates submitted by multiple programmers are ensured strong
consistency based on an existing framework for distributed reactive
propagation.
</summary>
    <author>
      <name>Heng Zhong</name>
    </author>
    <author>
      <name>Anrui Liu</name>
    </author>
    <link href="http://arxiv.org/abs/2407.06885v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2407.06885v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2407.06924v1</id>
    <updated>2024-07-09T14:58:12Z</updated>
    <published>2024-07-09T14:58:12Z</published>
    <title>foetus -- Termination Checker for Simple Functional Programs</title>
    <summary>  We introduce a simple functional language foetus (lambda calculus with
tuples, constructors and pattern matching) supplied with a termination checker.
This checker tries to find a well-founded structural order on the parameters on
the given function to prove termination. The components of the check algorithm
are: function call extraction out of the program text, call graph completion
and finding a lexical order for the function parameters.
</summary>
    <author>
      <name>Andreas Abel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">25 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2407.06924v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2407.06924v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N18" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2408.11954v1</id>
    <updated>2024-08-21T19:15:44Z</updated>
    <published>2024-08-21T19:15:44Z</published>
    <title>A type system for data flow and alias analysis in ReScript</title>
    <summary>  ReScript introduces a strongly typed language that targets JavaScript, as an
alternative to gradually typed languages, such as TypeScript. In this paper, we
present a type system for data-flow analysis for a subset of the ReScript
language, more specific for a lambda-calculus with mutability and pattern
matching. The type system is a local analysis that collects information about
what variables are used and alias information.
</summary>
    <author>
      <name>Nicky Ask Lund</name>
    </author>
    <author>
      <name>Hans Hüttel</name>
    </author>
    <link href="http://arxiv.org/abs/2408.11954v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2408.11954v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2409.11106v1</id>
    <updated>2024-09-17T12:02:23Z</updated>
    <published>2024-09-17T12:02:23Z</published>
    <title>Scheme Pearl: Quantum Continuations</title>
    <summary>  We advance the thesis that the simulation of quantum circuits is
fundamentally about the efficient management of a large (potentially
exponential) number of delimited continuations. The family of Scheme languages,
with its efficient implementations of first-class continuations and with its
imperative constructs, provides an elegant host for modeling and simulating
quantum circuits.
</summary>
    <author>
      <name>Vikraman Choudhury</name>
    </author>
    <author>
      <name>Borislav Agapiev</name>
    </author>
    <author>
      <name>Amr Sabry</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared at Scheme Workshop 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2409.11106v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2409.11106v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2409.19211v1</id>
    <updated>2024-09-28T02:30:24Z</updated>
    <published>2024-09-28T02:30:24Z</published>
    <title>Programming with High-Level Abstractions, Proceedings of the 3rd
  Workshop on Logic and Practice of Programming</title>
    <summary>  This proceedings contains abstracts and position papers for the work
presented at the third Logic and Practice of Programming (LPOP) Workshop. The
workshop was held online, using zoom, at stonybrook.zoom.us, on December 13,
2022. The workshop focused on core high-level abstractions around sets and
logic rules, to help bring them to the general practice of programming.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <link href="http://arxiv.org/abs/2409.19211v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2409.19211v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2412.16185v1</id>
    <updated>2024-12-12T14:01:55Z</updated>
    <published>2024-12-12T14:01:55Z</published>
    <title>Computing $\sqrt{2}$ with FRACTRAN</title>
    <summary>  The FRACTRAN programs $\sqrt{2}$GAME and NR$\sqrt{2}$GAME are presented, both
of which compute the decimal expansion of $\sqrt{2}$. Our $\sqrt{2}$GAME is
analogous to Conway's PIGAME program. In fact, our proof carries over to PIGAME
to produce a simpler proof of Conway's theorem as well as highlight how the
efficiency of the program can be improved. NR$\sqrt{2}$GAME encodes the
canonical example of the Newton--Raphson method in FRACTRAN.
</summary>
    <author>
      <name>Khushi Kaushik</name>
    </author>
    <author>
      <name>Tommy Murphy</name>
    </author>
    <author>
      <name>David Weed</name>
    </author>
    <link href="http://arxiv.org/abs/2412.16185v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2412.16185v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N15" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2412.16206v1</id>
    <updated>2024-12-17T16:09:28Z</updated>
    <published>2024-12-17T16:09:28Z</published>
    <title>Information Aware Type Systems and Telescopic Constraint Trees</title>
    <summary>  Can we use the flow of information to understand type systems? I present two
familiar type systems in pursuit of an `Information Aware' style, using
information effects to reveal data flow and help in implementing them. I also
calculate a general, scoped, constraint-based representation of typechecking
problems from the typing rules.
</summary>
    <author>
      <name>Philippa Cowderoy</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract from MSFP2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2412.16206v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2412.16206v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2503.20463v1</id>
    <updated>2025-03-26T11:50:39Z</updated>
    <published>2025-03-26T11:50:39Z</published>
    <title>An Encoding of Interaction Nets in OCaml</title>
    <summary>  Interaction nets constitute a visual programming language grounded in graph
transformation. Owing to their distinctive properties, they inherently
facilitate parallelism in the rewriting step. This paper showcases a simple and
concise approach to encoding interaction nets within the programming language
OCaml, emphasising correctness guarantees. To achieve this objective, we encode
not only the interaction net primitives, but also Lafont's original type
system.
</summary>
    <author>
      <name>Nikolaus Huber</name>
    </author>
    <author>
      <name>Wang Yi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.417.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.417.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GCM 2023 and 2024, arXiv:2503.19632</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 417, 2025, pp. 1-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2503.20463v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2503.20463v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0302013v1</id>
    <updated>2003-02-12T05:16:12Z</updated>
    <published>2003-02-12T05:16:12Z</published>
    <title>Cg in Two Pages</title>
    <summary>  Cg is a language for programming GPUs. This paper describes Cg briefly.
</summary>
    <author>
      <name>Mark J. Kilgard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0302013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0302013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.GR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.GR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.3.6; C.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.1812v3</id>
    <updated>2014-04-06T14:56:30Z</updated>
    <published>2013-12-06T09:41:06Z</published>
    <title>Long multiplication by instruction sequences with backward jump
  instructions</title>
    <summary>  For each function on bit strings, its restriction to bit strings of any given
length can be computed by a finite instruction sequence that contains only
instructions to set and get the content of Boolean registers, forward jump
instructions, and a termination instruction. Backward jump instructions are not
necessary for this, but instruction sequences can be significantly shorter with
them. We take the function on bit strings that models the multiplication of
natural numbers on their representation in the binary number system to
demonstrate this by means of a concrete example. The example is reason to
discuss points concerning the halting problem and the concept of an algorithm.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages, the preliminaries are about the same as the preliminaries
  in arXiv:1308.0219 [cs.PL] and arXiv:1312.1529 [cs.PL]; minor errors
  corrected, references added; section on indirect addressing added</arxiv:comment>
    <link href="http://arxiv.org/abs/1312.1812v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.1812v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; F.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9810010v2</id>
    <updated>1998-11-02T21:39:47Z</updated>
    <published>1998-10-09T20:29:43Z</published>
    <title>C++ Templates as Partial Evaluation</title>
    <summary>  This paper explores the relationship between C++ templates and partial
evaluation. Templates were designed to support generic programming, but
unintentionally provided the ability to perform compile-time computations and
code generation. These features are completely accidental, and as a result
their syntax is awkward. By recasting these features in terms of partial
evaluation, a much simpler syntax can be achieved. C++ may be regarded as a
two-level language in which types are first-class values. Template
instantiation resembles an offline partial evaluator. This paper describes
preliminary work toward a single mechanism based on Partial Evaluation which
unifies generic programming, compile-time computation and code generation. The
language Catat is introduced to illustrate these ideas.
</summary>
    <author>
      <name>Todd L. Veldhuizen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9810010v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9810010v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9811001v1</id>
    <updated>1998-10-31T07:20:37Z</updated>
    <published>1998-10-31T07:20:37Z</published>
    <title>A Polymorphic Groundness Analysis of Logic Programs</title>
    <summary>  A polymorphic analysis is an analysis whose input and output contain
parameters which serve as placeholders for information that is unknown before
analysis but provided after analysis. In this paper, we present a polymorphic
groundness analysis that infers parameterised groundness descriptions of the
variables of interest at a program point. The polymorphic groundness analysis
is designed by replacing two primitive operators used in a monomorphic
groundness analysis and is shown to be as precise as the monomorphic groundness
analysis for any possible values for mode parameters. Experimental results of a
prototype implementation of the polymorphic groundness analysis are given.
</summary>
    <author>
      <name>Lunjin Lu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waikato</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">30 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9811001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9811001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2;D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/9811021v1</id>
    <updated>1998-11-12T09:49:57Z</updated>
    <published>1998-11-12T09:49:57Z</published>
    <title>Automatic Hardware Synthesis for a Hybrid Reconfigurable CPU Featuring
  Philips CPLDs</title>
    <summary>  A high-level architecture of a Hybrid Reconfigurable CPU, based on a
Philips-supported core processor, is introduced. It features the Philips XPLA2
CPLD as a reconfigurable functional unit. A compilation chain is presented, in
which automatic implementation of time-critical program segments in custom
hardware is performed. The entire process is transparent from the programmer's
point of view. The hardware synthesis module of the chain, which translates
segments of assembly code into a hardware netlist, is discussed in details.
Application examples are also presented.
</summary>
    <author>
      <name>Bernardo Kastrup</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 7 figures, PACT '98 Workshop on Reconfigurable Computing</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/9811021v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/9811021v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; C.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0003010v1</id>
    <updated>2000-03-06T12:16:00Z</updated>
    <published>2000-03-06T12:16:00Z</published>
    <title>TSIA: A Dataflow Model</title>
    <summary>  The Task System and Item Architecture (TSIA) is a model for transparent
application execution. In many real-world projects, a TSIA provides a simple
application with a transparent reliable, distributed, heterogeneous, adaptive,
dynamic, real-time, parallel, secure or other execution. TSIA is suitable for
many applications, not just for the simple applications served to date. This
presentation shows that TSIA is a dataflow model - a long-standing model for
transparent parallel execution. The advances to the dataflow model include a
simple semantics, as well as support for input/output, for modifiable items and
for other such effects.
</summary>
    <author>
      <name>Burkhard D. Steinmacher-Burow</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0003010v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0003010v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0004011v1</id>
    <updated>2000-04-19T12:22:36Z</updated>
    <published>2000-04-19T12:22:36Z</published>
    <title>Task Frames</title>
    <summary>  Forty years ago Dijkstra introduced the current conventional execution of
routines. It places activation frames onto a stack. Each frame is the internal
state of an executing routine. The resulting application execution is not
easily helped by an external system. This presentation proposes an alternative
execution of routines. It places task frames onto the stack. A task frame is
the call of a routine to be executed. The feasibility of the alternative
execution is demonstrated by a crude implementation. As described elsewhere, an
application which executes in terms of tasks can be provided by an external
system with a transparent reliable, distributed, heterogeneous, adaptive,
dynamic, real-time, parallel, secure or other execution. By extending the crude
implementation, this presentation outlines a simple transparent parallel
execution.
</summary>
    <author>
      <name>Burkhard D. Steinmacher-Burow</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0004011v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0004011v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3;D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0005023v1</id>
    <updated>2000-05-19T10:19:51Z</updated>
    <published>2000-05-19T10:19:51Z</published>
    <title>C++ programming language for an abstract massively parallel SIMD
  architecture</title>
    <summary>  The aim of this work is to define and implement an extended C++ language to
support the SIMD programming paradigm. The C++ programming language has been
extended to express all the potentiality of an abstract SIMD machine consisting
of a central Control Processor and a N-dimensional toroidal array of Numeric
Processors. Very few extensions have been added to the standard C++ with the
goal of minimising the effort for the programmer in learning a new language and
to keep very high the performance of the compiled code. The proposed language
has been implemented as a porting of the GNU C++ Compiler on a SIMD
supercomputer.
</summary>
    <author>
      <name>Alessandro Lonardo</name>
    </author>
    <author>
      <name>Emanuele Panizzi</name>
    </author>
    <author>
      <name>Benedetto Proietti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0005023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0005023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.2.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0009030v1</id>
    <updated>2000-09-29T20:29:41Z</updated>
    <published>2000-09-29T20:29:41Z</published>
    <title>From Syntactic Theories to Interpreters: A Specification Language and
  Its Compilation</title>
    <summary>  Recent years have seen an increasing need of high-level specification
languages and tools generating code from specifications. In this paper, we
introduce a specification language, {\splname}, which is tailored to the
writing of syntactic theories of language semantics. More specifically, the
language supports specifying primitive notions such as dynamic constraints,
contexts, axioms, and inference rules. We also introduce a system which
generates interpreters from {\splname} specifications. A prototype system is
implemented and has been tested on a number of examples, including a syntactic
theory for Verilog.
</summary>
    <author>
      <name>Yong Xiao</name>
    </author>
    <author>
      <name>Zena M. Ariola</name>
    </author>
    <author>
      <name>Michel Mauny</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted in Rule-based Programming Workshop, 2000, 16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0009030v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0009030v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.1.2; D.3.1; F.3.1; F.3.2; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010009v1</id>
    <updated>2000-10-03T17:00:42Z</updated>
    <published>2000-10-03T17:00:42Z</published>
    <title>An Approach to the Implementation of Overlapping Rules in Standard ML</title>
    <summary>  We describe an approach to programming rule-based systems in Standard ML,
with a focus on so-called overlapping rules, that is rules that can still be
active when other rules are fired. Such rules are useful when implementing
rule-based reactive systems, and to that effect we show a simple implementation
of Loyall's Active Behavior Trees, used to control goal-directed agents in the
Oz virtual environment. We discuss an implementation of our framework using a
reactive library geared towards implementing those kind of systems.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages. Presented at RULE 2000, First International Workshop on
  Rule-Based Programming, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0010009v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010009v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0010016v1</id>
    <updated>2000-10-10T10:32:00Z</updated>
    <published>2000-10-10T10:32:00Z</published>
    <title>Towards rule-based visual programming of generic visual systems</title>
    <summary>  This paper illustrates how the diagram programming language DiaPlan can be
used to program visual systems. DiaPlan is a visual rule-based language that is
founded on the computational model of graph transformation. The language
supports object-oriented programming since its graphs are hierarchically
structured. Typing allows the shape of these graphs to be specified recursively
in order to increase program security. Thanks to its genericity, DiaPlan allows
to implement systems that represent and manipulate data in arbitrary diagram
notations. The environment for the language exploits the diagram editor
generator DiaGen for providing genericity, and for implementing its user
interface and type checker.
</summary>
    <author>
      <name>Berthold Hoffmann</name>
    </author>
    <author>
      <name>Mark Minas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 16 figures contribution to the First International Workshop
  on Rule-Based Programming (RULE'2000), September 19, 2000, Montreal, Canada</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0010016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0010016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.7; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0101023v1</id>
    <updated>2001-01-23T13:35:27Z</updated>
    <published>2001-01-23T13:35:27Z</published>
    <title>Properties of Input-Consuming Derivations</title>
    <summary>  We study the properties of input-consuming derivations of moded logic
programs. Input-consuming derivations can be used to model the behavior of
logic programs using dynamic scheduling and employing constructs such as delay
declarations.
  We consider the class of nicely-moded programs and queries. We show that for
these programs a weak version of the well-known switching lemma holds also for
input-consuming derivations. Furthermore, we show that, under suitable
conditions, there exists an algebraic characterization of termination of
input-consuming derivations.
</summary>
    <author>
      <name>Annalisa Bossi</name>
    </author>
    <author>
      <name>Sandro Etalle</name>
    </author>
    <author>
      <name>Sabina Rossi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">33 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0101023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0101023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6;D.3.1;F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105011v1</id>
    <updated>2001-05-07T12:56:11Z</updated>
    <published>2001-05-07T12:56:11Z</published>
    <title>Component Programming and Interoperability in Constraint Solver Design</title>
    <summary>  Prolog was once the main host for implementing constraint solvers.
  It seems that it is no longer so. To be useful, constraint solvers have to be
integrable into industrial applications written in imperative or
object-oriented languages; to be efficient, they have to interact with other
solvers. To meet these requirements, many solvers are now implemented in the
form of extensible object-oriented libraries. Following Pfister and Szyperski,
we argue that ``objects are not enough,'' and we propose to design solvers as
component-oriented libraries. We illustrate our approach by the description of
the architecture of a prototype, and we assess its strong points and
weaknesses.
</summary>
    <author>
      <name>Frederic Goualard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 1 figure, paper accepted at the 6th Annual workshop of the
  ERCIM Working Group on Constraints</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105011v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105011v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0105024v1</id>
    <updated>2001-05-14T13:35:03Z</updated>
    <published>2001-05-14T13:35:03Z</published>
    <title>Constraint Propagation in Presence of Arrays</title>
    <summary>  We describe the use of array expressions as constraints, which represents a
consequent generalisation of the "element" constraint. Constraint propagation
for array constraints is studied theoretically, and for a set of domain
reduction rules the local consistency they enforce, arc-consistency, is proved.
An efficient algorithm is described that encapsulates the rule set and so
inherits the capability to enforce arc-consistency from the rules.
</summary>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages. Accepted at the 6th Annual Workshop of the ERCIM Working
  Group on Constraints, 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0105024v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0105024v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0106059v1</id>
    <updated>2001-06-29T08:41:02Z</updated>
    <published>2001-06-29T08:41:02Z</published>
    <title>CHR as grammar formalism. A first report</title>
    <summary>  Grammars written as Constraint Handling Rules (CHR) can be executed as
efficient and robust bottom-up parsers that provide a straightforward,
non-backtracking treatment of ambiguity. Abduction with integrity constraints
as well as other dynamic hypothesis generation techniques fit naturally into
such grammars and are exemplified for anaphora resolution, coordination and
text interpretation.
</summary>
    <author>
      <name>Henning Christiansen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages. Presented at ERCIM Workshop on Constraints, Prague, Czech
  Republic, June 18-20, 2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. of ERCIM Workshop on Constraints, Prague, Czech Republic,
  June 18-20, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0106059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0106059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.7;D.3.2;F.4.1;F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109003v1</id>
    <updated>2001-09-03T05:37:48Z</updated>
    <published>2001-09-03T05:37:48Z</published>
    <title>On the generalized dining philosophers problem</title>
    <summary>  We consider a generalization of the dining philosophers problem to arbitrary
connection topologies. We focus on symmetric, fully distributed systems, and we
address the problem of guaranteeing progress and lockout-freedom, even in
presence of adversary schedulers, by using randomized algorithms. We show that
the well-known algorithms of Lehmann and Rabin do not work in the generalized
case, and we propose an alternative algorithm based on the idea of letting the
philosophers assign a random priority to their adjacent forks.
</summary>
    <author>
      <name>Oltea Mihaela Herescu</name>
    </author>
    <author>
      <name>Catuscia Palamidessi</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. of the 20th ACM Symposium on Principles of Distributed
  Computing (PODC), pages 81-89, ACM, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0109003v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109003v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.4.1;C.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109024v1</id>
    <updated>2001-09-17T15:43:17Z</updated>
    <published>2001-09-17T15:43:17Z</published>
    <title>Verification of Timed Automata Using Rewrite Rules and Strategies</title>
    <summary>  ELAN is a powerful language and environment for specifying and prototyping
deduction systems in a language based on rewrite rules controlled by
strategies. Timed automata is a class of continuous real-time models of
reactive systems for which efficient model-checking algorithms have been
devised. In this paper, we show that these algorithms can very easily be
prototyped in the ELAN system. This paper argues through this example that
rewriting based systems relying on rules and strategies are a good framework to
prototype, study and test rather efficiently symbolic model-checking
algorithms, i.e. algorithms which involve combination of graph exploration
rules, deduction rules, constraint solving techniques and decision procedures.
</summary>
    <author>
      <name>Emmanuel Beffara</name>
    </author>
    <author>
      <name>Olivier Bournez</name>
    </author>
    <author>
      <name>Hassen Kacem</name>
    </author>
    <author>
      <name>Claude Kirchner</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0109024v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109024v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0109060v1</id>
    <updated>2001-09-24T11:33:39Z</updated>
    <published>2001-09-24T11:33:39Z</published>
    <title>Branching: the Essence of Constraint Solving</title>
    <summary>  This paper focuses on the branching process for solving any constraint
satisfaction problem (CSP). A parametrised schema is proposed that (with
suitable instantiations of the parameters) can solve CSP's on both finite and
infinite domains. The paper presents a formal specification of the schema and a
statement of a number of interesting properties that, subject to certain
conditions, are satisfied by any instances of the schema.
  It is also shown that the operational procedures of many constraint systems
including cooperative systems) satisfy these conditions.
  Moreover, the schema is also used to solve the same CSP in different ways by
means of different instantiations of its parameters.
</summary>
    <author>
      <name>Antonio J. Fernandez</name>
    </author>
    <author>
      <name>Patricia M. Hill</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 pages, 2 figures, Proceedings ERCIM Workshop on Constraints
  (Prague, June 2001)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0109060v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0109060v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0110007v1</id>
    <updated>2001-10-02T14:10:58Z</updated>
    <published>2001-10-02T14:10:58Z</published>
    <title>Variable and Value Ordering When Solving Balanced Academic Curriculum
  Problems</title>
    <summary>  In this paper we present the use of Constraint Programming for solving
balanced academic curriculum problems. We discuss the important role that
heuristics play when solving a problem using a constraint-based approach. We
also show how constraint solving techniques allow to very efficiently solve
combinatorial optimization problems that are too hard for integer programming
techniques.
</summary>
    <author>
      <name>Carlos Castro</name>
    </author>
    <author>
      <name>Sebastian Manzano</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 4 figures</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of 6th Workshop of the ERCIM WG on Constraints
  (Prague, June 2001)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0110007v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0110007v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0111042v2</id>
    <updated>2001-11-22T17:19:32Z</updated>
    <published>2001-11-16T14:40:57Z</published>
    <title>Proceedings of the Eleventh Workshop on Logic Programming Environments
  (WLPE'01)</title>
    <summary>  The Eleventh Workshop on Logic Programming Environments (WLPE'01) was one in
a series of international workshops in the topic area. It was held on December
1, 2001 in Paphos, Cyprus as a post-conference workshop at ICLP 2001. Eight
refereed papers were presented at the conference. A majority of the papers
involved, in some way, constraint logic programming and tools for software
development. Other topics areas addressed include execution visualization,
instructional aids (for learning users), software maintenance (including
debugging), and provisions for new paradigms.
</summary>
    <author>
      <name>Anthony Kusalik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 refereed papers; Anthony Kusalik, editor; 11WLPE, WLPE 2001</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0111042v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0111042v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.2.5; D.2.6; F.4.1; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0203001v1</id>
    <updated>2002-03-01T11:58:56Z</updated>
    <published>2002-03-01T11:58:56Z</published>
    <title>Towards Generic Refactoring</title>
    <summary>  We study program refactoring while considering the language or even the
programming paradigm as a parameter. We use typed functional programs, namely
Haskell programs, as the specification medium for a corresponding refactoring
framework. In order to detach ourselves from language syntax, our
specifications adhere to the following style. (I) As for primitive algorithms
for program analysis and transformation, we employ generic function combinators
supporting generic traversal and polymorphic functions refined by ad-hoc cases.
(II) As for the language abstractions involved in refactorings, we design a
dedicated multi-parameter class. This class can be instantiated for
abstractions as present in various languages, e.g., Java, Prolog or Haskell.
</summary>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0203001v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0203001v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.1.2; D.2.1; D.2.3; D.2.13; D.3.1; I.1.1; I.1.2; I.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0203022v1</id>
    <updated>2002-03-18T13:22:30Z</updated>
    <published>2002-03-18T13:22:30Z</published>
    <title>Three Optimisations for Sharing</title>
    <summary>  In order to improve precision and efficiency sharing analysis should track
both freeness and linearity. The abstract unification algorithms for these
combined domains are suboptimal, hence there is scope for improving precision.
This paper proposes three optimisations for tracing sharing in combination with
freeness and linearity. A novel connection between equations and sharing
abstractions is used to establish correctness of these optimisations even in
the presence of rational trees. A method for pruning intermediate sharing
abstractions to improve efficiency is also proposed. The optimisations are
lightweight and therefore some, if not all, of these optimisations will be of
interest to the implementor.
</summary>
    <author>
      <name>Jacob M. Howe</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theiry and Practice of Logic Programming</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0203022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0203022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; f.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0204015v1</id>
    <updated>2002-04-09T12:44:43Z</updated>
    <published>2002-04-09T12:44:43Z</published>
    <title>Design Patterns for Functional Strategic Programming</title>
    <summary>  In previous work, we introduced the fundamentals and a supporting combinator
library for \emph{strategic programming}. This an idiom for generic programming
based on the notion of a \emph{functional strategy}: a first-class generic
function that cannot only be applied to terms of any type, but which also
allows generic traversal into subterms and can be customized with type-specific
behaviour.
  This paper seeks to provide practicing functional programmers with pragmatic
guidance in crafting their own strategic programs. We present the fundamentals
and the support from a user's perspective, and we initiate a catalogue of
\emph{strategy design patterns}. These design patterns aim at consolidating
strategic programming expertise in accessible form.
</summary>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <author>
      <name>Joost Visser</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0204015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0204015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.2.3; D.2.10" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0204018v3</id>
    <updated>2003-02-24T12:30:59Z</updated>
    <published>2002-04-09T18:32:40Z</published>
    <title>A Framework for Datatype Transformation</title>
    <summary>  We study one dimension in program evolution, namely the evolution of the
datatype declarations in a program. To this end, a suite of basic
transformation operators is designed. We cover structure-preserving
refactorings, but also structure-extending and -reducing adaptations. Both the
object programs that are subject to datatype transformations, and the meta
programs that encode datatype transformations are functional programs.
</summary>
    <author>
      <name>Jan Kort</name>
    </author>
    <author>
      <name>Ralf Laemmel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Minor revision; now accepted at LDTA 2003</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0204018v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0204018v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.2.3; D.2.6; D.2.7; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0302004v1</id>
    <updated>2003-02-03T15:52:17Z</updated>
    <published>2003-02-03T15:52:17Z</published>
    <title>Unique Pattern Matching in Strings</title>
    <summary>  Regular expression patterns are a key feature of document processing
languages like Perl and XDuce. It is in this context that the first and longest
match policies have been proposed to disambiguate the pattern matching process.
We formally define a matching semantics with these policies and show that the
generally accepted method of simulating longest match by first match and
recursion is incorrect. We continue by solving the associated type inference
problem, which consists in calculating for every subexpression the set of words
the subexpression can still match when these policies are in effect, and show
how this algorithm can be used to efficiently implement the matching process.
</summary>
    <author>
      <name>Stijn Vansummeren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0302004v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0302004v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.1.1; H.2.3; H.3.3; H.2.4; I.5.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0312023v1</id>
    <updated>2003-12-12T16:14:20Z</updated>
    <published>2003-12-12T16:14:20Z</published>
    <title>Inferring Termination Conditions for Logic Programs using Backwards
  Analysis</title>
    <summary>  This paper focuses on the inference of modes for which a logic program is
guaranteed to terminate. This generalises traditional termination analysis
where an analyser tries to verify termination for a specified mode. Our
contribution is a methodology in which components of traditional termination
analysis are combined with backwards analysis to obtain an analyser for
termination inference. We identify a condition on the components of the
analyser which guarantees that termination inference will infer all modes which
can be checked to terminate. The application of this methodology to enhance a
traditional termination analyser to perform also termination inference is
demonstrated.
</summary>
    <author>
      <name>Samir Genaim</name>
    </author>
    <author>
      <name>Michael Codish</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0312023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0312023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6,F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0312027v1</id>
    <updated>2003-12-15T13:43:37Z</updated>
    <published>2003-12-15T13:43:37Z</published>
    <title>An Open Ended Tree</title>
    <summary>  An open ended list is a well known data structure in Prolog programs. It is
frequently used to represent a value changing over time, while this value is
referred to from several places in the data structure of the application. A
weak point in this technique is that the time complexity is linear in the
number of updates to the value represented by the open ended list. In this
programming pearl we present a variant of the open ended list, namely an open
ended tree, with an update and access time complexity logarithmic in the number
of updates to the value.
</summary>
    <author>
      <name>Henk Vandecasteele</name>
    </author>
    <author>
      <name>Gerda Janssens</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">TPLP Vol 3(3) 2003 pp 377-385</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0312027v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0312027v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6;D.3.3;.E.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0402048v1</id>
    <updated>2004-02-20T14:09:02Z</updated>
    <published>2004-02-20T14:09:02Z</published>
    <title>Transformation Rules for Locally Stratified Constraint Logic Programs</title>
    <summary>  We propose a set of transformation rules for constraint logic programs with
negation. We assume that every program is locally stratified and, thus, it has
a unique perfect model. We give sufficient conditions which ensure that the
proposed set of transformation rules preserves the perfect model of the
programs. Our rules extend in some respects the rules for logic programs and
constraint logic programs already considered in the literature and, in
particular, they include a rule for unfolding a clause with respect to a
negative literal.
</summary>
    <author>
      <name>Fabio Fioravanti</name>
    </author>
    <author>
      <name>Alberto Pettorossi</name>
    </author>
    <author>
      <name>Maurizio Proietti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in: M. Bruynooghe, K.-K. Lau (Eds.) Program Development in
  Computational Logic, Lecture Notes in Computer Science, Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0402048v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0402048v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.2;D.1.6;I.2.2;F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0403016v1</id>
    <updated>2004-03-12T08:37:54Z</updated>
    <published>2004-03-12T08:37:54Z</published>
    <title>A Comparative Study of Arithmetic Constraints on Integer Intervals</title>
    <summary>  We propose here a number of approaches to implement constraint propagation
for arithmetic constraints on integer intervals. To this end we introduce
integer interval arithmetic. Each approach is explained using appropriate proof
rules that reduce the variable domains. We compare these approaches using a set
of benchmarks.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Peter Zoeteweij</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">24 pages. To appear in "Recent Advances in Constraints, 2003" K.R.
  Apt, F. Fages, F. Rossi, P. Szeredi and J. Vancza, eds, LNAI 3010,
  Springer-Verlag, 2004</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0403016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0403016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0404052v1</id>
    <updated>2004-04-25T03:49:44Z</updated>
    <published>2004-04-25T03:49:44Z</published>
    <title>Multi-Threading And Message Communication In Qu-Prolog</title>
    <summary>  This paper presents the multi-threading and internet message communication
capabilities of Qu-Prolog. Message addresses are symbolic and the
communications package provides high-level support that completely hides
details of IP addresses and port numbers as well as the underlying TCP/IP
transport layer. The combination of the multi-threads and the high level
inter-thread message communications provide simple, powerful support for
implementing internet distributed intelligent applications.
</summary>
    <author>
      <name>Keith L. Clark</name>
    </author>
    <author>
      <name>Peter J. Robinson</name>
    </author>
    <author>
      <name>Richard Hagen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 3,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 3, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0404052v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0404052v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405079v1</id>
    <updated>2004-05-23T18:56:57Z</updated>
    <published>2004-05-23T18:56:57Z</published>
    <title>Higher-Order Concurrent Win32 Programming</title>
    <summary>  We present a concurrent framework for Win32 programming based on Concurrent
ML, a concurrent language with higher-order functions, static typing,
lightweight threads and synchronous communication channels. The key points of
the framework are the move from an event loop model to a threaded model for the
processing of window messages, and the decoupling of controls notifications
from the system messages. This last point allows us to derive a general way of
writing controls that leads to easy composition, and can accommodate ActiveX
Controls in a transparent way.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages; appeared in Proceedings of the 3rd Usenix Windows NT
  Symposium, Seattle, pp. 113-122, 1999</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405079v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405079v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3;H.5.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405080v1</id>
    <updated>2004-05-23T19:09:11Z</updated>
    <published>2004-05-23T19:09:11Z</published>
    <title>Reactive Programming in Standard ML</title>
    <summary>  Reactive systems are systems that maintain an ongoing interaction with their
environment, activated by receiving input events from the environment and
producing output events in response. Modern programming languages designed to
program such systems use a paradigm based on the notions of instants and
activations. We describe a library for Standard ML that provides basic
primitives for programming reactive systems. The library is a low-level system
upon which more sophisticated reactive behaviors can be built, which provides a
convenient framework for prototyping extensions to existing reactive languages.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1109/ICCL.1998.674156</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1109/ICCL.1998.674156" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages; appeared in Proceedings of the IEEE International
  Conference on Computer Languages (ICCL'98), pp. 48-57, 1998</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405080v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405080v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405082v1</id>
    <updated>2004-05-23T19:35:49Z</updated>
    <published>2004-05-23T19:35:49Z</published>
    <title>Aspects de la Programmation d'Applications Win32 avec un Langage
  Fonctionnel</title>
    <summary>  A useful programming language needs to support writing programs that take
advantage of services and communication mechanisms supplied by the operating
system. We examine the problem of programming native Win32 applications under
Windows with Standard ML. We introduce an framework based on the IDL interface
language et a minimal foreign-functions interface to explore the Win32 API et
COM in the context of Standard ML.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <author>
      <name>Erik Meijer</name>
    </author>
    <author>
      <name>Dino Oliva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In french, 25 pages, 3 figures. Appeared in the Proceedings of the
  "Journees Francophones des Langages Applicatifs" (JFLA'99), 1999</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405082v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405082v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;D.3.3;H.5.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405083v1</id>
    <updated>2004-05-23T19:51:01Z</updated>
    <published>2004-05-23T19:51:01Z</published>
    <title>The Design of a COM-Oriented Module System</title>
    <summary>  We present in this paper the preliminary design of a module system based on a
notion of components such as they are found in COM. This module system is
inspired from that of Standard ML, and features first-class instances of
components, first-class interfaces, and interface-polymorphic functions, as
well as allowing components to be both imported from the environment and
exported to the environment using simple mechanisms. The module system
automates the memory management of interfaces and hides the IUnknown interface
and QueryInterface mechanisms from the programmer, favoring instead a
higher-level approach to handling interfaces.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages; appeared in Proceedings of the Joint Modular Languages
  Conference (JMLC'00). LNCS 1897, pp. 104-118, 2000</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0405083v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405083v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2;D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405085v1</id>
    <updated>2004-05-24T05:16:33Z</updated>
    <published>2004-05-24T05:16:33Z</published>
    <title>On the Expressive Power of First-Order Boolean Functions in PCF</title>
    <summary>  Recent results of Bucciarelli show that the semilattice of degrees of
parallelism of first-order boolean functions in PCF has both infinite chains
and infinite antichains. By considering a simple subclass of Sieber's
sequentiality relations, we identify levels in the semilattice and derive
inexpressibility results concerning functions on different levels. This allows
us to further explore the structure of the semilattice of degrees of
parallelism: we identify semilattices characterized by simple level properties,
and show the existence of new infinite hierarchies which are in a certain sense
natural with respect to the levels.
</summary>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <author>
      <name>Prakash Panangaden</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theoretical Computer Science 266(1-2), pp. 543-567, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0405085v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405085v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0405102v1</id>
    <updated>2004-05-27T03:08:30Z</updated>
    <published>2004-05-27T03:08:30Z</published>
    <title>A Proof Theoretic Approach to Failure in Functional Logic Programming</title>
    <summary>  How to extract negative information from programs is an important issue in
logic programming. Here we address the problem for functional logic programs,
from a proof-theoretic perspective. The starting point of our work is CRWL
(Constructor based ReWriting Logic), a well established theoretical framework
for functional logic programming, whose fundamental notion is that of
non-strict non-deterministic function. We present a proof calculus, CRWLF,
which is able to deduce negative information from CRWL-programs. In particular,
CRWLF is able to prove finite failure of reduction within CRWL.
</summary>
    <author>
      <name>Francisco Javier Lopez-Fraguas</name>
    </author>
    <author>
      <name>Jaime Sanchez-Hernandez</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 4, no.
  1&amp;2, 2004</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 4, no. 1&amp;2, 2004</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0405102v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0405102v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0406012v1</id>
    <updated>2004-06-07T07:01:53Z</updated>
    <published>2004-06-07T07:01:53Z</published>
    <title>Secure Prolog-Based Mobile Code</title>
    <summary>  LogicWeb mobile code consists of Prolog-like rules embedded in Web pages,
thereby adding logic programming behaviour to those pages. Since LogicWeb
programs are downloaded from foreign hosts and executed locally, there is a
need to protect the client from buggy or malicious code. A security model is
crucial for making LogicWeb mobile code safe to execute. This paper presents
such a model, which supports programs of varying trust levels by using
different resource access policies. The implementation of the model derives
from an extended operational semantics for the LogicWeb language, which
provides a precise meaning of safety.
</summary>
    <author>
      <name>Seng Wai Loke</name>
    </author>
    <author>
      <name>Andrew Davison</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 3,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 3, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0406012v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0406012v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0406014v1</id>
    <updated>2004-06-07T14:04:48Z</updated>
    <published>2004-06-07T14:04:48Z</published>
    <title>O(1) Reversible Tree Navigation Without Cycles</title>
    <summary>  Imperative programmers often use cyclically linked trees in order to achieve
O(1) navigation time to neighbours. Some logic programmers believe that cyclic
terms are necessary to achieve the same in logic-based languages. An old but
little-known technique provides O(1) time and space navigation without cyclic
links, in the form of reversible predicates. A small modification provides O(1)
amortised time and space editing.
</summary>
    <author>
      <name>Richard A. O'Keefe</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in Theory and Practice of Logic Programming, vol. 1, no. 5,
  2001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 1, no. 5, 2001</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0406014v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0406014v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0407043v1</id>
    <updated>2004-07-16T14:44:21Z</updated>
    <published>2004-07-16T14:44:21Z</published>
    <title>A Hyper-Arc Consistency Algorithm for the Soft Alldifferent Constraint</title>
    <summary>  This paper presents an algorithm that achieves hyper-arc consistency for the
soft alldifferent constraint. To this end, we prove and exploit the equivalence
with a minimum-cost flow problem. Consistency of the constraint can be checked
in O(nm) time, and hyper-arc consistency is achieved in O(m) time, where n is
the number of variables involved and m is the sum of the cardinalities of the
domains. It improves a previous method that did not ensure hyper-arc
consistency.
</summary>
    <author>
      <name>Willem Jan van Hoeve</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0407043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0407043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3; G.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0409009v1</id>
    <updated>2004-09-07T09:44:18Z</updated>
    <published>2004-09-07T09:44:18Z</published>
    <title>CrocoPat 2.1 Introduction and Reference Manual</title>
    <summary>  CrocoPat is an efficient, powerful and easy-to-use tool for manipulating
relations of arbitrary arity, including directed graphs. This manual provides
an introduction to and a reference for CrocoPat and its programming language
RML. It includes several application examples, in particular from the analysis
of structural models of software systems.
</summary>
    <author>
      <name>Dirk Beyer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of California, Berkeley</arxiv:affiliation>
    </author>
    <author>
      <name>Andreas Noack</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Brandenburg University of Technology</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">19 pages + cover, 2 eps figures, uses llncs.cls and
  cs_techrpt_cover.sty, for downloading the source code, binaries, and RML
  examples, see http://www.software-systemtechnik.de/CrocoPat/</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0409009v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0409009v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; G.2.2.a; E.1.d; D.2.7m" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0501073v1</id>
    <updated>2005-01-25T13:28:38Z</updated>
    <published>2005-01-25T13:28:38Z</published>
    <title>Optimal Union-Find in Constraint Handling Rules</title>
    <summary>  Constraint Handling Rules (CHR) is a committed-choice rule-based language
that was originally intended for writing constraint solvers. In this paper we
show that it is also possible to write the classic union-find algorithm and
variants in CHR. The programs neither compromise in declarativeness nor
efficiency. We study the time complexity of our programs: they match the
almost-linear complexity of the best known imperative implementations. This
fact is illustrated with experimental results.
</summary>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <author>
      <name>Thom Fruehwirth</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 3 figures, to appear in Theory and Practice of Logic
  Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0501073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0501073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0504008v10</id>
    <updated>2009-08-25T15:36:19Z</updated>
    <published>2005-04-04T06:19:43Z</published>
    <title>Super Object Oriented Programming</title>
    <summary>  This submission has been withdrawn at the request of the author.
</summary>
    <author>
      <name>Raju Renjit. G</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0504008v10" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0504008v10" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0504025v15</id>
    <updated>2009-08-25T15:34:49Z</updated>
    <published>2005-04-07T13:21:15Z</published>
    <title>Incorporating LINQ, State Diagrams Templating and Package Extension Into
  Java</title>
    <summary>  This submission has been withdrawn at the request of the author.
</summary>
    <author>
      <name>Raju Renjit. G</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0504025v15" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0504025v15" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0506035v1</id>
    <updated>2005-06-10T15:28:00Z</updated>
    <published>2005-06-10T15:28:00Z</published>
    <title>Fast Recompilation of Object Oriented Modules</title>
    <summary>  Once a program file is modified, the recompilation time should be minimized,
without sacrificing execution speed or high level object oriented features. The
recompilation time is often a problem for the large graphical interactive
distributed applications tackled by modern OO languages. A compilation server
and fast code generator were developed and integrated with the SRC Modula-3
compiler and Linux ELF dynamic linker. The resulting compilation and
recompilation speedups are impressive. The impact of different language
features, processor speed, and application size are discussed.
</summary>
    <author>
      <name>Jerome Collin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Engineering, Ecole Polytechnique de Montreal</arxiv:affiliation>
    </author>
    <author>
      <name>Michel Dagenais</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Engineering, Ecole Polytechnique de Montreal</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/cs/0506035v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0506035v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507036v1</id>
    <updated>2005-07-14T08:47:45Z</updated>
    <published>2005-07-14T08:47:45Z</published>
    <title>Improved Inference for Checking Annotations</title>
    <summary>  We consider type inference in the Hindley/Milner system extended with type
annotations and constraints with a particular focus on Haskell-style type
classes. We observe that standard inference algorithms are incomplete in the
presence of nested type annotations. To improve the situation we introduce a
novel inference scheme for checking type annotations. Our inference scheme is
also incomplete in general but improves over existing implementations as found
e.g. in the Glasgow Haskell Compiler (GHC). For certain cases (e.g. Haskell 98)
our inference scheme is complete. Our approach has been fully implemented as
part of the Chameleon system (experimental version of Haskell).
</summary>
    <author>
      <name>Peter J Stuckey</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <author>
      <name>Jeremy Wazny</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0507036v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507036v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507037v1</id>
    <updated>2005-07-14T08:58:31Z</updated>
    <published>2005-07-14T08:58:31Z</published>
    <title>Type Inference for Guarded Recursive Data Types</title>
    <summary>  We consider type inference for guarded recursive data types (GRDTs) -- a
recent generalization of algebraic data types. We reduce type inference for
GRDTs to unification under a mixed prefix. Thus, we obtain efficient type
inference. Inference is incomplete because the set of type constraints allowed
to appear in the type system is only a subset of those type constraints
generated by type inference. Hence, inference only succeeds if the program is
sufficiently type annotated. We present refined procedures to infer types
incrementally and to assist the user in identifying which pieces of type
information are missing. Additionally, we introduce procedures to test if a
type is not principal and to find a principal type if one exists.
</summary>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0507037v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507037v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0507043v3</id>
    <updated>2006-03-16T08:24:17Z</updated>
    <published>2005-07-18T13:06:13Z</published>
    <title>Proof rules for purely quantum programs</title>
    <summary>  We apply the notion of quantum predicate proposed by D'Hondt and Panangaden
to analyze a purely quantum language fragment which describes the quantum part
of a future quantum computer in Knill's architecture. The denotational
semantics, weakest precondition semantics, and weakest liberal precondition
semantics of this language fragment are introduced. To help reasoning about
quantum programs involving quantum loops, we extend proof rules for classical
probabilistic programs to our purely quantum programs.
</summary>
    <author>
      <name>Yuan Feng</name>
    </author>
    <author>
      <name>Runyao Duan</name>
    </author>
    <author>
      <name>Zhengfeng Ji</name>
    </author>
    <author>
      <name>Mingsheng Ying</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Now 12 pages, introduction and Section 3 rewritten, some errors
  corrected</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0507043v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0507043v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0509057v1</id>
    <updated>2005-09-19T15:30:10Z</updated>
    <published>2005-09-19T15:30:10Z</published>
    <title>Language embeddings that preserve staging and safety</title>
    <summary>  We study embeddings of programming languages into one another that preserve
what reductions take place at compile-time, i.e., staging. A certain condition
-- what we call a `Turing complete kernel' -- is sufficient for a language to
be stage-universal in the sense that any language may be embedded in it while
preserving staging. A similar line of reasoning yields the notion of
safety-preserving embeddings, and a useful characterization of
safety-universality. Languages universal with respect to staging and safety are
good candidates for realizing domain-specific embedded languages (DSELs) and
`active libraries' that provide domain-specific optimizations and safety
checks.
</summary>
    <author>
      <name>Todd L. Veldhuizen</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0509057v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0509057v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0510074v1</id>
    <updated>2005-10-24T16:27:00Z</updated>
    <published>2005-10-24T16:27:00Z</published>
    <title>Practical Datatype Specializations with Phantom Types and Recursion
  Schemes</title>
    <summary>  Datatype specialization is a form of subtyping that captures program
invariants on data structures that are expressed using the convenient and
intuitive datatype notation. Of particular interest are structural invariants
such as well-formedness. We investigate the use of phantom types for describing
datatype specializations. We show that it is possible to express
statically-checked specializations within the type system of Standard ML. We
also show that this can be done in a way that does not lose useful programming
facilities such as pattern matching in case expressions.
</summary>
    <author>
      <name>Matthew Fluet</name>
    </author>
    <author>
      <name>Riccardo Pucella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">25 pages. Appeared in the Proc. of the 2005 ACM SIGPLAN Workshop on
  ML</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0510074v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0510074v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0511090v2</id>
    <updated>2006-01-14T15:48:00Z</updated>
    <published>2005-11-27T14:58:22Z</published>
    <title>Integration of Declarative and Constraint Programming</title>
    <summary>  Combining a set of existing constraint solvers into an integrated system of
cooperating solvers is a useful and economic principle to solve hybrid
constraint problems. In this paper we show that this approach can also be used
to integrate different language paradigms into a unified framework.
Furthermore, we study the syntactic, semantic and operational impacts of this
idea for the amalgamation of declarative and constraint programming.
</summary>
    <author>
      <name>Petra Hofstedt</name>
    </author>
    <author>
      <name>Peter Pepper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">30 pages, 9 figures, To appear in Theory and Practice of Logic
  Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0511090v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0511090v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0601019v2</id>
    <updated>2006-11-21T13:02:37Z</updated>
    <published>2006-01-06T19:50:29Z</published>
    <title>Canonical Abstract Syntax Trees</title>
    <summary>  This paper presents Gom, a language for describing abstract syntax trees and
generating a Java implementation for those trees. Gom includes features
allowing the user to specify and modify the interface of the data structure.
These features provide in particular the capability to maintain the internal
representation of data in canonical form with respect to a rewrite system. This
explicitly guarantees that the client program only manipulates normal forms for
this rewrite system, a feature which is only implicitly used in many
implementations.
</summary>
    <author>
      <name>Antoine Reilles</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Lorraine - LORIA</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Dans Workshop on Rewriting Techniques and Applications (2006)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0601019v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0601019v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0602027v1</id>
    <updated>2006-02-07T15:19:53Z</updated>
    <published>2006-02-07T15:19:53Z</published>
    <title>Explaining Constraint Programming</title>
    <summary>  We discuss here constraint programming (CP) by using a proof-theoretic
perspective. To this end we identify three levels of abstraction. Each level
sheds light on the essence of CP.
  In particular, the highest level allows us to bring CP closer to the
computation as deduction paradigm. At the middle level we can explain various
constraint propagation algorithms. Finally, at the lowest level we can address
the issue of automatic generation and optimization of the constraint
propagation algorithms.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, appeared in "Processes, Terms and Cycles: Steps on the Road
  to Infinity", (A. Middeldorp, V. van Oostrom, F. van Raamsdonk, R. de Vrijer,
  eds.), LNCS 3838, pp. 55-69. (2005)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0602027v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0602027v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0603100v1</id>
    <updated>2006-03-26T20:27:40Z</updated>
    <published>2006-03-26T20:27:40Z</published>
    <title>Efficient Compression of Prolog Programs</title>
    <summary>  We propose a special-purpose class of compression algorithms for efficient
compression of Prolog programs. It is a dictionary-based compression method,
specially designed for the compression of Prolog code, and therefore we name it
PCA (Prolog Compression Algorithm). According to the experimental results this
method provides better compression than state-of-the-art general-purpose
compression algorithms. Since the algorithm works with Prolog syntactic
entities (e.g. atoms, terms, etc.) the implementation of a Prolog prototype is
straightforward and very easy to use in any Prolog application that needs
compression. Although the algorithm is designed for Prolog programs, the idea
can be easily applied for the compression of programs written in other (logic)
languages.
</summary>
    <author>
      <name>Alin Suciu</name>
    </author>
    <author>
      <name>Kalman Pusztai</name>
    </author>
    <link href="http://arxiv.org/abs/cs/0603100v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0603100v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0606102v3</id>
    <updated>2011-02-18T00:41:26Z</updated>
    <published>2006-06-24T18:51:54Z</published>
    <title>Toward Functionality Oriented Programming</title>
    <summary>  The concept of functionality oriented programming is proposed, and some of
its aspects are discussed, such as: (1) implementation independent basic types
and generic collection types; (2) syntax requirements and recommendations for
implementation independence; (3) unified documentation and code; (4)
cross-module interface; and (5) cross-language program making scheme. A
prototype example is given to demonstrate functionality oriented programming.
</summary>
    <author>
      <name>Chengpu Wang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper has been withdrawn by the author. 21 Pages, 7 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0606102v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0606102v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0607016v2</id>
    <updated>2007-03-21T13:51:00Z</updated>
    <published>2006-07-06T10:09:43Z</published>
    <title>An Analysis of Arithmetic Constraints on Integer Intervals</title>
    <summary>  Arithmetic constraints on integer intervals are supported in many constraint
programming systems. We study here a number of approaches to implement
constraint propagation for these constraints. To describe them we introduce
integer interval arithmetic. Each approach is explained using appropriate proof
rules that reduce the variable domains. We compare these approaches using a set
of benchmarks. For the most promising approach we provide results that
characterize the effect of constraint propagation. This is a full version of
our earlier paper, cs.PL/0403016.
</summary>
    <author>
      <name>Krzysztof R. Apt</name>
    </author>
    <author>
      <name>Peter Zoeteweij</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">44 pages, to appear in 'Constraints' journal</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0607016v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0607016v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0608015v1</id>
    <updated>2006-08-03T02:41:20Z</updated>
    <published>2006-08-03T02:41:20Z</published>
    <title>Towards "Propagation = Logic + Control"</title>
    <summary>  Constraint propagation algorithms implement logical inference. For
efficiency, it is essential to control whether and in what order basic
inference steps are taken. We provide a high-level framework that clearly
differentiates between information needed for controlling propagation versus
that needed for the logical semantics of complex constraints composed from
primitive ones. We argue for the appropriateness of our controlled propagation
framework by showing that it captures the underlying principles of manually
designed propagation algorithms, such as literal watching for unit clause
propagation and the lexicographic ordering constraint. We provide an
implementation and benchmark results that demonstrate the practicality and
efficiency of our framework.
</summary>
    <author>
      <name>Sebastian Brand</name>
    </author>
    <author>
      <name>Roland H. C. Yap</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages; 22nd International Conference on Logic Programming
  (ICLP'06)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0608015v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0608015v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0609092v1</id>
    <updated>2006-09-16T12:22:15Z</updated>
    <published>2006-09-16T12:22:15Z</published>
    <title>Analysis of Equality Relationships for Imperative Programs</title>
    <summary>  In this article, we discuss a flow--sensitive analysis of equality
relationships for imperative programs. We describe its semantic domains,
general purpose operations over abstract computational states (term evaluation
and identification, semantic completion, widening operator, etc.) and semantic
transformers corresponding to program constructs. We summarize our experiences
from the last few years concerning this analysis and give attention to
applications of analysis of automatically generated code. Among other
illustrating examples, we consider a program for which the analysis diverges
without a widening operator and results of analyzing residual programs produced
by some automatic partial evaluator. An example of analysis of a program
generated by this evaluator is given.
</summary>
    <author>
      <name>P. Emelyanov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">31 pages, 10 figures, 2 tables, 1 appendix</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0609092v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0609092v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0610164v2</id>
    <updated>2006-10-31T09:09:11Z</updated>
    <published>2006-10-30T08:39:04Z</published>
    <title>Complexity of Data Flow Analysis for Non-Separable Frameworks</title>
    <summary>  The complexity of round robin method of intraprocedural data flow analysis is
measured in number of iterations over the control flow graph. Existing
complexity bounds realistically explain the complexity of only Bit-vector
frameworks which are separable. In this paper we define the complexity bounds
for non-separable frameworks by quantifying the interdependences among the data
flow information of program entities using an Entity Dependence Graph.
</summary>
    <author>
      <name>Bageshri Karkare</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Sathe</arxiv:affiliation>
    </author>
    <author>
      <name>Uday Khedker</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Published in the International Conference on Programming Languages
  and Compilers (PLC) 2006, Las Vegas, U.S.A</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0610164v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0610164v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701081v1</id>
    <updated>2007-01-12T15:39:29Z</updated>
    <published>2007-01-12T15:39:29Z</published>
    <title>Fingerprinting Logic Programs</title>
    <summary>  In this work we present work in progress on functionality duplication
detection in logic programs. Eliminating duplicated functionality recently
became prominent in context of refactoring. We describe a quantitative approach
that allows to measure the ``similarity'' between two predicate definitions.
Moreover, we show how to compute a so-called ``fingerprint'' for every
predicate. Fingerprints capture those characteristics of the predicate that are
significant when searching for duplicated functionality. Since reasoning on
fingerprints is much easier than reasoning on predicate definitions, comparing
the fingerprints is a promising direction in automated code duplication in
logic programs.
</summary>
    <author>
      <name>Alexander Serebrenik</name>
    </author>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 16th Workshop on Logic-based methods in
  Programming Languages (WLPE2006)</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701081v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701081v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701147v1</id>
    <updated>2007-01-24T06:55:34Z</updated>
    <published>2007-01-24T06:55:34Z</published>
    <title>A Generic Analysis Environment for Curry Programs</title>
    <summary>  We present CurryBrowser, a generic analysis environment for the declarative
multi-paradigm language Curry. CurryBrowser supports browsing through the
program code of an application written in Curry, i.e., the main module and all
directly or indirectly imported modules. Each module can be shown in different
formats (e.g., source code, interface, intermediate code) and, inside each
module, various properties of functions defined in this module can be analyzed.
In order to support the integration of various program analyses, CurryBrowser
has a generic interface to connect local and global analyses implemented in
Curry. CurryBrowser is completely implemented in Curry using libraries for GUI
programming and meta-programming.
</summary>
    <author>
      <name>Michael Hanus</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 16th Workshop on Logic-based Methods in
  Programming Environments</arxiv:comment>
    <link href="http://arxiv.org/abs/cs/0701147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701192v5</id>
    <updated>2008-05-22T09:35:12Z</updated>
    <published>2007-01-30T16:26:50Z</published>
    <title>The pitfalls of verifying floating-point computations</title>
    <summary>  Current critical systems commonly use a lot of floating-point computations,
and thus the testing or static analysis of programs containing floating-point
operators has become a priority. However, correctly defining the semantics of
common implementations of floating-point is tricky, because semantics may
change with many factors beyond source-code level, such as choices made by
compilers. We here give concrete examples of problems that can appear and
solutions to implement in analysis software.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS, Verimag - Imag</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/1353445.1353446</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/1353445.1353446" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Transactions on Programming Languages and Systems 30, 3 (2008)
  12</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701192v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701192v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; G.1.0; G.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0701195v1</id>
    <updated>2007-01-30T17:14:52Z</updated>
    <published>2007-01-30T17:14:52Z</published>
    <title>An Abstract Monte-Carlo Method for the Analysis of Probabilistic
  Programs</title>
    <summary>  We introduce a new method, combination of random testing and abstract
interpretation, for the analysis of programs featuring both probabilistic and
non-probabilistic nondeterminism. After introducing "ordinary" testing, we show
how to combine testing and abstract interpretation and give formulas linking
the precision of the results to the number of iterations. We then discuss
complexity and optimization issues and end with some experimental results.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/360204.360211</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/360204.360211" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">POPL: Annual Symposium on Principles of Programming Languages
  (2001) 93 - 101</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0701195v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0701195v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0702072v1</id>
    <updated>2007-02-13T03:10:02Z</updated>
    <published>2007-02-13T03:10:02Z</published>
    <title>Logic Programming with Satisfiability</title>
    <summary>  This paper presents a Prolog interface to the MiniSat satisfiability solver.
Logic program- ming with satisfiability combines the strengths of the two
paradigms: logic programming for encoding search problems into satisfiability
on the one hand and efficient SAT solving on the other. This synergy between
these two exposes a programming paradigm which we propose here as a logic
programming pearl. To illustrate logic programming with SAT solving we give an
example Prolog program which solves instances of Partial MAXSAT.
</summary>
    <author>
      <name>Michael Codish</name>
    </author>
    <author>
      <name>Vitaly Lagoon</name>
    </author>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 3 figures, 1 table</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming: 8(1):121-128, 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0702072v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0702072v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0703077v2</id>
    <updated>2007-03-16T08:51:01Z</updated>
    <published>2007-03-15T06:07:02Z</published>
    <title>Relational Abstract Domains for the Detection of Floating-Point Run-Time
  Errors</title>
    <summary>  We present a new idea to adapt relational abstract domains to the analysis of
IEEE 754-compliant floating-point numbers in order to statically detect,
through abstract Interpretation-based static analyses, potential floating-point
run-time exceptions such as overflows or invalid operations. In order to take
the non-linearity of rounding into account, expressions are modeled as linear
forms with interval coefficients. We show how to extend already existing
numerical abstract domains, such as the octagon abstract domain, to efficiently
abstract transfer functions based on interval linear forms. We discuss specific
fixpoint stabilization techniques and give some experimental results.
</summary>
    <author>
      <name>Antoine Miné</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">(update: reversed author first and last names)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">European Symposium on Programming (ESOP) (03/2004) 3-17</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0703077v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0703077v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/cs/0703084v2</id>
    <updated>2007-03-16T08:47:24Z</updated>
    <published>2007-03-15T18:16:32Z</published>
    <title>The Octagon Abstract Domain</title>
    <summary>  This article presents a new numerical abstract domain for static analysis by
abstract interpretation. It extends a former numerical abstract domain based on
Difference-Bound Matrices and allows us to represent invariants of the form
(+/-x+/-y&lt;=c), where x and y are program variables and c is a real constant. We
focus on giving an efficient representation based on Difference-Bound Matrices
- O(n2) memory cost, where n is the number of variables - and graph-based
algorithms for all common abstract operators - O(n3) time cost. This includes a
normal form algorithm to test equivalence of representation and a widening
operator to compute least fixpoint approximations.
</summary>
    <author>
      <name>Antoine Miné</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIENS</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">(update: reversed author first and last names)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Analysis, Slicing and Transformation (AST) (10/2001) 310-319</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/cs/0703084v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/cs/0703084v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.1452v1</id>
    <updated>2007-05-10T12:19:51Z</updated>
    <published>2007-05-10T12:19:51Z</published>
    <title>Typer la dé-sérialisation sans sérialiser les types</title>
    <summary>  In this paper, we propose a way of assigning static type information to
unmarshalling functions and we describe a verification technique for
unmarshalled data that preserves the execution safety provided by static type
checking. This technique, whose correctness is proven, relies on singleton
types whose values are transmitted to unmarshalling routines at runtime, and on
an efficient checking algorithm able to deal with sharing and cycles.
</summary>
    <author>
      <name>Grégoire Henry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Michel Mauny</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt, ENSTA-UMA</arxiv:affiliation>
    </author>
    <author>
      <name>Emmanuel Chailloux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journ\'ee francophone des langages applicatifs (JFLA) 2006
  (01/2006)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.1452v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.1452v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.1458v1</id>
    <updated>2007-05-10T12:31:17Z</updated>
    <published>2007-05-10T12:31:17Z</published>
    <title>Mixing the Objective Caml and C# Programming Models in the .Net
  Framework</title>
    <summary>  We present a new code generator, called O'Jacare.net, to inter-operate
between C# and Objective Caml through their object models. O'Jacare.net defines
a basic IDL (Interface Definition Language) that describes classes and
interfaces in order to communicate between Objective Caml and C#. O'Jacare.net
generates all needed wrapper classes and takes advantage of static type
checking in both worlds. Although the IDL intersects these two object models,
O'Jacare.net allows to combine features from both.
</summary>
    <author>
      <name>Emmanuel Chailloux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Grégoire Henry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Raphaël Montelatici</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop on MULTIPARADIGM PROGRAMMING WITH OO LANGUAGES (MPOOL),
  Norv\`ege (06/2004)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.1458v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.1458v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0705.2126v1</id>
    <updated>2007-05-15T12:06:32Z</updated>
    <published>2007-05-15T12:06:32Z</published>
    <title>Improvements to the Psi-SSA representation</title>
    <summary>  Modern compiler implementations use the Static Single Assignment
representation as a way to efficiently implement optimizing algorithms. However
this representation is not well adapted to architectures with a predicated
instruction set. The Psi-SSA representation extends the SSA representation such
that standard SSA algorithms can be easily adapted to an architecture with a
fully predicated instruction set. A new pseudo operation, the Psi operation, is
introduced to merge several conditional definitions into a unique definition.
</summary>
    <author>
      <name>Francois De Ferriere</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Published in proceedings for the workshop "Software and Compilers
  for Embedded Systems (SCOPES) 2007" (20/04/2007)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0705.2126v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0705.2126v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0706.2293v1</id>
    <updated>2007-06-15T13:39:12Z</updated>
    <published>2007-06-15T13:39:12Z</published>
    <title>Resource control of object-oriented programs</title>
    <summary>  A sup-interpretation is a tool which provides an upper bound on the size of a
value computed by some symbol of a program. Sup-interpretations have shown
their interest to deal with the complexity of first order functional programs.
For instance, they allow to characterize all the functions bitwise computable
in Alogtime. This paper is an attempt to adapt the framework of
sup-interpretations to a fragment of oriented-object programs, including
distinct encodings of numbers through the use of constructor symbols, loop and
while constructs and non recursive methods with side effects. We give a
criterion, called brotherly criterion, which ensures that each brotherly
program computes objects whose size is polynomially bounded by the inputs
sizes.
</summary>
    <author>
      <name>Jean-Yves Marion</name>
    </author>
    <author>
      <name>Romain Pechoux</name>
    </author>
    <link href="http://arxiv.org/abs/0706.2293v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0706.2293v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0344v1</id>
    <updated>2007-11-02T16:53:34Z</updated>
    <published>2007-11-02T16:53:34Z</published>
    <title>Automatic Coding Rule Conformance Checking Using Logic Programs</title>
    <summary>  Some approaches to increasing program reliability involve a disciplined use
of programming languages so as to minimise the hazards introduced by
error-prone features. This is realised by writing code that is constrained to a
subset of the a priori admissible programs, and that, moreover, may use only a
subset of the language. These subsets are determined by a collection of
so-called coding rules.
</summary>
    <author>
      <name>Guillem Marpons-Ucero</name>
    </author>
    <author>
      <name>Julio Mariño</name>
    </author>
    <author>
      <name>Ángel Herranz</name>
    </author>
    <author>
      <name>Lars-Åke Fredlund</name>
    </author>
    <author>
      <name>Manuel Carro</name>
    </author>
    <author>
      <name>Juan José Moreno-Navarro</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0344v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0344v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0345v1</id>
    <updated>2007-11-02T16:40:10Z</updated>
    <published>2007-11-02T16:40:10Z</published>
    <title>A Prolog-based Environment for Reasoning about Programming Languages
  (Extended abstract)</title>
    <summary>  ECLAIR is a Prolog-based prototype system aiming to provide a functionally
complete environment for the study, development and evaluation of programming
language analysis and implementation tools. In this paper, we sketch the
overall structure of the system, outlining the main methodologies and
technologies underlying its components. We also discuss the appropriateness of
Prolog as the implementation language for the system: besides highlighting its
strengths, we also point out a few potential weaknesses, hinting at possible
solutions.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Patricia Hill</name>
    </author>
    <author>
      <name>Enea Zaffanella</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0345v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0345v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0348v1</id>
    <updated>2007-11-02T16:49:30Z</updated>
    <published>2007-11-02T16:49:30Z</published>
    <title>Compiling ER Specifications into Declarative Programs</title>
    <summary>  This paper proposes an environment to support high-level database programming
in a declarative programming language. In order to ensure safe database
updates, all access and update operations related to the database are generated
from high-level descriptions in the entity- relationship (ER) model. We propose
a representation of ER diagrams in the declarative language Curry so that they
can be constructed by various tools and then translated into this
representation. Furthermore, we have implemented a compiler from this
representation into a Curry program that provides access and update operations
based on a high-level API for database programming.
</summary>
    <author>
      <name>Bernd Braßel</name>
    </author>
    <author>
      <name>Michael Hanus</name>
    </author>
    <author>
      <name>Marion Muller</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0348v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0348v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0711.0618v1</id>
    <updated>2007-11-05T12:13:12Z</updated>
    <published>2007-11-05T12:13:12Z</published>
    <title>PIDoc: Wiki style Literate Programming for Prolog</title>
    <summary>  This document introduces PlDoc, a literate programming system for Prolog.
Starting point for PlDoc was minimal distraction from the programming task and
maximal immediate reward, attempting to seduce the programmer to use the
system. Minimal distraction is achieved using structured comments that are as
closely as possible related to common Prolog documentation practices. Immediate
reward is provided by a web interface powered from the Prolog development
environment that integrates searching and browsing application and system
documentation. When accessed from localhost, it is possible to go from
documentation shown in a browser to the source code displayed in the user's
editor of choice.
</summary>
    <author>
      <name>Jan Wielemaker</name>
    </author>
    <author>
      <name>Anjo Anjewierden</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 17th Workshop on Logic-based Methods in
  Programming Environments (WLPE2007)</arxiv:comment>
    <link href="http://arxiv.org/abs/0711.0618v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0711.0618v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0801.0133v1</id>
    <updated>2007-12-30T14:43:27Z</updated>
    <published>2007-12-30T14:43:27Z</published>
    <title>An Approach to Programming Based on Concepts</title>
    <summary>  In this paper we describe a new approach to programming which generalizes
object-oriented programming. It is based on using a new programming construct,
called concept, which generalizes classes. Concept is defined as a pair of two
classes: one reference class and one object class. Each concept has a parent
concept which is specified using inclusion relation generalizing inheritance.
We describe several important mechanisms such as reference resolution, context
stack, dual methods and life-cycle management, inheritance and polymorphism.
This approach to programming is positioned as a new programming paradigm and
therefore we formulate its main principles and rules.
</summary>
    <author>
      <name>Alexandr Savinov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">49 pages. Related papers: http://conceptoriented.com</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, Academy of Sciences
  of Moldova, Technical Report RT0005, 2007</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0801.0133v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0801.0133v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0801.1219v1</id>
    <updated>2008-01-08T12:28:18Z</updated>
    <published>2008-01-08T12:28:18Z</published>
    <title>DSL development based on target meta-models. Using AST transformations
  for automating semantic analysis in a textual DSL framework</title>
    <summary>  This paper describes an approach to creating textual syntax for Do-
main-Specific Languages (DSL). We consider target meta-model to be the main
artifact and hence to be developed first. The key idea is to represent analysis
of textual syntax as a sequence of transformations. This is made by explicit
opera- tions on abstract syntax trees (ATS), for which a simple language is
proposed. Text-to-model transformation is divided into two parts: text-to-AST
(developed by openArchitectureWare [1]) and AST-to-model (proposed by this
paper). Our approach simplifies semantic analysis and helps to generate as much
as possi- ble.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/0801.1219v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0801.1219v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0802.3492v2</id>
    <updated>2010-03-25T19:06:42Z</updated>
    <published>2008-02-24T05:28:52Z</published>
    <title>The RDF Virtual Machine</title>
    <summary>  The Resource Description Framework (RDF) is a semantic network data model
that is used to create machine-understandable descriptions of the world and is
the basis of the Semantic Web. This article discusses the application of RDF to
the representation of computer software and virtual computing machines. The
Semantic Web is posited as not only a web of data, but also as a web of
programs and processes.
</summary>
    <author>
      <name>Marko A. Rodriguez</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.knosys.2011.04.004</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.knosys.2011.04.004" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">keywords: Resource Description Framework, Virtual Machines,
  Distributed Computing, Semantic Web</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Knowledge-Based Systems, 24(6), 890-903, August 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0802.3492v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0802.3492v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; I.2.4; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0802.4018v2</id>
    <updated>2008-03-21T11:22:39Z</updated>
    <published>2008-02-27T13:21:51Z</published>
    <title>Algebraic Pattern Matching in Join Calculus</title>
    <summary>  We propose an extension of the join calculus with pattern matching on
algebraic data types. Our initial motivation is twofold: to provide an
intuitive semantics of the interaction between concurrency and pattern
matching; to define a practical compilation scheme from extended join
definitions into ordinary ones plus ML pattern matching. To assess the
correctness of our compilation scheme, we develop a theory of the applied join
calculus, a calculus with value passing and value matching. We implement this
calculus as an extension of the current JoCaml system.
</summary>
    <author>
      <name>Qin Ma</name>
    </author>
    <author>
      <name>Luc Maranget</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-4(1:7)2008</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-4(1:7)2008" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 4, Issue 1 (March 21,
  2008) lmcs:770</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0802.4018v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0802.4018v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0804.1118v1</id>
    <updated>2008-04-07T19:48:31Z</updated>
    <published>2008-04-07T19:48:31Z</published>
    <title>A Survey of Quantum Programming Languages: History, Methods, and Tools</title>
    <summary>  Quantum computer programming is emerging as a new subject domain from
multidisciplinary research in quantum computing, computer science, mathematics
(especially quantum logic, lambda calculi, and linear logic), and engineering
attempts to build the first non-trivial quantum computer. This paper briefly
surveys the history, methods, and proposed tools for programming quantum
computers circa late 2007. It is intended to provide an extensive but
non-exhaustive look at work leading up to the current state-of-the-art in
quantum computer programming. Further, it is an attempt to analyze the needed
programming tools for quantum programmers, to use this analysis to predict the
direction in which the field is moving, and to make recommendations for further
development of quantum programming language tools.
</summary>
    <author>
      <name>Donald A. Sofge</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0804.1118v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0804.1118v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0804.1696v2</id>
    <updated>2008-04-24T15:46:28Z</updated>
    <published>2008-04-10T13:21:32Z</published>
    <title>A classification of invasive patterns in AOP</title>
    <summary>  Aspect-Oriented Programming (AOP) improves modularity by encapsulating
crosscutting concerns into aspects. Some mechanisms to compose aspects allow
invasiveness as a mean to integrate concerns. Invasiveness means that AOP
languages have unrestricted access to program properties. Such kind of
languages are interesting because they allow performing complex operations and
better introduce functionalities. In this report we present a classification of
invasive patterns in AOP. This classification characterizes the aspects
invasive behavior and allows developers to abstract about the aspect incidence
over the program they crosscut.
</summary>
    <author>
      <name>Freddy Munoz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <author>
      <name>Benoit Baudry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Barais</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRISA</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0804.1696v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0804.1696v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0805.4029v1</id>
    <updated>2008-05-27T01:31:05Z</updated>
    <published>2008-05-27T01:31:05Z</published>
    <title>Event Synchronization by Lightweight Message Passing</title>
    <summary>  Concurrent ML's events and event combinators facilitate modular concurrent
programming with first-class synchronization abstractions. A standard
implementation of these abstractions relies on fairly complex manipulations of
first-class continuations in the underlying language. In this paper, we present
a lightweight implementation of these abstractions in Concurrent Haskell, a
language that already provides first-order message passing. At the heart of our
implementation is a new distributed synchronization protocol. In contrast with
several previous translations of event abstractions in concurrent languages, we
remain faithful to the standard semantics for events and event combinators; for
example, we retain the symmetry of $\mathtt{choose}$ for expressing selective
communication.
</summary>
    <author>
      <name>Avik Chaudhuri</name>
    </author>
    <link href="http://arxiv.org/abs/0805.4029v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0805.4029v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0809.1437v1</id>
    <updated>2008-09-09T14:39:57Z</updated>
    <published>2008-09-09T14:39:57Z</published>
    <title>How applicable is Python as first computer language for teaching
  programming in a pre-university educational environment, from a teacher's
  point of view?</title>
    <summary>  This project report attempts to evaluate the educational properties of the
Python computer language, in practice. This is done by examining computer
language evolution history, related scientific background work, the existing
educational research on computer languages and Python's experimental
application in higher secondary education in Greece, during first half of year
2002. This Thesis Report was delivered in advance of a thesis defense for a
Masters/Doctorandus (MSc/Drs) title with the Amstel Institute/Universiteit van
Amsterdam, during the same year.
</summary>
    <author>
      <name>Fotis Georgatos</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">135 pages, 20 tables, 10 figures (incl. evolution of computer
  languages)</arxiv:comment>
    <link href="http://arxiv.org/abs/0809.1437v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0809.1437v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; K.3.2; I.2.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0809.4635v1</id>
    <updated>2008-09-26T13:57:36Z</updated>
    <published>2008-09-26T13:57:36Z</published>
    <title>Mechanistic Behavior of Single-Pass Instruction Sequences</title>
    <summary>  Earlier work on program and thread algebra detailed the functional,
observable behavior of programs under execution. In this article we add the
modeling of unobservable, mechanistic processing, in particular processing due
to jump instructions. We model mechanistic processing preceding some further
behavior as a delay of that behavior; we borrow a unary delay operator from
discrete time process algebra. We define a mechanistic improvement ordering on
threads and observe that some threads do not have an optimal implementation.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Mark B. van der Zwaag</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0809.4635v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0809.4635v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0810.0372v1</id>
    <updated>2008-10-02T09:41:52Z</updated>
    <published>2008-10-02T09:41:52Z</published>
    <title>Optimizing Binary Code Produced by Valgrind (Project Report on Virtual
  Execution Environments Course - AVExe)</title>
    <summary>  Valgrind is a widely used framework for dynamic binary instrumentation and
its mostly known by its memcheck tool. Valgrind's code generation module is far
from producing optimal code. In addition it has many backends for different CPU
architectures, which difficults code optimization in an architecture
independent way. Our work focused on identifying sub-optimal code produced by
Valgrind and optimizing it.
</summary>
    <author>
      <name>Filipe Cabecinhas</name>
    </author>
    <author>
      <name>Nuno Lopes</name>
    </author>
    <author>
      <name>Renato Crisostomo</name>
    </author>
    <author>
      <name>Luis Veiga</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical report from INESC-ID Lisboa describing optimizations to
  code generation of the Valgring execution environment. Work developed in the
  context of a Virtual Execution Environments course (AVExe) at IST/Technical
  university of Lisbon</arxiv:comment>
    <link href="http://arxiv.org/abs/0810.0372v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0810.0372v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.OS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0810.1151v2</id>
    <updated>2013-04-16T12:11:12Z</updated>
    <published>2008-10-07T13:55:21Z</published>
    <title>Periodic Single-Pass Instruction Sequences</title>
    <summary>  A program is a finite piece of data that produces a (possibly infinite)
sequence of primitive instructions. From scratch we develop a linear notation
for sequential, imperative programs, using a familiar class of primitive
instructions and so-called repeat instructions, a particular type of control
instructions. The resulting mathematical structure is a semigroup. We relate
this set of programs to program algebra (PGA) and show that a particular
subsemigroup is a carrier for PGA by providing axioms for single-pass
congruence, structural congruence, and thread extraction. This subsemigroup
characterizes periodic single-pass instruction sequences and provides a direct
basis for PGA's toolset.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, 3 tables, New title</arxiv:comment>
    <link href="http://arxiv.org/abs/0810.1151v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0810.1151v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0811.0436v2</id>
    <updated>2008-11-18T10:08:03Z</updated>
    <published>2008-11-04T07:24:12Z</published>
    <title>Instruction sequences for the production of processes</title>
    <summary>  Single-pass instruction sequences under execution are considered to produce
behaviours to be controlled by some execution environment. Threads as
considered in thread algebra model such behaviours: upon each action performed
by a thread, a reply from its execution environment determines how the thread
proceeds. Threads in turn can be looked upon as producing processes as
considered in process algebra. We show that, by apposite choice of basic
instructions, all processes that can only be in a finite number of states can
be produced by single-pass instruction sequences.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages; acknowledgement corrected, reference updated</arxiv:comment>
    <link href="http://arxiv.org/abs/0811.0436v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0811.0436v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.1.1; F.1.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0811.0819v1</id>
    <updated>2008-11-05T21:10:33Z</updated>
    <published>2008-11-05T21:10:33Z</published>
    <title>Persistent Queries</title>
    <summary>  We propose a syntax and semantics for interactive abstract state machines to
deal with the following situation. A query is issued during a certain step, but
the step ends before any reply is received. Later, a reply arrives, and later
yet the algorithm makes use of this reply. By a persistent query, we mean a
query for which a late reply might be used. Syntactically, our proposal
involves issuing, along with a persistent query, a location where a late reply
is to be stored. Semantically, it involves only a minor modification of the
existing theory of interactive small-step abstract state machines.
</summary>
    <author>
      <name>Andreas Blass</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Michigan</arxiv:affiliation>
    </author>
    <author>
      <name>Yuri Gurevich</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Microsoft Research</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0811.0819v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0811.0819v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0812.3550v1</id>
    <updated>2008-12-18T15:22:46Z</updated>
    <published>2008-12-18T15:22:46Z</published>
    <title>XML Static Analyzer User Manual</title>
    <summary>  This document describes how to use the XML static analyzer in practice. It
provides informal documentation for using the XML reasoning solver
implementation. The solver allows automated verification of properties that are
expressed as logical formulas over trees. A logical formula may for instance
express structural constraints or navigation properties (like e.g. path
existence and node selection) in finite trees. Logical formulas can be
expressed using the syntax of XPath expressions, DTD, XML Schemas, and Relax NG
definitions.
</summary>
    <author>
      <name>Pierre Geneves</name>
    </author>
    <author>
      <name>Nabil Layaida</name>
    </author>
    <link href="http://arxiv.org/abs/0812.3550v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0812.3550v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0; D.3.1; D.3.4; E.1; F.3.1; F.3.2; F.4.1; F.4.3; H.2.3; I.2.4;&#10;  I.7.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0901.2461v1</id>
    <updated>2009-01-16T11:45:40Z</updated>
    <published>2009-01-16T11:45:40Z</published>
    <title>Grammatic -- a tool for grammar definition reuse and modularity</title>
    <summary>  Grammatic is a tool for grammar definition and manipulation aimed to improve
modularity and reuse of grammars and related development artifacts. It is
independent from parsing technology and any other details of target system
implementation. Grammatic provides a way for annotating grammars with arbitrary
metadata (like associativity attributes, semantic actions or anything else). It
might be used as a front-end for external tools like parser generators to make
their input grammars modular and reusable. This paper describes main principles
behind Grammatic and gives an overview of languages it provides and their
ability to separate concerns and define reusable modules. Also it presents
sketches of possible use cases for the tool.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to DSL'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0901.2461v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0901.2461v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0901.3619v1</id>
    <updated>2009-01-23T08:40:31Z</updated>
    <published>2009-01-23T08:40:31Z</published>
    <title>Mechanized semantics for the Clight subset of the C language</title>
    <summary>  This article presents the formal semantics of a large subset of the C
language called Clight. Clight includes pointer arithmetic, "struct" and
"union" types, C loops and structured "switch" statements. Clight is the source
language of the CompCert verified compiler. The formal semantics of Clight is a
big-step operational semantics that observes both terminating and diverging
executions and produces traces of input/output events. The formal semantics of
Clight is mechanized using the Coq proof assistant. In addition to the
semantics of Clight, this article describes its integration in the CompCert
verified compiler and several ways by which the semantics was validated.
</summary>
    <author>
      <name>Sandrine Blazy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CEDRIC, INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/s10817-009-9148-3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/s10817-009-9148-3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Automated Reasoning (2009)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Automated Reasoning 43, 3 (2009) 263-288</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0901.3619v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0901.3619v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.1257v1</id>
    <updated>2009-02-07T18:00:30Z</updated>
    <published>2009-02-07T18:00:30Z</published>
    <title>Compilation of extended recursion in call-by-value functional languages</title>
    <summary>  This paper formalizes and proves correct a compilation scheme for
mutually-recursive definitions in call-by-value functional languages. This
scheme supports a wider range of recursive definitions than previous methods.
We formalize our technique as a translation scheme to a lambda-calculus
featuring in-place update of memory blocks, and prove the translation to be
correct.
</summary>
    <author>
      <name>Tom Hirschowitz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LM-Savoie</arxiv:affiliation>
    </author>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>J. B. Wells</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/s10990-009-9042-z</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/s10990-009-9042-z" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">62 pages, uses pic</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Higher-Order and Symbolic Computation 22, 1 (2009) 3-66</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0902.1257v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.1257v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.2621v1</id>
    <updated>2009-02-16T07:55:16Z</updated>
    <published>2009-02-16T07:55:16Z</published>
    <title>Creating modular and reusable DSL textual syntax definitions with
  Grammatic/ANTLR</title>
    <summary>  In this paper we present Grammatic -- a tool for textual syntax definition.
Grammatic serves as a front-end for parser generators (and other tools) and
brings modularity and reuse to their development artifacts. It adapts
techniques for separation of concerns from Apsect-Oriented Programming to
grammars and uses templates for grammar reuse. We illustrate usage of Grammatic
by describing a case study: bringing separation of concerns to ANTLR parser
generator, which is achieved without a common time- and memory-consuming
technique of building an AST to separate semantic actions from a grammar
definition.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to PSI'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0902.2621v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.2621v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0902.2859v1</id>
    <updated>2009-02-17T08:41:22Z</updated>
    <published>2009-02-17T08:41:22Z</published>
    <title>Transmission protocols for instruction streams</title>
    <summary>  Threads as considered in thread algebra model behaviours to be controlled by
some execution environment: upon each action performed by a thread, a reply
from its execution environment -- which takes the action as an instruction to
be processed -- determines how the thread proceeds. In this paper, we are
concerned with the case where the execution environment is remote: we describe
and analyse some transmission protocols for passing instructions from a thread
to a remote execution environment.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-03466-4_8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-03466-4_8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">13 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In ICTAC 2009, pages 127--139. Springer-Verlag, LNCS 5684, 2009</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0902.2859v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0902.2859v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.2.4; F.1.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.1352v2</id>
    <updated>2009-11-07T13:19:57Z</updated>
    <published>2009-03-07T17:14:44Z</published>
    <title>An Instruction Sequence Semigroup with Involutive Anti-Automorphisms</title>
    <summary>  We introduce an algebra of instruction sequences by presenting a semigroup C
in which programs can be represented without directional bias: in terms of the
next instruction to be executed, C has both forward and backward instructions
and a C-expression can be interpreted starting from any instruction. We provide
equations for thread extraction, i.e., C's program semantics. Then we consider
thread extraction compatible (anti-)homomorphisms and (anti-)automorphisms.
Finally we discuss some expressiveness results.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">36 pages, 1 table</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Scientific Annals of Computer Science, 19:57-92, 2009</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0903.1352v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.1352v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.RA" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2; I.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.1598v6</id>
    <updated>2009-03-26T17:11:37Z</updated>
    <published>2009-03-09T17:26:36Z</published>
    <title>18th Workshop on Logic-based methods in Programming Environments (WLPE
  2008)</title>
    <summary>  This volume contains the papers presented at WLPE 2008: the 18th Workshop on
Logic-based Methods in Programming Environments held on 12th December, 2008 in
Udine, Italy. It was held as a satellite workshop of ICLP 2008, the 24th
International Conference on Logic Programming.
</summary>
    <author>
      <name>Puri Arenas</name>
    </author>
    <author>
      <name>Damiano Zanardini</name>
    </author>
    <link href="http://arxiv.org/abs/0903.1598v6" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.1598v6" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.6; D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2202v1</id>
    <updated>2009-03-12T15:54:13Z</updated>
    <published>2009-03-12T15:54:13Z</published>
    <title>Improving Size-Change Analysis in Offline Partial Evaluation</title>
    <summary>  Some recent approaches for scalable offline partial evaluation of logic
programs include a size-change analysis for ensuring both so called local and
global termination. In this work|inspired by experimental evaluation|we
introduce several improvements that may increase the accuracy of the analysis
and, thus, the quality of the associated specialized programs. We aim to
achieve this while maintaining the same complexity and scalability of the
recent works.
</summary>
    <author>
      <name>Michael Leuschel</name>
    </author>
    <author>
      <name>Salvador Tamarit</name>
    </author>
    <author>
      <name>German Vidal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 18th Workshop on Logic-based Methods in
  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted
  by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2202v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2202v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2252v1</id>
    <updated>2009-03-12T15:42:24Z</updated>
    <published>2009-03-12T15:42:24Z</published>
    <title>A Semantics-Aware Editing Environment for Prolog in Eclipse</title>
    <summary>  In this paper we present a Prolog plugin for Eclipse based upon BE4, and
providing many features such as semantic-aware syntax highlighting, outline
view, error marking, content assist, hover information, documentation
generation, and quick fixes. The plugin makes use of a Java parser for full
Prolog with an integrated Prolog engine, and can be extended with further
semantic analyses, e.g., based on abstract interpretation.
</summary>
    <author>
      <name>Jens Bendisposto</name>
    </author>
    <author>
      <name>Ian Endrijautzki</name>
    </author>
    <author>
      <name>Michael Leuschel</name>
    </author>
    <author>
      <name>David Schneider</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 18th Workshop on Logic-based Methods in
  Programming Environments (WLPE2008) (Report-No: WLPE/2008). Paper submitted
  by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2252v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2252v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0903.2353v1</id>
    <updated>2009-03-13T10:46:39Z</updated>
    <published>2009-03-13T10:46:39Z</published>
    <title>Relations, Constraints and Abstractions: Using the Tools of Logic
  Programming in the Security Industry</title>
    <summary>  Logic programming is sometimes described as relational programming: a
paradigm in which the programmer specifies and composes n-ary relations using
systems of constraints. An advanced logic programming environment will provide
tools that abstract these relations to transform, optimise, or even verify the
correctness of a logic program. This talk will show that these concepts, namely
relations, constraints and abstractions, turn out to also be important in the
reverse engineer process that underpins the discovery of bugs within the
security industry.
</summary>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented as an invited talk at the 18th Workshop on
  Logic-based Methods in Programming Environments (WLPE2008) (Report-No:
  WLPE/2008). Paper submitted by a co-editor of the Workshop proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/0903.2353v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0903.2353v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.0737v1</id>
    <updated>2009-05-06T04:21:15Z</updated>
    <published>2009-05-06T04:21:15Z</published>
    <title>REC language is a live on IBM1130 simulator, EL lenguaje REC esta vivo
  en el simulador de la IBM 1130</title>
    <summary>  REC (Regular Expression Compiler) is a concise programming language
development in mayor Mexican Universities at end of 60s which allows students
to write programs without knowledge of the complicated syntax of languages like
FORTRAN and ALGOL. The language is recursive and contains only four elements
for control. This paper describes use of the interpreter of REC written in
FORTRAN on IBM1130 Simulator from -Computer History Simulation- Project.
</summary>
    <author>
      <name>Ignacio Vega-Paez</name>
    </author>
    <author>
      <name>Jose Angel Ortega</name>
    </author>
    <author>
      <name>Georgina G. Pulido</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This work is archaeological reconstruction of REC/A language</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.0737v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.0737v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.2257v1</id>
    <updated>2009-05-14T06:23:18Z</updated>
    <published>2009-05-14T06:23:18Z</published>
    <title>A protocol for instruction stream processing</title>
    <summary>  The behaviour produced by an instruction sequence under execution is a
behaviour to be controlled by some execution environment: each step performed
actuates the processing of an instruction by the execution environment and a
reply returned at completion of the processing determines how the behaviour
proceeds. In this paper, we are concerned with the case where the processing
takes place remotely. We describe a protocol to deal with the case where the
behaviour produced by an instruction sequence under execution leads to the
generation of a stream of instructions to be processed and a remote execution
unit handles the processing of that stream of instructions.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.2257v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.2257v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1; D.2.4; F.1.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.3432v1</id>
    <updated>2009-05-21T03:35:52Z</updated>
    <published>2009-05-21T03:35:52Z</published>
    <title>A Type System for Parallel Components</title>
    <summary>  The # component model was proposed to improve the practice of parallel
programming. This paper introduces a type system for # programming systems,
aiming to lift the abstraction and safety of programming for parallel computing
architectures by introducing a notion of abstract component based on universal
and existential bounded quantification. Issues about the implementation of such
type system in HPE, a # programming system, are also discussed.
</summary>
    <author>
      <name>Francisco Heron de Carvalho-Junior</name>
    </author>
    <author>
      <name>Rafael Dueire Lins</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to SBLP 2009 (Brazilian Symposium on Programming Languages)</arxiv:comment>
    <link href="http://arxiv.org/abs/0905.3432v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.3432v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0905.4596v1</id>
    <updated>2009-05-28T10:01:47Z</updated>
    <published>2009-05-28T10:01:47Z</published>
    <title>About raising and handling exceptions</title>
    <summary>  This paper presents a unified framework for dealing with a deduction system
and a denotational semantics of exceptions. It is based on the fact that
handling exceptions can be seen as a kind of generalized case distinction. This
point of view on exceptions has been introduced in 2004, it is based on the
notion of diagrammatic logic, which assumes some familiarity with category
theory. Extensive sums of types can be used for dealing with case distinctions.
The aim of this new paper is to focus on the role of generalized extensivity
property for dealing with exceptions. Moreover, the presentation of this paper
makes only a restricted use of category theory.
</summary>
    <author>
      <name>Dominique Duval</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMC - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Claude Reynaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LSR - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/0905.4596v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0905.4596v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.1777v1</id>
    <updated>2009-06-09T16:30:01Z</updated>
    <published>2009-06-09T16:30:01Z</published>
    <title>Creating Textual Language Dialects Using Aspect-like Techniques</title>
    <summary>  Here we present a work aimed on efficiently creating textual language
dialects and supporting tools for them (e.g. compiler front-ends, IDE support,
pretty-printers, etc.). A dialect is a language which may be described with a
(relatively small) set of changes to some other language (a parent language).
For example we can consider SQL dialects used in DB-management systems.
  We propose to use aspects for grammars to define different features of the
anguage and to transform grammars. A dialect is created by defining a
syntactical spect which modifies the parent language. This technique is not
dependent on any particular language design, AST structure or parsing
technology and provides a uniform way for creating dialects, which extend or
restrict languages.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">extended abstract for GTTSE'09</arxiv:comment>
    <link href="http://arxiv.org/abs/0906.1777v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.1777v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0906.3083v2</id>
    <updated>2014-10-01T14:26:01Z</updated>
    <published>2009-06-17T07:03:17Z</published>
    <title>Instruction sequence notations with probabilistic instructions</title>
    <summary>  This paper concerns instruction sequences that contain probabilistic
instructions, i.e. instructions that are themselves probabilistic by nature. We
propose several kinds of probabilistic instructions, provide an informal
operational meaning for each of them, and discuss related work. On purpose, we
refrain from providing an ad hoc formal meaning for the proposed kinds of
instructions. We also discuss the approach of projection semantics, which was
introduced in earlier work on instruction sequences, in the light of
probabilistic instruction sequences.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, revised because arxiv:1409.6873v1 [cs.LO] has come out</arxiv:comment>
    <link href="http://arxiv.org/abs/0906.3083v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0906.3083v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; F.1.1; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.2173v2</id>
    <updated>2011-06-06T00:35:43Z</updated>
    <published>2009-07-13T14:15:01Z</published>
    <title>Bit Copying - The Ultimate Computational Simplicity</title>
    <summary>  A computational abstract machine based on two operations: referencing and bit
copying is presented. These operations are sufficient for carrying out any
computation. They can be used as the primitives for a Turing-complete
programming language. The interesting point is that the computation can be done
without logic operations such as AND or OR. The compiler and emulator of this
language with sample programs are available on the Internet.
</summary>
    <author>
      <name>Oleg Mazonka</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Complex Systems Journal 2011, Vol 19, N3</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0907.2173v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.2173v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.4477v2</id>
    <updated>2009-09-11T19:57:27Z</updated>
    <published>2009-07-26T13:27:38Z</published>
    <title>Full abstraction for nominal general references</title>
    <summary>  Game semantics has been used with considerable success in formulating fully
abstract semantics for languages with higher-order procedures and a wide range
of computational effects. Recently, nominal games have been proposed for
modelling functional languages with names. These are ordinary, stateful games
cast in the theory of nominal sets developed by Pitts and Gabbay. Here we take
nominal games one step further, by developing a fully abstract semantics for a
language with nominal general references.
</summary>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-5(3:8)2009</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-5(3:8)2009" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 5, Issue 3 (September
  11, 2009) lmcs:918</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0907.4477v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.4477v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.4960v1</id>
    <updated>2009-07-28T19:24:51Z</updated>
    <published>2009-07-28T19:24:51Z</published>
    <title>Ezhil: A Tamil Programming Language</title>
    <summary>  Ezhil is a Tamil language based interpreted procedural programming language.
Tamil keywords and grammar are chosen to make the native Tamil speaker write
programs in the Ezhil system. Ezhil allows easy representation of computer
program closer to the Tamil language logical constructs equivalent to the
conditional, branch and loop statements in modern English based programming
languages. Ezhil is a compact programming language aimed towards Tamil speaking
novice computer users. Grammar for Ezhil and a few example programs are
reported here, from the initial proof-of-concept implementation using the
Python programming language1. To the best of our knowledge, Ezhil language is
the first freely available Tamil programming language.
</summary>
    <author>
      <name>Muthiah Annamalai</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, Tamil UTF-8 characters</arxiv:comment>
    <link href="http://arxiv.org/abs/0907.4960v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.4960v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0907.5290v2</id>
    <updated>2012-03-22T18:58:15Z</updated>
    <published>2009-07-30T09:33:53Z</published>
    <title>Program structure</title>
    <summary>  A program is usually represented as a word chain. It is exactly a word chain
that appears as the lexical analyzer output and is parsed. The work shows that
a program can be syntactically represented as an oriented word tree, that is a
syntactic program tree, program words being located both in tree nodes and on
tree arrows. The basic property of a tree is that arrows starting from each
node are marked by different words (including an empty word). Semantics can
then be directly specified on such tree using either requirements or additional
links, and adding instructions to some tree nodes enables program execution
specification.
</summary>
    <author>
      <name>Alex Shkotin</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">22 pages, 4 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/0907.5290v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0907.5290v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0909.2089v3</id>
    <updated>2012-08-17T15:06:20Z</updated>
    <published>2009-09-11T05:51:09Z</published>
    <title>Indirect jumps improve instruction sequence performance</title>
    <summary>  Instruction sequences with direct and indirect jump instructions are as
expressive as instruction sequences with direct jump instructions only. We show
that, in the case where the number of instructions is not bounded, we are faced
with increases of the maximal internal delays of instruction sequences on
execution that are not bounded by a linear function if we strive for acceptable
increases of the lengths of instruction sequences on elimination of indirect
jump instructions.
</summary>
    <author>
      <name>J. A. Bergstra</name>
    </author>
    <author>
      <name>C. A. Middelburg</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.7561/SACS.2012.2.253</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.7561/SACS.2012.2.253" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, definition of maximal internal delay and theorem 1 are
  stated more precise; presentation improved</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Scientific Annals of Computer Science, 22(2):253--265, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0909.2089v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0909.2089v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.1.1; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0909.2839v1</id>
    <updated>2009-09-15T16:59:57Z</updated>
    <published>2009-09-15T16:59:57Z</published>
    <title>A progression ring for interfaces of instruction sequences, threads, and
  services</title>
    <summary>  We define focus-method interfaces and some connections between such
interfaces and instruction sequences, giving rise to instruction sequence
components. We provide a flexible and practical notation for interfaces using
an abstract datatype specification comparable to that of basic process algebra
with deadlock. The structures thus defined are called progression rings. We
also define thread and service components. Two types of composition of
instruction sequences or threads and services (called `use' and `apply') are
lifted to the level of components.
</summary>
    <author>
      <name>Jan A. Bergstra</name>
    </author>
    <author>
      <name>Alban Ponse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/0909.2839v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0909.2839v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.2; D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.2327v1</id>
    <updated>2009-11-12T08:56:05Z</updated>
    <published>2009-11-12T08:56:05Z</published>
    <title>An Intuitive Automated Modelling Interface for Systems Biology</title>
    <summary>  We introduce a natural language interface for building stochastic pi calculus
models of biological systems. In this language, complex constructs describing
biochemical events are built from basic primitives of association, dissociation
and transformation. This language thus allows us to model biochemical systems
modularly by describing their dynamics in a narrative-style language, while
making amendments, refinements and extensions on the models easy. We
demonstrate the language on a model of Fc-gamma receptor phosphorylation during
phagocytosis. We provide a tool implementation of the translation into a
stochastic pi calculus language, Microsoft Research's SPiM.
</summary>
    <author>
      <name>Ozan Kahramanoğullari</name>
    </author>
    <author>
      <name>Luca Cardelli</name>
    </author>
    <author>
      <name>Emmanuelle Caron</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.9.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.9.9" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 9, 2009, pp. 73-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.2327v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.2327v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="q-bio.QM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.4203v1</id>
    <updated>2009-11-21T21:19:33Z</updated>
    <published>2009-11-21T21:19:33Z</published>
    <title>From Self-Interpreters to Normalization by Evaluation</title>
    <summary>  We characterize normalization by evaluation as the composition of a
self-interpreter with a self-reducer using a special representation scheme, in
the sense of Mogensen (1992). We do so by deriving in a systematic way an
untyped normalization by evaluation algorithm from a standard interpreter for
the ?-calculus. The derived algorithm is not novel and indeed other published
algorithms may be obtained in the same manner through appropriate adaptations
to the representation scheme.
</summary>
    <author>
      <name>Mathieu Boespflug</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIX</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">2009 Workshop on Normalization by Evaluation, Los Angeles :
  \'Etats-Unis d'Am\'erique (2009)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.4203v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.4203v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0911.5449v1</id>
    <updated>2009-11-29T00:35:42Z</updated>
    <published>2009-11-29T00:35:42Z</published>
    <title>Session Types at the Mirror</title>
    <summary>  We (re)define session types as projections of process behaviors with respect
to the communication channels they use. In this setting, we give session types
a semantics based on fair testing. The outcome is a unified theory of
behavioral types that shares common aspects with conversation types and that
encompass features of both dyadic and multi-party session types. The point of
view we provide sheds light on the nature of session types and gives us a
chance to reason about them in a framework where every notion, from
well-typedness to the subtyping relation between session types, is semantically
-rather than syntactically- grounded.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Urbino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.12.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.12.5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 12, 2009, pp. 71-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0911.5449v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0911.5449v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.4877v1</id>
    <updated>2009-12-24T15:27:18Z</updated>
    <published>2009-12-24T15:27:18Z</published>
    <title>Typing rule-based transformations over topological collections</title>
    <summary>  Pattern-matching programming is an example of a rule-based programming style
developed in functional languages. This programming style is intensively used
in dialects of ML but is restricted to algebraic data-types. This restriction
limits the field of application. However, as shown by Giavitto and Michel at
RULE'02, case-based function definitions can be extended to more general data
structures called topological collections. We show in this paper that this
extension retains the benefits of the typed discipline of the functional
languages. More precisely, we show that topological collections and the
rule-based definition of functions associated with them fit in a polytypic
extension of mini-ML where type inference is still possible.
</summary>
    <author>
      <name>Julien Cohen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMI</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/S1571-0661(04)80676-5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/S1571-0661(04)80676-5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">4th International Workshop on Rule-Based Programming, Valencia :
  Spain (2003)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0912.4877v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.4877v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/0912.4878v1</id>
    <updated>2009-12-24T15:27:50Z</updated>
    <published>2009-12-24T15:27:50Z</published>
    <title>Typage fort et typage souple des collections topologiques et des
  transformations</title>
    <summary>  Topological collections allow to consider uniformly many data structures in
programming languages and are handled by functions defined by pattern matching
called transformations. We present two type systems for languages with
topological collections and transformations. The first one is a strong type
system \`a la Hindley/Milner which can be entirely typed at compile time. The
second one is a mixed static and dynamic type system allowing to handle
heterogeneous collections, that is collections which contain values with
different types. In the two cases, automatic type inference is possible.
</summary>
    <author>
      <name>Julien Cohen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMI</arxiv:affiliation>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journ\'ees francophones des langages applicatifs,
  Sainte-Marie-de-R\'e : France (2004)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/0912.4878v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/0912.4878v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4434v1</id>
    <updated>2010-01-25T14:06:29Z</updated>
    <published>2010-01-25T14:06:29Z</published>
    <title>Strategies in PRholog</title>
    <summary>  PRholog is an experimental extension of logic programming with strategic
conditional transformation rules, combining Prolog with Rholog calculus. The
rules perform nondeterministic transformations on hedges. Queries may have
several results that can be explored on backtracking. Strategies provide a
control on rule applications in a declarative way. With strategy combinators,
the user can construct more complex strategies from simpler ones. Matching with
four different kinds of variables provides a flexible mechanism of selecting
(sub)terms during execution. We give an overview on programming with strategies
in PRholog and demonstrate how rewriting strategies can be expressed.
</summary>
    <author>
      <name>Besik Dundua</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RISC, JKU Linz</arxiv:affiliation>
    </author>
    <author>
      <name>Temur Kutsia</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RISC, JKU Linz</arxiv:affiliation>
    </author>
    <author>
      <name>Mircea Marin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Tsukuba</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.15.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.15.3" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 15, 2010, pp. 32-43</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4434v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4434v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4573v1</id>
    <updated>2010-01-26T01:05:09Z</updated>
    <published>2010-01-26T01:05:09Z</published>
    <title>Proceedings Ninth International Workshop on Reduction Strategies in
  Rewriting and Programming</title>
    <summary>  This volume contains selected papers presented at the 9th International
Workshop on Reduction Strategies in Rewriting and Programming, WRS2009, which
was held in Brasilia on the 28th June 2009, associated to RTA 2009 (the 20th
International Conference on Rewriting Techniques and Applications) at RDP, the
Federated Conference on Rewriting, Deduction and Programming. Reduction
strategies define which (sub)expression(s) should be selected for evaluation
and which rule(s) should be applied. These choices affect fundamental
properties of reductions, such as completeness, laziness and efficiency in
general. The WRS workshops promote research and collaboration in the area of
reduction strategies and their applications in specification and programming,
theorem proving, software engineering, etc.
</summary>
    <author>
      <name>Maribel Fernández</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">King's College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.15</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.15" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 15, 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4573v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4573v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1001.4901v1</id>
    <updated>2010-01-27T10:44:26Z</updated>
    <published>2010-01-27T10:44:26Z</published>
    <title>Deriving Ontologies from XML Schema</title>
    <summary>  In this paper, we present a method and a tool for deriving a skeleton of an
ontology from XML schema files. We first recall what an is ontology and its
relationships with XML schemas. Next, we focus on ontology building methodology
and associated tool requirements. Then, we introduce Janus, a tool for building
an ontology from various XML schemas in a given domain. We summarize the main
features of Janus and illustrate its functionalities through a simple example.
Finally, we compare our approach to other existing ontology building tools.
</summary>
    <author>
      <name>Ivan Bedini</name>
    </author>
    <author>
      <name>Georges Gardarin</name>
    </author>
    <author>
      <name>Benjamin Nguyen</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Entrepots de Donnees et Analyse en Ligne (EDA) Conference, Invited
  Paper, 2008</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1001.4901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1001.4901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0936v1</id>
    <updated>2010-02-04T09:43:21Z</updated>
    <published>2010-02-04T09:43:21Z</published>
    <title>Programming Idioms for Transactional Events</title>
    <summary>  Transactional events (TE) are an extension of Concurrent ML (CML), a
programming model for synchronous message-passing. Prior work has focused on
TE's formal semantics and its implementation. This paper considers programming
idioms, particularly those that vary unexpectedly from the corresponding CML
idioms. First, we solve a subtle problem with client-server protocols in TE.
Second, we argue that CML's wrap and guard primitives do not translate well to
TE, and we suggest useful workarounds. Finally, we discuss how to rewrite CML
protocols that use abort actions.
</summary>
    <author>
      <name>Matthew Kehrt</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Laura Effinger-Dean</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Michael Schmitz</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <author>
      <name>Dan Grossman</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Washington</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.4" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 43-48</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0936v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0936v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0937v1</id>
    <updated>2010-02-04T09:46:48Z</updated>
    <published>2010-02-04T09:46:48Z</published>
    <title>Towards the Safe Programming of Wireless Sensor Networks</title>
    <summary>  Sensor networks are rather challenging to deploy, program, and debug. Current
programming languages for these platforms suffer from a significant semantic
gap between their specifications and underlying implementations. This fact
precludes the development of (type-)safe applications, which would potentially
simplify the task of programming and debugging deployed networks. In this paper
we define a core calculus for programming sensor networks and propose to use it
as an assembly language for developing type-safe, high-level programming
languages.
</summary>
    <author>
      <name>Francisco Martins</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Lisbon</arxiv:affiliation>
    </author>
    <author>
      <name>Luís Lopes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto</arxiv:affiliation>
    </author>
    <author>
      <name>João Barros</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.5" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 49-62</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0937v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0937v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.0940v1</id>
    <updated>2010-02-04T09:51:04Z</updated>
    <published>2010-02-04T09:51:04Z</published>
    <title>A Concurrent Language with a Uniform Treatment of Regions and Locks</title>
    <summary>  A challenge for programming language research is to design and implement
multi-threaded low-level languages providing static guarantees for memory
safety and freedom from data races. Towards this goal, we present a concurrent
language employing safe region-based memory management and hierarchical locking
of regions. Both regions and locks are treated uniformly, and the language
supports ownership transfer, early deallocation of regions and early release of
locks in a safe manner.
</summary>
    <author>
      <name>Prodromos Gerakios</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Nikolaos Papaspyrou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Konstantinos Sagonas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.17.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.17.7" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 17, 2010, pp. 79-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1002.0940v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.0940v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1002.1549v1</id>
    <updated>2010-02-08T08:51:06Z</updated>
    <published>2010-02-08T08:51:06Z</published>
    <title>Extensible type checker for parser generation</title>
    <summary>  Parser generators generate translators from language specifications. In many
cases, such specifications contain semantic actions written in the same
language as the generated code. Since these actions are subject to little
static checking, they are usually a source of errors which are discovered only
when generated code is compiled.
  In this paper we propose a parser generator front-end which statically checks
semantic actions for typing errors and prevents such errors from appearing in
generated code. The type checking procedure is extensible to support many
implementation languages. An extension for Java is presented along with an
extension for declarative type system descriptions.
</summary>
    <author>
      <name>Andrey Breslav</name>
    </author>
    <link href="http://arxiv.org/abs/1002.1549v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1002.1549v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.3241v1</id>
    <updated>2010-04-19T16:14:13Z</updated>
    <published>2010-04-19T16:14:13Z</published>
    <title>Causality and the semantics of provenance</title>
    <summary>  Provenance, or information about the sources, derivation, custody or history
of data, has been studied recently in a number of contexts, including
databases, scientific workflows and the Semantic Web. Many provenance
mechanisms have been developed, motivated by informal notions such as
influence, dependence, explanation and causality. However, there has been
little study of whether these mechanisms formally satisfy appropriate policies
or even how to formalize relevant motivating concepts such as causality. We
contend that mathematical models of these concepts are needed to justify and
compare provenance techniques. In this paper we review a theory of causality
based on structural models that has been developed in artificial intelligence,
and describe work in progress on a causal semantics for provenance graphs.
</summary>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Workshop submission</arxiv:comment>
    <link href="http://arxiv.org/abs/1004.3241v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.3241v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1004.4796v2</id>
    <updated>2011-04-13T09:14:23Z</updated>
    <published>2010-04-27T13:31:41Z</published>
    <title>Compiling Signal Processing Code embedded in Haskell via LLVM</title>
    <summary>  We discuss a programming language for real-time audio signal processing that
is embedded in the functional language Haskell and uses the Low-Level Virtual
Machine as back-end. With that framework we can code with the comfort and type
safety of Haskell while achieving maximum efficiency of fast inner loops and
full vectorisation. This way Haskell becomes a valuable alternative to special
purpose signal processing languages.
</summary>
    <author>
      <name>Henning Thielemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages, 1 figure, 3 listings, 1 table, accepted by Linux Audio
  Conference LAC2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1004.4796v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1004.4796v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SD" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.4022v1</id>
    <updated>2010-05-21T17:35:59Z</updated>
    <published>2010-05-21T17:35:59Z</published>
    <title>Molecular Programming Pseudo-code Representation to Molecular
  Electronics</title>
    <summary>  This research paper is proposing the idea of pseudo code representation to
molecular programming used in designing molecular electronics devices. Already
the schematic representation of logical gates like AND, OR, NOT etc.from
molecular diodes or resonant tunneling diode are available. This paper is
setting a generic pseudo code model so that various logic gates can be
formulated. These molecular diodes have designed from organic molecules or
Bio-molecules. Our focus is on to give a scenario of molecular computation
through molecular programming. We have restricted our study to molecular
rectifying diode and logic device as AND gate from organic molecules only.
</summary>
    <author>
      <name>Manas Ranjan Pradhan</name>
    </author>
    <author>
      <name>E. G. Rajan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">http://www.journalofcomputing.org</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Computing, Volume 2, Issue 5, May 2010</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1005.4022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.4022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.4616v1</id>
    <updated>2010-05-25T16:07:06Z</updated>
    <published>2010-05-25T16:07:06Z</published>
    <title>Parametrizing Program Analysis by Lifting to Cardinal Power Domains</title>
    <summary>  A parametric analysis is an analysis whose input and output are parametrized
with a number of parameters which can be instantiated to abstract properties
after analysis is completed. This paper proposes to use Cousot and Cousot's
Cardinal power domain to capture functional dependencies of analysis output on
its input and obtain a parametric analysis by parametrizing a non-parametric
base analysis. We illustrate the method by parametrizing a $\pos$ based
groundness analysis of logic programs to a parametric groundness analysis. In
addition, a prototype implementation shows that generality of the parametric
groundness analysis comes with a negligible extra cost.
</summary>
    <author>
      <name>Lunjin Lu</name>
    </author>
    <link href="http://arxiv.org/abs/1005.4616v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.4616v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1005.5278v2</id>
    <updated>2010-08-18T08:05:55Z</updated>
    <published>2010-05-28T12:33:37Z</published>
    <title>Positive Supercompilation for a Higher-Order Call-By-Value Language</title>
    <summary>  Previous deforestation and supercompilation algorithms may introduce
accidental termination when applied to call-by-value programs. This hides
looping bugs from the programmer, and changes the behavior of a program
depending on whether it is optimized or not. We present a supercompilation
algorithm for a higher-order call-by-value language and prove that the
algorithm both terminates and preserves termination properties. This algorithm
utilizes strictness information to decide whether to substitute or not and
compares favorably with previous call-by-name transformations.
</summary>
    <author>
      <name>Peter A. Jonsson</name>
    </author>
    <author>
      <name>Johan Nordlander</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-6(3:5)2010</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-6(3:5)2010" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 6, Issue 3 (August 18,
  2010) lmcs:1038</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1005.5278v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1005.5278v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.3039v2</id>
    <updated>2010-06-20T19:23:06Z</updated>
    <published>2010-06-15T17:44:15Z</published>
    <title>Concurrent Goal-Based Execution of Constraint Handling Rules</title>
    <summary>  (To appear in Theory and Practice of Logic Programming (TPLP)) We introduce a
systematic, concurrent execution scheme for Constraint Handling Rules (CHR)
based on a previously proposed sequential goal-based CHR semantics. We
establish strong correspondence results to the abstract CHR semantics, thus
guaranteeing that any answer in the concurrent, goal-based CHR semantics is
reproducible in the abstract CHR semantics. Our work provides the foundation to
obtain efficient, parallel CHR execution schemes.
</summary>
    <author>
      <name>Edmund S. L. Lam</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <link href="http://arxiv.org/abs/1006.3039v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.3039v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1006.3159v1</id>
    <updated>2010-06-16T08:39:12Z</updated>
    <published>2010-06-16T08:39:12Z</published>
    <title>Abstract Fixpoint Computations with Numerical Acceleration Methods</title>
    <summary>  Static analysis by abstract interpretation aims at automatically proving
properties of computer programs. To do this, an over-approximation of program
semantics, defined as the least fixpoint of a system of semantic equations,
must be computed. To enforce the convergence of this computation, widening
operator is used but it may lead to coarse results. We propose a new method to
accelerate the computation of this fixpoint by using standard techniques of
numerical analysis. Our goal is to automatically and dynamically adapt the
widening operator in order to maintain precision.
</summary>
    <author>
      <name>Olivier Bouissou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMeASI</arxiv:affiliation>
    </author>
    <author>
      <name>Yassamine Seladji</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMeASI</arxiv:affiliation>
    </author>
    <author>
      <name>Alexandre Chapoutot</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIP6</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.entcs.2010.09.004</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.entcs.2010.09.004" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Electronic Notes in Theoretical Computer Science (2010) 29-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1006.3159v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1006.3159v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.3023v2</id>
    <updated>2011-02-10T17:57:10Z</updated>
    <published>2010-07-18T17:29:53Z</published>
    <title>Purely Functional Structured Programming</title>
    <summary>  The idea of functional programming has played a big role in shaping today's
landscape of mainstream programming languages. Another concept that dominates
the current programming style is Dijkstra's structured programming. Both
concepts have been successfully married, for example in the programming
language Scala. This paper proposes how the same can be achieved for structured
programming and PURELY functional programming via the notion of LINEAR SCOPE.
One advantage of this proposal is that mainstream programmers can reap the
benefits of purely functional programming like easily exploitable parallelism
while using familiar structured programming syntax and without knowing concepts
like monads. A second advantage is that professional purely functional
programmers can often avoid hard to read functional code by using structured
programming syntax that is often easier to parse mentally.
</summary>
    <author>
      <name>Steven Obua</name>
    </author>
    <link href="http://arxiv.org/abs/1007.3023v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.3023v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1007.3183v1</id>
    <updated>2010-07-19T15:28:00Z</updated>
    <published>2010-07-19T15:28:00Z</published>
    <title>A Non-Null Annotation Inferencer for Java Bytecode</title>
    <summary>  We present a non-null annotations inferencer for the Java bytecode language.
We previously proposed an analysis to infer non-null annotations and proved it
soundness and completeness with respect to a state of the art type system. This
paper proposes extensions to our former analysis in order to deal with the Java
bytecode language. We have implemented both analyses and compared their
behaviour on several benchmarks. The results show a substantial improvement in
the precision and, despite being a whole-program analysis, production
applications can be analyzed within minutes.
</summary>
    <author>
      <name>Laurent Hubert</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA - IRISA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/1512475.1512484</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/1512475.1512484" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">PASTE: Program analysis for software tools and engineering,
  Atlanta, Georgia : United States (2008)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1007.3183v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1007.3183v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.0909v1</id>
    <updated>2010-08-05T03:47:48Z</updated>
    <published>2010-08-05T03:47:48Z</published>
    <title>A Heuristic Algorithm for optimizing Page Selection Instructions</title>
    <summary>  Page switching is a technique that increases the memory in microcontrollers
without extending the address buses. This technique is widely used in the
design of 8-bit MCUs. In this paper, we present an algorithm to reduce the
overhead of page switching. To pursue small code size, we place the emphasis on
the allocation of functions into suitable pages with a heuristic algorithm,
thereby the cost-effective placement of page selection instructions. Our
experimental results showed the optimization achieved a reduction in code size
of 13.2 percent.
</summary>
    <author>
      <name>Qing'an Li</name>
    </author>
    <author>
      <name>Yanxiang He</name>
    </author>
    <author>
      <name>Yong Chen</name>
    </author>
    <author>
      <name>Wei Wu</name>
    </author>
    <author>
      <name>Wenwen Xu</name>
    </author>
    <link href="http://arxiv.org/abs/1008.0909v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.0909v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.3431v1</id>
    <updated>2010-08-20T03:17:43Z</updated>
    <published>2010-08-20T03:17:43Z</published>
    <title>Comparative study of the Pros and Cons of Programming languages Java,
  Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP &amp; Scheme - a Team 11
  COMP6411-S10 Term Report</title>
    <summary>  With the advent of numerous languages it is difficult to realize the edge of
one language in a particular scope over another one. We are making an effort,
realizing these few issues and comparing some main stream languages like Java,
Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP and Scheme keeping in
mind some core issues in program development.
</summary>
    <author>
      <name>Venkatreddy Dwarampudi</name>
    </author>
    <author>
      <name>Shahbaz Singh Dhillon</name>
    </author>
    <author>
      <name>Jivitesh Shah</name>
    </author>
    <author>
      <name>Nikhil Joseph Sebastian</name>
    </author>
    <author>
      <name>Nitin Kanigicharla</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">28 pages, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.3431v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.3431v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1008.3561v1</id>
    <updated>2010-08-20T19:50:52Z</updated>
    <published>2010-08-20T19:50:52Z</published>
    <title>Comparative Studies of 10 Programming Languages within 10 Diverse
  Criteria - a Team 10 COMP6411-S10 Term Report</title>
    <summary>  This is a survey on the programming languages: C++, JavaScript, AspectJ, C#,
Haskell, Java, PHP, Scala, Scheme, and BPEL. Our survey work involves a
comparative study of these ten programming languages with respect to the
following criteria: secure programming practices, web application development,
web service composition, OOP-based abstractions, reflection, aspect
orientation, functional programming, declarative programming, batch scripting,
and UI prototyping. We study these languages in the context of the above
mentioned criteria and the level of support they provide for each one of them.
</summary>
    <author>
      <name>Rana Naim</name>
    </author>
    <author>
      <name>Mohammad Fahim Nizam</name>
    </author>
    <author>
      <name>Sheetal Hanamasagar</name>
    </author>
    <author>
      <name>Jalal Noureddine</name>
    </author>
    <author>
      <name>Marinela Miladinova</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">126 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1008.3561v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1008.3561v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.0817v1</id>
    <updated>2010-09-04T09:39:53Z</updated>
    <published>2010-09-04T09:39:53Z</published>
    <title>Towards a Property Preserving Transformation from IEC 61131-3 to BIP</title>
    <summary>  We report on a transformation from Sequential Function Charts of the IEC
61131-3 standard to BIP. Our presentation features a description of formal
syntax and semantics representation of the involved languages and
transformation rules. Furthermore, we present a formalism for describing
invariants of IEC 61131-3 systems and establish a notion of invariant
preservation between the two languages. For a subset of our transformation
rules we sketch a proof showing invariant preservation during the
transformation of IEC 61131-3 to BIP and vice versa.
</summary>
    <author>
      <name>Jan Olaf Blech</name>
    </author>
    <author>
      <name>Anton Hattendorf</name>
    </author>
    <author>
      <name>Jia Huang</name>
    </author>
    <link href="http://arxiv.org/abs/1009.0817v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.0817v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.2900v1</id>
    <updated>2010-09-15T11:43:13Z</updated>
    <published>2010-09-15T11:43:13Z</published>
    <title>Linear-Logic Based Analysis of Constraint Handling Rules with
  Disjunction</title>
    <summary>  Constraint Handling Rules (CHR) is a declarative committed-choice programming
language with a strong relationship to linear logic. Its generalization CHR
with Disjunction (CHRv) is a multi-paradigm declarative programming language
that allows the embedding of horn programs. We analyse the assets and the
limitations of the classical declarative semantics of CHR before we motivate
and develop a linear-logic declarative semantics for CHR and CHRv. We show how
to apply the linear-logic semantics to decide program properties and to prove
operational equivalence of CHRv programs across the boundaries of language
paradigms.
</summary>
    <author>
      <name>Hariolf Betz</name>
    </author>
    <author>
      <name>Thom W. Frühwirth</name>
    </author>
    <link href="http://arxiv.org/abs/1009.2900v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.2900v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.3174v1</id>
    <updated>2010-09-16T13:38:10Z</updated>
    <published>2010-09-16T13:38:10Z</published>
    <title>Evaluating Call-By-Need on the Control Stack</title>
    <summary>  Ariola and Felleisen's call-by-need {\lambda}-calculus replaces a variable
occurrence with its value at the last possible moment. To support this gradual
notion of substitution, function applications-once established-are never
discharged. In this paper we show how to translate this notion of reduction
into an abstract machine that resolves variable references via the control
stack. In particular, the machine uses the static address of a variable
occurrence to extract its current value from the dynamic control stack.
</summary>
    <author>
      <name>Stephen Chang</name>
    </author>
    <author>
      <name>David Van Horn</name>
    </author>
    <author>
      <name>Matthias Felleisen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Symposium on Trends in Functional Programming (TFP 2010), Norman,
  Oklahoma, May 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1009.3174v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.3174v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1009.3773v1</id>
    <updated>2010-09-20T11:09:27Z</updated>
    <published>2010-09-20T11:09:27Z</published>
    <title>Towards a Study of Meta-Predicate Semantics</title>
    <summary>  We describe and compare design choices for meta-predicate semantics, as found
in representative Prolog module systems and in Logtalk. We look at the
consequences of these design choices from a pragmatic perspective, discussing
explicit qualification semantics, computational reflection support,
expressiveness of meta-predicate declarations, safety of meta-predicate
definitions, portability of meta-predicate definitions, and meta-predicate
performance. Our aim is to provide useful insight for debating meta-predicate
semantics and portability issues based on actual implementations and common
usage patterns.
</summary>
    <author>
      <name>Paulo Moura</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online proceedings of the Joint Workshop on Implementation of
  Constraint Logic Programming Systems and Logic-based Methods in Programming
  Environments (CICLOPS-WLPE 2010), Edinburgh, Scotland, U.K., July 15, 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1009.3773v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1009.3773v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.1234v2</id>
    <updated>2012-06-01T01:00:59Z</updated>
    <published>2010-10-06T19:13:38Z</published>
    <title>LR(1) Parser Generation System: LR(1) Error Recovery, Oracles, and
  Generic Tokens</title>
    <summary>  The LR(1) Parser Generation System generates full LR(1) parsers that are
comparable in speed and size to those generated by LALR(1) parser generators,
such as yacc [5]. LR contains a number of novel feature. This paper discusses
three of them in detail: an LR(1) grammar specified automatic error recovery
algorithm, oracles, and generic tokens.
</summary>
    <author>
      <name>Arthur Sorkin</name>
    </author>
    <author>
      <name>Peter Donovan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.1234v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.1234v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.2196v2</id>
    <updated>2010-11-03T22:41:27Z</updated>
    <published>2010-10-11T19:30:25Z</published>
    <title>Optimizing real world applications with GCC Link Time Optimization</title>
    <summary>  GCC has a new infrastructure to support a link time optimization (LTO). The
infrastructure is designed to allow linking of large applications using a
special mode (WHOPR) which support parallelization of the compilation process.
In this paper we present overview of the design and implementation of WHOPR and
present test results of its behavior when optimizing large applications. We
give numbers on compile time, memory usage and code quality comparisons to the
classical file by file based optimization model. In particular we focus on
Firefox web browser. We show main problems seen only when compiling a large
application, such as startup time and code size growth.
</summary>
    <author>
      <name>T. Glek</name>
    </author>
    <author>
      <name>J. Hubicka</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages, published version</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 2010 GCC Developers' Summit</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.2196v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.2196v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5023v1</id>
    <updated>2010-10-24T23:12:28Z</updated>
    <published>2010-10-24T23:12:28Z</published>
    <title>Yacc is dead</title>
    <summary>  We present two novel approaches to parsing context-free languages. The first
approach is based on an extension of Brzozowski's derivative from regular
expressions to context-free grammars. The second approach is based on a
generalization of the derivative to parser combinators. The payoff of these
techniques is a small (less than 250 lines of code), easy-to-implement parsing
library capable of parsing arbitrary context-free grammars into lazy parse
forests. Implementations for both Scala and Haskell are provided. Preliminary
experiments with S-Expressions parsed millions of tokens per second, which
suggests this technique is efficient enough for use in practice.
</summary>
    <author>
      <name>Matthew Might</name>
    </author>
    <author>
      <name>David Darais</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 pages; submitted October 2009 to ESOP; rejected</arxiv:comment>
    <link href="http://arxiv.org/abs/1010.5023v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5023v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5570v1</id>
    <updated>2010-10-27T05:04:32Z</updated>
    <published>2010-10-27T05:04:32Z</published>
    <title>Primitives for Contract-based Synchronization</title>
    <summary>  We investigate how contracts can be used to regulate the interaction between
processes. To do that, we study a variant of the concurrent constraints
calculus presented in [1], featuring primitives for multi-party synchronization
via contracts. We proceed in two directions. First, we exploit our primitives
to model some contract-based interactions. Then, we discuss how several models
for concurrency can be expressed through our primitives. In particular, we
encode the pi-calculus and graph rewriting.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Matematica e Informatica, Università degli Studi di Cagliari</arxiv:affiliation>
    </author>
    <author>
      <name>Roberto Zunino</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Ingegneria e Scienza dell'Informazione, Università degli studi di Trento</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.38.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.38.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2010, arXiv:1010.5308</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 38, 2010, pp. 67-82</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5570v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5570v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1010.5582v1</id>
    <updated>2010-10-27T06:12:50Z</updated>
    <published>2010-10-27T06:12:50Z</published>
    <title>Mechanized semantics</title>
    <summary>  The goal of this lecture is to show how modern theorem provers---in this
case, the Coq proof assistant---can be used to mechanize the specification of
programming languages and their semantics, and to reason over individual
programs and over generic program transformations, as typically found in
compilers. The topics covered include: operational semantics (small-step,
big-step, definitional interpreters); a simple form of denotational semantics;
axiomatic semantics and Hoare logic; generation of verification conditions,
with application to program proof; compilation to virtual machine code and its
proof of correctness; an example of an optimizing program transformation (dead
code elimination) and its proof of correctness.
</summary>
    <author>
      <name>Xavier Leroy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.3233/978-1-60750-100-8-195</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.3233/978-1-60750-100-8-195" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logics and languages for reliability and security, J. Esparza and
  B. Spanfelner and O. Grumberg (Ed.) (2010) 195-224</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1010.5582v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1010.5582v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.5640v1</id>
    <updated>2010-11-25T15:11:42Z</updated>
    <published>2010-11-25T15:11:42Z</published>
    <title>SICStus Prolog -- the first 25 years</title>
    <summary>  SICStus Prolog has evolved for nearly 25 years. This is an appropriate point
in time for revisiting the main language and design decisions, and try to
distill some lessons. SICStus Prolog was conceived in a context of multiple,
conflicting Prolog dialect camps and a fledgling standardization effort. We
reflect on the impact of this effort and role model implementations on our
development. After summarizing the development history, we give a guided tour
of the system anatomy, exposing some designs that were not published before. We
give an overview of our new interactive development environment, and describe a
sample of key applications. Finally, we try to identify key good and not so
good design decisions.
</summary>
    <author>
      <name>Mats Carlsson</name>
    </author>
    <author>
      <name>Per Mildner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.5640v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.5640v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1011.6223v3</id>
    <updated>2011-09-27T14:14:21Z</updated>
    <published>2010-11-29T13:24:11Z</published>
    <title>Just-In-Time compilation of OCaml byte-code</title>
    <summary>  This paper presents various improvements that were applied to OCamlJIT2, a
Just-In-Time compiler for the OCaml byte-code virtual machine. OCamlJIT2
currently runs on various Unix-like systems with x86 or x86-64 processors. The
improvements, including the new x86 port, are described in detail, and
performance measures are given, including a direct comparison of OCamlJIT2 to
OCamlJIT.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 6 figures, 3 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1011.6223v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1011.6223v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.2294v4</id>
    <updated>2011-08-15T09:21:52Z</updated>
    <published>2010-12-10T15:37:06Z</published>
    <title>Syntax and Semantics of Babel-17</title>
    <summary>  We present Babel-17, the first programming language for purely functional
structured programming (PFSP). Earlier work illustrated PFSP in the framework
of a toy research language. Babel-17 takes this earlier work to a new level by
showing how PFSP can be combined with pattern matching, object oriented
programming, and features like concurrency, lazy evaluation, memoization and
support for lenses.
</summary>
    <author>
      <name>Steven Obua</name>
    </author>
    <link href="http://arxiv.org/abs/1012.2294v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.2294v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.4240v1</id>
    <updated>2010-12-20T05:11:57Z</updated>
    <published>2010-12-20T05:11:57Z</published>
    <title>ECLiPSe - from LP to CLP</title>
    <summary>  ECLiPSe is a Prolog-based programming system, aimed at the development and
deployment of constraint programming applications. It is also used for teaching
most aspects of combinatorial problem solving, e.g. problem modelling,
constraint programming, mathematical programming, and search techniques. It
uses an extended Prolog as its high-level modelling and control language,
complemented by several constraint solver libraries, interfaces to third-party
solvers, an integrated development environment and interfaces for embedding
into host environments. This paper discusses language extensions,
implementation aspects, components and tools that we consider relevant on the
way from Logic Programming to Constraint Logic Programming.
</summary>
    <author>
      <name>Joachim Schimpf</name>
    </author>
    <author>
      <name>Kish Shen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <link href="http://arxiv.org/abs/1012.4240v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.4240v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.5494v2</id>
    <updated>2014-04-19T20:28:54Z</updated>
    <published>2010-12-26T03:33:09Z</published>
    <title>Contents of COMP6411 Summer 2010 Final Reports on Comparative Studies of
  Programming Languages</title>
    <summary>  This index covers the lecture notes and the final course project reports for
COMP6411 Summer 2010 at Concordia University, Montreal, Canada, Comparative
Study of Programming Languages by 4 teams trying compare a set of common
criteria and their applicability to about 10 distinct programming languages,
where 5 language choices were provided by the instructor and five were picked
by each team and each student individually compared two of the 10 and then the
team did a summary synthesis across all 10 languages. Their findings are posted
here for further reference, comparative studies, and analysis.
</summary>
    <author>
      <name>Serguei A. Mokhov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">an index</arxiv:comment>
    <link href="http://arxiv.org/abs/1012.5494v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.5494v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1012.6035v2</id>
    <updated>2011-12-03T18:49:44Z</updated>
    <published>2010-12-29T20:49:10Z</published>
    <title>Models of quantum computation and quantum programming languages</title>
    <summary>  The goal of the presented paper is to provide an introduction to the basic
computational models used in quantum information theory. We review various
models of quantum Turing machine, quantum circuits and quantum random access
machine (QRAM) along with their classical counterparts. We also provide an
introduction to quantum programming languages, which are developed using the
QRAM model. We review the syntax of several existing quantum programming
languages and discuss their features and limitations.
</summary>
    <author>
      <name>J. A. Miszczak</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2478/v10175-011-0039-5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2478/v10175-011-0039-5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, 10 figures, 9 listings</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Bull. Pol. Acad. Sci.-Tech. Sci., Vol. 59, No. 3 (2011), pp.
  305-324</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1012.6035v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1012.6035v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.3356v2</id>
    <updated>2011-01-19T14:07:27Z</updated>
    <published>2011-01-17T23:51:59Z</published>
    <title>CAL: A Language for Aggregating Functional and Extrafunctional
  Constraints in Streaming Networks</title>
    <summary>  In this article we present the {\em Constraint Aggregation Language} (CAL), a
declarative language for describing properties of stateless program components
that interact by exchanging messages. CAL allows one to describe functional as
well as extra-functional behaviours, such as computation latency. The CAL
language intention is to be able to describe the behaviour of so-called boxes
in the context of S-Net. However, the language would find application in other
coordination models based on stateless components.
</summary>
    <author>
      <name>Alex Shafarenko</name>
    </author>
    <author>
      <name>Raimund Kirner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1101.3356v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.3356v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4429v1</id>
    <updated>2011-01-24T01:39:52Z</updated>
    <published>2011-01-24T01:39:52Z</published>
    <title>Session Types = Intersection Types + Union Types</title>
    <summary>  We propose a semantically grounded theory of session types which relies on
intersection and union types. We argue that intersection and union types are
natural candidates for modeling branching points in session types and we show
that the resulting theory overcomes some important defects of related
behavioral theories. In particular, intersections and unions provide a native
solution to the problem of computing joins and meets of session types. Also,
the subtyping relation turns out to be a pre-congruence, while this is not
always the case in related behavioral theories.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.45.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.45.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2010, arXiv:1101.4104</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 45, 2011, pp. 71-89</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4429v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4429v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4430v1</id>
    <updated>2011-01-24T01:40:00Z</updated>
    <published>2011-01-24T01:40:00Z</published>
    <title>Equality, Quasi-Implicit Products, and Large Eliminations</title>
    <summary>  This paper presents a type theory with a form of equality reflection:
provable equalities can be used to coerce the type of a term. Coercions and
other annotations, including implicit arguments, are dropped during reduction
of terms. We develop the metatheory for an undecidable version of the system
with unannotated terms. We then devise a decidable system with annotated terms,
justified in terms of the unannotated system. Finally, we show how the approach
can be extended to account for large eliminations, using what we call
quasi-implicit products.
</summary>
    <author>
      <name>Vilhelm Sjöberg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Pennsylvania</arxiv:affiliation>
    </author>
    <author>
      <name>Aaron Stump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Iowa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.45.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.45.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2010, arXiv:1101.4104</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 45, 2011, pp. 90-100</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4430v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4430v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.4732v1</id>
    <updated>2011-01-25T06:57:41Z</updated>
    <published>2011-01-25T06:57:41Z</published>
    <title>Contracts for Abstract Processes in Service Composition</title>
    <summary>  Contracts are a well-established approach for describing and analyzing
behavioral aspects of web service compositions. The theory of contracts comes
equipped with a notion of compatibility between clients and servers that
ensures that every possible interaction between compatible clients and servers
will complete successfully. It is generally agreed that real applications often
require the ability of exposing just partial descriptions of their behaviors,
which are usually known as abstract processes. We propose a formal
characterization of abstraction as an extension of the usual symbolic
bisimulation and we recover the notion of abstraction in the context of
contracts.
</summary>
    <author>
      <name>Maria Grazia Buscemi</name>
    </author>
    <author>
      <name>Hernán Melgratti</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.46.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.46.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FIT 2010, arXiv:1101.4266</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 46, 2011, pp. 9-27</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1101.4732v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.4732v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1101.5569v1</id>
    <updated>2011-01-28T16:42:00Z</updated>
    <published>2011-01-28T16:42:00Z</published>
    <title>T2Script Programming Language</title>
    <summary>  Event-driven programming is used in many fields of modern Computer Science.
In event-driven programming languages user interacts with a program by
triggering the events. We propose a new approach that we denote command-event
driven programming in which the user interacts with a program by means of
events and commands. We describe a new programming language, T2Script, which is
based on command-event driven paradigm. T2Script has been already implemented
and used in one of industrial products. We describe the rationale, basic
concepts and advanced programming techniques of new T2Script language. We
evaluate the new language and show what advantages and limitations it has.
</summary>
    <author>
      <name>Piotr J. Puczynski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">27 pages, 9 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1101.5569v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1101.5569v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.2003v2</id>
    <updated>2011-02-11T17:03:17Z</updated>
    <published>2011-02-09T22:44:26Z</published>
    <title>Parsing Reflective Grammars</title>
    <summary>  Existing technology can parse arbitrary context-free grammars, but only a
single, static grammar per input. In order to support more powerful
syntax-extension systems, we propose reflective grammars, which can modify
their own syntax during parsing. We demonstrate and prove the correctness of an
algorithm for parsing reflective grammars. The algorithm is based on Earley's
algorithm, and we prove that it performs asymptotically no worse than Earley's
algorithm on ordinary context-free grammars.
</summary>
    <author>
      <name>Paul Stansifer</name>
    </author>
    <author>
      <name>Mitchell Wand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A shorter version appears in LDTA 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1102.2003v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.2003v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1102.4971v2</id>
    <updated>2011-06-10T14:32:34Z</updated>
    <published>2011-02-24T12:28:36Z</published>
    <title>Elementary affine $lambda$-calculus with multithreading and side effects</title>
    <summary>  Linear logic provides a framework to control the complexity of higher-order
functional programs. We present an extension of this framework to programs with
multithreading and side effects focusing on the case of elementary time. Our
main contributions are as follows. First, we provide a new combinatorial proof
of termination in elementary time for the functional case. Second, we develop
an extension of the approach to a call-by-value $lambda$-calculus with
multithreading and side effects. Third, we introduce an elementary affine type
system that guarantees the standard subject reduction and progress properties.
Finally, we illustrate the programming of iterative functions with side effects
in the presented formalism.
</summary>
    <author>
      <name>Antoine Madet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <author>
      <name>Roberto M. Amadio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">PPS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1102.4971v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1102.4971v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.0106v1</id>
    <updated>2011-04-30T18:26:49Z</updated>
    <published>2011-04-30T18:26:49Z</published>
    <title>Semantic Solutions to Program Analysis Problems</title>
    <summary>  Problems in program analysis can be solved by developing novel program
semantics and deriving abstractions conventionally. For over thirty years,
higher-order program analysis has been sold as a hard problem. Its solutions
have required ingenuity and complex models of approximation. We claim that this
difficulty is due to premature focus on abstraction and propose a new approach
that emphasizes semantics. Its simplicity enables new analyses that are beyond
the current state of the art.
</summary>
    <author>
      <name>Sam Tobin-Hochstadt</name>
    </author>
    <author>
      <name>David Van Horn</name>
    </author>
    <link href="http://arxiv.org/abs/1105.0106v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.0106v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.0966v1</id>
    <updated>2011-05-05T01:29:17Z</updated>
    <published>2011-05-05T01:29:17Z</published>
    <title>A resource analysis of the pi-calculus</title>
    <summary>  We give a new treatment of the pi-calculus based on the semantic theory of
separation logic, continuing a research program begun by Hoare and O'Hearn.
Using a novel resource model that distinguishes between public and private
ownership, we refactor the operational semantics so that sending, receiving,
and allocating are commands that influence owned resources. These ideas lead
naturally to two denotational models: one for safety and one for liveness. Both
models are fully abstract for the corresponding observables, but more
importantly both are very simple. The close connections with the model theory
of separation logic (in particular, with Brookes's action trace model) give
rise to a logic of processes and resources.
</summary>
    <author>
      <name>Aaron Turon</name>
    </author>
    <author>
      <name>Mitchell Wand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Preliminary version for MFPS 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1105.0966v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.0966v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q55" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1105.1985v3</id>
    <updated>2011-05-15T11:24:39Z</updated>
    <published>2011-05-10T15:59:09Z</published>
    <title>A Step-indexed Semantic Model of Types for the Call-by-Name Lambda
  Calculus</title>
    <summary>  Step-indexed semantic models of types were proposed as an alternative to
purely syntactic safety proofs using subject-reduction. Building upon the work
by Appel and others, we introduce a generalized step-indexed model for the
call-by-name lambda calculus. We also show how to prove type safety of general
recursion in our call-by-name model.
</summary>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, 6 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1105.1985v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1105.1985v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.2578v1</id>
    <updated>2011-06-14T00:06:58Z</updated>
    <published>2011-06-14T00:06:58Z</published>
    <title>Extensible Pattern Matching in an Extensible Language</title>
    <summary>  Pattern matching is a widely used technique in functional languages,
especially those in the ML and Haskell traditions, where it is at the core of
the semantics. In languages in the Lisp tradition, in contrast, pattern
matching it typically provided by libraries built with macros. We present
match, a sophisticated pattern matcher for Racket, implemented as language
extension. using macros. The system supports novel and widely-useful
pattern-matching forms, and is itself extensible. The extensibility of match is
implemented via a general technique for creating extensible language
extensions.
</summary>
    <author>
      <name>Sam Tobin-Hochstadt</name>
    </author>
    <link href="http://arxiv.org/abs/1106.2578v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.2578v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.2637v1</id>
    <updated>2011-06-14T08:34:11Z</updated>
    <published>2011-06-14T08:34:11Z</published>
    <title>Using Bounded Model Checking to Focus Fixpoint Iterations</title>
    <summary>  Two classical sources of imprecision in static analysis by abstract
interpretation are widening and merge operations. Merge operations can be done
away by distinguishing paths, as in trace partitioning, at the expense of
enumerating an exponential number of paths. In this article, we describe how to
avoid such systematic exploration by focusing on a single path at a time,
designated by SMT-solving. Our method combines well with acceleration
techniques, thus doing away with widenings as well in some cases. We illustrate
it over the well-known domain of convex polyhedra.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Laure Gonnord</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIFL</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1106.2637v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.2637v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1106.3457v1</id>
    <updated>2011-06-17T12:01:01Z</updated>
    <published>2011-06-17T12:01:01Z</published>
    <title>Extensional Higher-Order Logic Programming</title>
    <summary>  We propose a purely extensional semantics for higher-order logic programming.
In this semantics program predicates denote sets of ordered tuples, and two
predicates are equal iff they are equal as sets. Moreover, every program has a
unique minimum Herbrand model which is the greatest lower bound of all Herbrand
models of the program and the least fixed-point of an immediate consequence
operator. We also propose an SLD-resolution proof procedure which is proven
sound and complete with respect to the minimum model semantics. In other words,
we provide a purely extensional theoretical framework for higher-order logic
programming which generalizes the familiar theory of classical (first-order)
logic programming.
</summary>
    <author>
      <name>A. Charalambidis</name>
    </author>
    <author>
      <name>K. Handjopoulos</name>
    </author>
    <author>
      <name>P. Rondogiannis</name>
    </author>
    <author>
      <name>W. W. Wadge</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">45 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1106.3457v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1106.3457v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0190v1</id>
    <updated>2011-07-31T18:01:14Z</updated>
    <published>2011-07-31T18:01:14Z</published>
    <title>On the Correctness of Pull-Tabbing</title>
    <summary>  Pull-tabbing is an evaluation approach for functional logic computations,
based on a graph transformation recently proposed, which avoids making
irrevocable non-deterministic choices that would jeopardize the completeness of
computations. In contrast to other approaches with this property, it does not
require an upfront cloning of a possibly large portion of the choice's context.
We formally define the pull-tab transformation, characterize the class of
programs for which the transformation is intended, extend the computations in
these programs to include the transformation, and prove the correctness of the
extended computations.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068411000263</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068411000263" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, vol. 11, no. 4-5, pp.
  713-730, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0190v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0190v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0329v1</id>
    <updated>2011-08-01T14:56:56Z</updated>
    <published>2011-08-01T14:56:56Z</published>
    <title>Observational equivalences for linear logic CC languages</title>
    <summary>  Linear logic Concurrent Constraint programming (LCC) is an extension of
concurrent constraint programming (CC) where the constraint system is based on
Girard's linear logic instead of the classical logic. In this paper we address
the problem of program equivalence for this programming framework. For this
purpose, we present a structural operational semantics for LCC based on a label
transition system and investigate different notions of observational
equivalences inspired by the state of art of process algebras. Then, we
demonstrate that the asynchronous \pi-calculus can be viewed as simple
syntactical restrictions of LCC. Finally we show LCC observational equivalences
can be transposed straightforwardly to classical Concurrent Constraint
languages and Constraint Handling Rules, and investigate the resulting
equivalences.
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068411000123</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068411000123" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 11(4-5): 469-485, 2011</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0329v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0329v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0464v1</id>
    <updated>2011-08-02T02:27:04Z</updated>
    <published>2011-08-02T02:27:04Z</published>
    <title>Interaction and observation, categorically</title>
    <summary>  This paper proposes to use dialgebras to specify the semantics of interactive
systems in a natural way. Dialgebras are a conservative extension of
coalgebras. In this categorical model, from the point of view that we provide,
the notions of observation and interaction are separate features. This is
useful, for example, in the specification of process equivalences, which are
obtained as kernels of the homomorphisms of dialgebras. As an example we
present the asynchronous semantics of the CCS.
</summary>
    <author>
      <name>Vincenzo Ciancia</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.59.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.59.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2011, arXiv:1108.0144</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 59, 2011, pp. 25-36</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0464v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0464v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.0466v1</id>
    <updated>2011-08-02T02:27:18Z</updated>
    <published>2011-08-02T02:27:18Z</published>
    <title>Polymorphic Endpoint Types for Copyless Message Passing</title>
    <summary>  We present PolySing#, a calculus that models process interaction based on
copyless message passing, in the style of Singularity OS. We equip the calculus
with a type system that accommodates polymorphic endpoint types, which are a
variant of polymorphic session types, and we show that well-typed processes are
free from faults, leaks, and communication errors. The type system is
essentially linear, although linearity alone may leave room for scenarios where
well-typed processes leak memory. We identify a condition on endpoint types
that prevents these leaks from occurring.
</summary>
    <author>
      <name>Viviana Bono</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Torino, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.59.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.59.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2011, arXiv:1108.0144</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 59, 2011, pp. 52-67</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.0466v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.0466v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.2360v1</id>
    <updated>2011-08-11T09:28:01Z</updated>
    <published>2011-08-11T09:28:01Z</published>
    <title>A type checking algorithm for qualified session types</title>
    <summary>  We present a type checking algorithm for establishing a session-based
discipline in the pi calculus of Milner, Parrow and Walker. Our session types
are qualified as linear or unrestricted. Linearly typed communication channels
are guaranteed to occur in exactly one thread, possibly multiple times;
afterwards they evolve as unrestricted channels. Session protocols are
described by a type constructor that denotes the two ends of one and the same
communication channel. We ensure the soundness of the algorithm by showing that
processes consuming all linear resources are accepted by a type system
preserving typings during the computation and that type checking is consistent
w.r.t. structural congruence.
</summary>
    <author>
      <name>Marco Giunti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA and LIX, Ecole Polytechnique, France</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.61.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.61.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2011, arXiv:1108.2085</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 61, 2011, pp. 96-114</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1108.2360v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.2360v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1108.4547v1</id>
    <updated>2011-08-23T10:44:28Z</updated>
    <published>2011-08-23T10:44:28Z</published>
    <title>Language Support for Declarative Future Commitments</title>
    <summary>  Sequential programming and work-flow programming are two useful, but
radically different, ways of describing computational processing. Of the two,
it is sequential programming that we teach all programmers and support by
programming languages, whether in procedural, objectoriented, or functional
paradigms. We teach workflow as a secondary style of problem decomposition for
use in special situations, like distributed or networked processing. Both
styles offer complementary advantages, but the fact that they employ radically
different models for ownership of continuations interferes with our ability to
integrate them in a way that allows them to be taught and used in a single
programming language. This paper describes a programming language construct,
declarative future commitments, that permit better integration of the two.
</summary>
    <author>
      <name>William Harrison</name>
    </author>
    <link href="http://arxiv.org/abs/1108.4547v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1108.4547v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0781v1</id>
    <updated>2011-09-05T01:56:53Z</updated>
    <published>2011-09-05T01:56:53Z</published>
    <title>Tutorial on Online Partial Evaluation</title>
    <summary>  This paper is a short tutorial introduction to online partial evaluation. We
show how to write a simple online partial evaluator for a simple, pure,
first-order, functional programming language. In particular, we show that the
partial evaluator can be derived as a variation on a compositionally defined
interpreter. We demonstrate the use of the resulting partial evaluator for
program optimization in the context of model-driven development.
</summary>
    <author>
      <name>William R. Cook</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Texas at Austin</arxiv:affiliation>
    </author>
    <author>
      <name>Ralf Lämmel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Koblenz-Landau</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DSL 2011, arXiv:1109.0323</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011, pp. 168-180</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0781v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0781v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.0786v1</id>
    <updated>2011-09-05T01:57:27Z</updated>
    <published>2011-09-05T01:57:27Z</published>
    <title>Accurate Programming: Thinking about programs in terms of properties</title>
    <summary>  Accurate programming is a practical approach to producing high quality
programs. It combines ideas from test-automation, test-driven development,
agile programming, and other state of the art software development methods. In
addition to building on approaches that have proven effective in practice, it
emphasizes concepts that help programmers sharpen their understanding of both
the problems they are solving and the solutions they come up with. This is
achieved by encouraging programmers to think about programs in terms of
properties.
</summary>
    <author>
      <name>Walid Taha</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Halmstad University</arxiv:affiliation>
    </author>
    <author>
      <name>Veronica Gaspes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Halmstad University</arxiv:affiliation>
    </author>
    <author>
      <name>Rex Page</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oklahoma</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.66.13</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.66.13" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DSL 2011, arXiv:1109.0323</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 66, 2011, pp. 236-260</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1109.0786v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.0786v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.1421v1</id>
    <updated>2011-09-07T11:20:46Z</updated>
    <published>2011-09-07T11:20:46Z</published>
    <title>Profiling parallel Mercury programs with ThreadScope</title>
    <summary>  The behavior of parallel programs is even harder to understand than the
behavior of sequential programs. Parallel programs may suffer from any of the
performance problems affecting sequential programs, as well as from several
problems unique to parallel systems. Many of these problems are quite hard (or
even practically impossible) to diagnose without help from specialized tools.
We present a proposal for a tool for profiling the parallel execution of
Mercury programs, a proposal whose implementation we have already started. This
tool is an adaptation and extension of the ThreadScope profiler that was first
built to help programmers visualize the execution of parallel Haskell programs.
</summary>
    <author>
      <name>Paul Bone</name>
    </author>
    <author>
      <name>Zoltan Somogyi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21st Workshop on Logic-based methods in Programming Environments.
  Lexington, Kentucky, July 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.1421v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.1421v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.1905v1</id>
    <updated>2011-09-09T06:38:06Z</updated>
    <published>2011-09-09T06:38:06Z</published>
    <title>Modular Abstractions of Reactive Nodes using Disjunctive Invariants</title>
    <summary>  We wish to abstract nodes in a reactive programming language, such as Lustre,
into nodes with a simpler control structure, with a bound on the number of
control states. In order to do so, we compute disjunctive invariants in
predicate abstraction, with a bounded number of disjuncts, then we abstract the
node, each disjunct representing an abstract state. The computation of the
disjunctive invariant is performed by a form of quantifier elimination
expressed using SMT-solving. The same method can also be used to obtain
disjunctive loop invariants.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Martin Bodin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG, DI</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1109.1905v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.1905v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.2405v1</id>
    <updated>2011-09-12T08:48:00Z</updated>
    <published>2011-09-12T08:48:00Z</published>
    <title>Stratified Static Analysis Based on Variable Dependencies</title>
    <summary>  In static analysis by abstract interpretation, one often uses widening
operators in order to enforce convergence within finite time to an inductive
invariant. Certain widening operators, including the classical one over finite
polyhedra, exhibit an unintuitive behavior: analyzing the program over a subset
of its variables may lead a more precise result than analyzing the original
program! In this article, we present simple workarounds for such behavior.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Julien Le Guen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG, ST Microelectronics</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1109.2405v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.2405v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1109.2548v1</id>
    <updated>2011-09-12T17:49:01Z</updated>
    <published>2011-09-12T17:49:01Z</published>
    <title>RedAlert: Determinacy Inference for Prolog</title>
    <summary>  This paper revisits the problem of determinacy inference addressing the
problem of how to uniformly handle cut. To this end a new semantics is
introduced for cut, which is abstracted to systematically derive a backward
analysis that derives conditions sufficient for a goal to succeed at most once.
The method is conceptionally simpler and easier to implement than existing
techniques, whilst improving the latter's handling of cut. Formal arguments
substantiate correctness and experimental work, and a tool called 'RedAlert'
demonstrates the method's generality and applicability.
</summary>
    <author>
      <name>Jael Kriener</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 2011, 27th Int'l.
  Conference on Logic Programming (ICLP'11) Special Issue, volume 11, issue 4-5</arxiv:comment>
    <link href="http://arxiv.org/abs/1109.2548v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1109.2548v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.1029v2</id>
    <updated>2011-10-27T16:09:44Z</updated>
    <published>2011-10-05T16:05:41Z</published>
    <title>Towards a native toplevel for the OCaml language</title>
    <summary>  This paper presents the current state of our work on an interactive toplevel
for the OCaml language based on the optimizing native code compiler and
runtime. Our native toplevel is up to 100 times faster than the default OCaml
toplevel, which is based on the byte code compiler and interpreter. It uses
Just-In-Time techniques to compile toplevel phrases to native code at runtime,
and currently works with various Unix-like systems running on x86 or x86-64
processors.
</summary>
    <author>
      <name>Marcell Fischbach</name>
    </author>
    <author>
      <name>Benedikt Meurer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 5 figures, technical report</arxiv:comment>
    <link href="http://arxiv.org/abs/1110.1029v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.1029v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1110.4160v1</id>
    <updated>2011-10-19T02:29:14Z</updated>
    <published>2011-10-19T02:29:14Z</published>
    <title>A Type System for Unstructured Locking that Guarantees Deadlock Freedom
  without Imposing a Lock Ordering</title>
    <summary>  Deadlocks occur in concurrent programs as a consequence of cyclic resource
acquisition between threads. In this paper we present a novel type system that
guarantees deadlock freedom for a language with references, unstructured
locking primitives, and locks which are implicitly associated with references.
The proposed type system does not impose a strict lock acquisition order and
thus increases programming language expressiveness.
</summary>
    <author>
      <name>Prodromos Gerakios</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Nikolaos Papaspyrou</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <author>
      <name>Konstantinos Sagonas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">National Technical University of Athens</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.69.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.69.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2010, arXiv:1110.3853</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 69, 2011, pp. 44-58</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1110.4160v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1110.4160v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; D.3.2; D.1.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.3606v3</id>
    <updated>2015-02-12T13:12:12Z</updated>
    <published>2011-11-15T18:32:29Z</published>
    <title>tym: Typed Matlab</title>
    <summary>  Although, many scientists and engineers use Octave or MATLAB as their
preferred programming language, dynamic nature of these languages can lead to
slower running-time of programs written in these languages compared to programs
written in languages which are not as dynamic, like C, C++ and Fortran. In this
work we developed a translator for a new programming language (tym) which tries
to address performance issues, common in scientific programs, by adding new
constructs to a subset of Octave/MATLAB language. Our translator compiles
programs written in tym, to efficient C++ code.
</summary>
    <author>
      <name>Hamid A. Toussi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at University of Sistan and Baluchestan, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1111.3606v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.3606v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4737v1</id>
    <updated>2011-11-21T05:24:23Z</updated>
    <published>2011-11-21T05:24:23Z</published>
    <title>Compiler Optimization: A Case for the Transformation Tool Contest</title>
    <summary>  An optimizing compiler consists of a front end parsing a textual programming
language into an intermediate representation (IR), a middle end performing
optimizations on the IR, and a back end lowering the IR to a target
representation (TR) built of operations supported by the target hardware. In
modern compiler construction graph-based IRs are employed. Optimization and
lowering tasks can then be implemented with graph transformation rules. This
case provides two compiler tasks to evaluate the participating tools regarding
performance.
</summary>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 6-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4737v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4737v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4751v1</id>
    <updated>2011-11-21T05:26:14Z</updated>
    <published>2011-11-21T05:26:14Z</published>
    <title>Solving the TTC 2011 Reengineering Case with GrGen.NET</title>
    <summary>  The challenge of the Reengineering Case is to extract a state machine model
out of the abstract syntax graph of a Java program. The extracted state machine
offers a reduced view on the full program graph and thus helps to understand
the program regarding the question of interest. We tackle this task employing
the general purpose graph rewrite system GrGen.NET (www.grgen.net).
</summary>
    <author>
      <name>Edgar Jakumeit</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Sebastian Buchwald</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Karlsruhe Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.16</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.16" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 168-180</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4751v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4751v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1111.4755v1</id>
    <updated>2011-11-21T05:26:57Z</updated>
    <published>2011-11-21T05:26:57Z</published>
    <title>Saying Hello World with MOLA - A Solution to the TTC 2011 Instructive
  Case</title>
    <summary>  This paper describes the solution of Hello World transformations in MOLA
transformation language. Transformations implementing the task are relatively
straightforward and easily inferable from the task specification. The required
additional steps related to model import and export are also described.
</summary>
    <author>
      <name>Elina Kalnina</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Audris Kalnins</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Agris Sostaks</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Janis Iraids</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <author>
      <name>Edgars Celms</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institute of Mathematics and Computer Science, University of Latvia</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.74.21</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.74.21" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2011, arXiv:1111.4407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 74, 2011, pp. 237-252</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1111.4755v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1111.4755v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.2396v3</id>
    <updated>2012-09-07T01:22:05Z</updated>
    <published>2011-12-11T20:29:40Z</published>
    <title>Decorated proofs for computational effects: States</title>
    <summary>  The syntax of an imperative language does not mention explicitly the state,
while its denotational semantics has to mention it. In this paper we show that
the equational proofs about an imperative language may hide the state, in the
same way as the syntax does.
</summary>
    <author>
      <name>Jean-Guillaume Dumas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Dominique Duval</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Laurent Fousse</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <author>
      <name>Jean-Claude Reynaud</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LJK, Université de Grenoble, France</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.93.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.93.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ACCAT 2012, arXiv:1208.4301</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 93, 2012, pp. 45-59</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1112.2396v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.2396v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3785v1</id>
    <updated>2011-12-16T12:25:28Z</updated>
    <published>2011-12-16T12:25:28Z</published>
    <title>Nesting Probabilistic Inference</title>
    <summary>  When doing inference in ProbLog, a probabilistic extension of Prolog, we
extend SLD resolution with some additional bookkeeping. This additional
information is used to compute the probabilistic results for a probabilistic
query. In Prolog's SLD, goals are nested very naturally. In ProbLog's SLD,
nesting probabilistic queries interferes with the probabilistic bookkeeping. In
order to support nested probabilistic inference we propose the notion of a
parametrised ProbLog engine. Nesting becomes possible by suspending and
resuming instances of ProbLog engines. With our approach we realise several
extensions of ProbLog such as meta-calls, negation, and answers of
probabilistic goals.
</summary>
    <author>
      <name>Theofrastos Mantadelis</name>
    </author>
    <author>
      <name>Gerda Janssens</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3785v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3785v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3786v2</id>
    <updated>2011-12-23T08:49:22Z</updated>
    <published>2011-12-16T12:25:42Z</published>
    <title>High-Level Multi-Threading in hProlog</title>
    <summary>  A new high-level interface to multi-threading in Prolog, implemented in
hProlog, is described. Modern CPUs often contain multiple cores and through
high-level multi-threading a programmer can leverage this power without having
to worry about low-level details. Two common types of high-level explicit
parallelism are discussed: independent and-parallelism and competitive
or-parallelism. A new type of explicit parallelism, pipeline parallelism, is
proposed. This new type can be used in certain cases where independent
and-parallelism and competitive or-parallelism cannot be used.
</summary>
    <author>
      <name>Timon Van Overveldt</name>
    </author>
    <author>
      <name>Bart Demoen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3786v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3786v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3787v1</id>
    <updated>2011-12-16T12:26:59Z</updated>
    <published>2011-12-16T12:26:59Z</published>
    <title>Approximating Constraint Propagation in Datalog</title>
    <summary>  We present a technique exploiting Datalog with aggregates to improve the
performance of programs with arithmetic (in)equalities. Our approach employs a
source-to-source program transformation which approximates the propagation
technique from Constraint Programming. The experimental evaluation of the
approach shows good run time speed-ups on a range of non-recursive as well as
recursive programs. Furthermore, our technique improves upon the previously
reported in the literature constraint magic set transformation approach.
</summary>
    <author>
      <name>Dario Campagna</name>
    </author>
    <author>
      <name>Beata Sarna-Starosta</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3787v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3787v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3789v1</id>
    <updated>2011-12-16T12:27:19Z</updated>
    <published>2011-12-16T12:27:19Z</published>
    <title>An Implementation of Bubbling</title>
    <summary>  Non-determinism is of great importance in functional logic programming. It
provides expressiveness and efficiency to functional logic computations. In
this paper we describe an implementation of the multi-paradigm functional logic
language Curry. The evaluation strategy employed by the implementation is based
on definitional trees and needed narrowing for deterministic operations, while
non-deterministic operations will depend on the graph transformation, bubbling.
Bubbling preserves the completeness of non-deterministic operations and avoids
unnecessary large-scale reconstruction of expressions done by other approaches.
</summary>
    <author>
      <name>Abdulla Alqaddoumi</name>
    </author>
    <author>
      <name>Enrico Pontelli</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Online Proceedings of the 11th International Colloquium on
  Implementation of Constraint LOgic Programming Systems (CICLOPS 2011),
  Lexington, KY, U.S.A., July 10, 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.3789v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3789v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.3833v1</id>
    <updated>2011-12-16T14:48:42Z</updated>
    <published>2011-12-16T14:48:42Z</published>
    <title>Dependently Typed Programming based on Automated Theorem Proving</title>
    <summary>  Mella is a minimalistic dependently typed programming language and
interactive theorem prover implemented in Haskell. Its main purpose is to
investigate the effective integration of automated theorem provers in a pure
and simple setting. Such integrations are essential for supporting program
development in dependently typed languages. We integrate the equational theorem
prover Waldmeister and test it on more than 800 proof goals from the TPTP
library. In contrast to previous approaches, the reconstruction of Waldmeister
proofs within Mella is quite robust and does not generate a significant
overhead to proof search. Mella thus yields a template for integrating more
expressive theorem provers in more sophisticated languages.
</summary>
    <author>
      <name>Alasdair Armstrong</name>
    </author>
    <author>
      <name>Simon Foster</name>
    </author>
    <author>
      <name>Georg Struth</name>
    </author>
    <link href="http://arxiv.org/abs/1112.3833v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.3833v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.4106v3</id>
    <updated>2012-08-01T04:56:07Z</updated>
    <published>2011-12-18T01:42:11Z</published>
    <title>Dependent Types for JavaScript</title>
    <summary>  We present Dependent JavaScript (DJS), a statically-typed dialect of the
imperative, object-oriented, dynamic language. DJS supports the particularly
challenging features such as run-time type-tests, higher-order functions,
extensible objects, prototype inheritance, and arrays through a combination of
nested refinement types, strong updates to the heap, and heap unrolling to
precisely track prototype hierarchies. With our implementation of DJS, we
demonstrate that the type system is expressive enough to reason about a variety
of tricky idioms found in small examples drawn from several sources, including
the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.
</summary>
    <author>
      <name>Ravi Chugh</name>
    </author>
    <author>
      <name>David Herman</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <link href="http://arxiv.org/abs/1112.4106v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.4106v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1112.6096v1</id>
    <updated>2011-12-28T10:49:18Z</updated>
    <published>2011-12-28T10:49:18Z</published>
    <title>Solving XCSP problems by using Gecode</title>
    <summary>  Gecode is one of the most efficient libraries that can be used for constraint
solving. However, using it requires dealing with C++ programming details. On
the other hand several formats for representing constraint networks have been
proposed. Among them, XCSP has been proposed as a format based on XML which
allows us to represent constraints defined either extensionally or
intensionally, permits global constraints and has been the standard format of
the international competition of constraint satisfaction problems solvers. In
this paper we present a plug-in for solving problems specified in XCSP by
exploiting the Gecode solver. This is done by dynamically translating
constraints into Gecode library calls, thus avoiding the need to interact with
C++.
</summary>
    <author>
      <name>Massimo Morara</name>
    </author>
    <author>
      <name>Jacopo Mauro</name>
    </author>
    <author>
      <name>Maurizio Gabbrielli</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages, http://ceur-ws.org/Vol-810 CILC 2011</arxiv:comment>
    <link href="http://arxiv.org/abs/1112.6096v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1112.6096v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.0874v1</id>
    <updated>2012-01-04T11:22:08Z</updated>
    <published>2012-01-04T11:22:08Z</published>
    <title>Applicative Bisimulations for Delimited-Control Operators</title>
    <summary>  We develop a behavioral theory for the untyped call-by-value lambda calculus
extended with the delimited-control operators shift and reset. For this
calculus, we discuss the possible observable behaviors and we define an
applicative bisimilarity that characterizes contextual equivalence. We then
compare the applicative bisimilarity and the CPS equivalence, a relation on
terms often used in studies of control operators. In the process, we illustrate
how bisimilarity can be used to prove equivalence of terms with
delimited-control effects.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Serguei Lenglet</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A long version of an article accepted at FoSSaCS 2012</arxiv:comment>
    <link href="http://arxiv.org/abs/1201.0874v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.0874v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.2312v1</id>
    <updated>2012-01-10T08:24:07Z</updated>
    <published>2012-01-10T08:24:07Z</published>
    <title>Actor Garbage Collection in Distributed Systems using Graph
  Transformation</title>
    <summary>  A lot of research work has been done in the area of Garbage collection for
both uniprocessor and distributed systems. Actors are associated with activity
(thread) and hence usual garbage collection algorithms cannot be applied for
them. Hence a separate algorithm should be used to collect them. If we
transform the active reference graph into a graph which captures all the
features of actors and looks like passive reference graph then any passive
reference graph algorithm can be applied for it. But the cost of transformation
and optimization are the core issues. An attempt has been made to walk through
these issues.
</summary>
    <author>
      <name>B. Seetha Lakshmi</name>
    </author>
    <author>
      <name>C. D. Balapriya</name>
    </author>
    <author>
      <name>R. Soniya</name>
    </author>
    <link href="http://arxiv.org/abs/1201.2312v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.2312v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.4262v1</id>
    <updated>2012-01-20T11:11:37Z</updated>
    <published>2012-01-20T11:11:37Z</published>
    <title>Secondary use of data in EHR systems</title>
    <summary>  We show how to use aspect-oriented programming to separate security and trust
issues from the logical design of mobile, distributed systems. The main
challenge is how to enforce various types of security policies, in particular
predictive access control policies - policies based on the future behavior of a
program. A novel feature of our approach is that advice is able to analyze the
future use of data. We consider a number of different security policies,
concerning both primary and secondary use of data, some of which can only be
enforced by analysis of process continuations.
</summary>
    <author>
      <name>Fan Yang</name>
    </author>
    <author>
      <name>Chris Hankin</name>
    </author>
    <author>
      <name>Flemming Nielson</name>
    </author>
    <author>
      <name>Hanne Riis Nielson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">40 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1201.4262v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.4262v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.4719v1</id>
    <updated>2012-01-23T14:06:32Z</updated>
    <published>2012-01-23T14:06:32Z</published>
    <title>On Synergy of Metal, Slicing, and Symbolic Execution</title>
    <summary>  We introduce a novel technique for finding real errors in programs. The
technique is based on a synergy of three well-known methods: metacompilation,
slicing, and symbolic execution. More precisely, we instrument a given program
with a code that tracks runs of state machines representing various kinds of
errors. Next we slice the program to reduce its size without affecting runs of
state machines. And then we symbolically execute the sliced program. Depending
on the kind of symbolic execution, the technique can be applied as a
stand-alone bug finding technique, or to weed out some false positives from an
output of another bug-finding tool. We provide several examples demonstrating
the practical applicability of our technique.
</summary>
    <author>
      <name>Jiří Slabý</name>
    </author>
    <author>
      <name>Jan Strejček</name>
    </author>
    <author>
      <name>Marek Trtík</name>
    </author>
    <link href="http://arxiv.org/abs/1201.4719v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.4719v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1201.6188v1</id>
    <updated>2012-01-30T11:58:01Z</updated>
    <published>2012-01-30T11:58:01Z</published>
    <title>On the realizability of contracts in dishonest systems</title>
    <summary>  We develop a theory of contracting systems, where behavioural contracts may
be violated by dishonest participants after they have been agreed upon - unlike
in traditional approaches based on behavioural types. We consider the contracts
of \cite{CastagnaPadovaniGesbert09toplas}, and we embed them in a calculus that
allows distributed participants to advertise contracts, reach agreements, query
the fulfilment of contracts, and realise them (or choose not to).
  Our contract theory makes explicit who is culpable at each step of a
computation. A participant is honest in a given context S when she is not
culpable in each possible interaction with S. Our main result is a sufficient
criterion for classifying a participant as honest in all possible contexts.
</summary>
    <author>
      <name>Massimo Bartoletti</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <author>
      <name>Roberto Zunino</name>
    </author>
    <link href="http://arxiv.org/abs/1201.6188v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1201.6188v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2086v2</id>
    <updated>2012-03-01T20:44:48Z</updated>
    <published>2012-02-09T19:22:13Z</published>
    <title>Typing Copyless Message Passing</title>
    <summary>  We present a calculus that models a form of process interaction based on
copyless message passing, in the style of Singularity OS. The calculus is
equipped with a type system ensuring that well-typed processes are free from
memory faults, memory leaks, and communication errors. The type system is
essentially linear, but we show that linearity alone is inadequate, because it
leaves room for scenarios where well-typed processes leak significant amounts
of memory. We address these problems basing the type system upon an original
variant of session types.
</summary>
    <author>
      <name>Viviana Bono</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-8(1:17)2012</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-8(1:17)2012" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">50 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 8, Issue 1 (March 2,
  2012) lmcs:798</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2086v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2086v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2, F.3.3, F.3.1, D.4.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2736v1</id>
    <updated>2012-02-13T14:14:00Z</updated>
    <published>2012-02-13T14:14:00Z</published>
    <title>Function call overhead benchmarks with MATLAB, Octave, Python, Cython
  and C</title>
    <summary>  We consider the overhead of function calls in the programming languages
MATLAB/Octave, Python, Cython and C. In many applications a function has to be
called very often inside a loop. One such application in numerical analysis is
the finite element method where integrals have to be computed on each element
in a loop. The called functions can often be evaluated efficiently but the
function call itself may be time-consuming. We present a benchmark whose goal
is to identify and quantify optimization potentials with respect to time
consumption caused by function calls in the mentioned programming languages.
</summary>
    <author>
      <name>André Gaul</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The benchmark's source code is available under GPL3 at
  https://bitbucket.org/andrenarchy/funcall</arxiv:comment>
    <link href="http://arxiv.org/abs/1202.2736v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2736v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.2922v1</id>
    <updated>2012-02-14T03:01:53Z</updated>
    <published>2012-02-14T03:01:53Z</published>
    <title>Tracing monadic computations and representing effects</title>
    <summary>  In functional programming, monads are supposed to encapsulate computations,
effectfully producing the final result, but keeping to themselves the means of
acquiring it. For various reasons, we sometimes want to reveal the internals of
a computation. To make that possible, in this paper we introduce monad
transformers that add the ability to automatically accumulate observations
about the course of execution as an effect. We discover that if we treat the
resulting trace as the actual result of the computation, we can find new
functionality in existing monads, notably when working with non-terminating
computations.
</summary>
    <author>
      <name>Maciej Piróg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Oxford</arxiv:affiliation>
    </author>
    <author>
      <name>Jeremy Gibbons</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, University of Oxford</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.76.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.76.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2012, arXiv:1202.2407</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 76, 2012, pp. 90-111</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1202.2922v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.2922v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1202.5959v2</id>
    <updated>2012-02-28T15:33:59Z</updated>
    <published>2012-02-27T14:49:00Z</published>
    <title>Normal Form Bisimulations for Delimited-Control Operators</title>
    <summary>  We define a notion of normal form bisimilarity for the untyped call-by-value
lambda calculus extended with the delimited-control operators shift and reset.
Normal form bisimilarities are simple, easy-to-use behavioral equivalences
which relate terms without having to test them within all contexts (like
contextual equivalence), or by applying them to function arguments (like
applicative bisimilarity). We prove that the normal form bisimilarity for shift
and reset is sound but not complete w.r.t. contextual equivalence and we define
up-to techniques that aim at simplifying bisimulation proofs. Finally, we
illustrate the simplicity of the techniques we develop by proving several
equivalences on terms.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Serguei Lenglet</name>
    </author>
    <link href="http://arxiv.org/abs/1202.5959v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1202.5959v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.0835v1</id>
    <updated>2012-03-05T09:07:18Z</updated>
    <published>2012-03-05T09:07:18Z</published>
    <title>Functional Logic Programming with Generalized Circular Coinduction</title>
    <summary>  We propose a method to adapt functional logic programming to deal with
reasoning on coinductively interpreted programs as well as on inductively
interpreted programs. In order to do so, we consider a class of objects
interesting for this coinductive interpretation, namely regular terms. We show
how the usual data structures can be adapted to capture these objects. We adapt
the operational semantics of Curry to interpret programs coinductively. We
illustrate this method with several examples that show the working of our
method and several cases in which it could be useful. Finally, we suggest how
the declarative semantics can be adapted suitably.
</summary>
    <author>
      <name>Ronald de Haan</name>
    </author>
    <link href="http://arxiv.org/abs/1203.0835v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.0835v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.1539v1</id>
    <updated>2012-03-07T17:05:09Z</updated>
    <published>2012-03-07T17:05:09Z</published>
    <title>Programming with Algebraic Effects and Handlers</title>
    <summary>  Eff is a programming language based on the algebraic approach to
computational effects, in which effects are viewed as algebraic operations and
effect handlers as homomorphisms from free algebras. Eff supports first-class
effects and handlers through which we may easily define new computational
effects, seamlessly combine existing ones, and handle them in novel ways. We
give a denotational semantics of eff and discuss a prototype implementation
based on it. Through examples we demonstrate how the standard effects are
treated in eff, and how eff supports programming techniques that use various
forms of delimited continuations, such as backtracking, breadth-first search,
selection functionals, cooperative multi-threading, and others.
</summary>
    <author>
      <name>Andrej Bauer</name>
    </author>
    <author>
      <name>Matija Pretnar</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.jlamp.2014.02.001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.jlamp.2014.02.001" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Logical and Algebraic Methods in Programming. Volume
  84, Issue 1, January 2015, Pages 108-123</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1203.1539v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.1539v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.1986v1</id>
    <updated>2012-03-09T04:19:19Z</updated>
    <published>2012-03-09T04:19:19Z</published>
    <title>Type-Preserving Flow Analysis and Interprocedural Unboxing (Extended
  Version)</title>
    <summary>  Interprocedural flow analysis can be used to eliminate otherwise unnecessary
heap allocated objects (unboxing), and in previous work we have shown how to do
so while maintaining correctness with respect to the garbage collector. In this
paper, we extend the notion of flow analysis to incorporate types, enabling
analysis and optimization of typed programs. We apply this typed analysis to
specify a type preserving interprocedural unboxing optimization, and prove that
the optimization preserves both type and GC safety along with program
semantics. We also show that the unboxing optimization can be applied
independently to separately compiled program modules, and prove via a
contextual equivalence result that unboxing a module in isolation preserves
program semantics.
</summary>
    <author>
      <name>Neal Glew</name>
    </author>
    <author>
      <name>Leaf Petersen</name>
    </author>
    <link href="http://arxiv.org/abs/1203.1986v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.1986v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1203.5303v1</id>
    <updated>2012-03-23T17:22:06Z</updated>
    <published>2012-03-23T17:22:06Z</published>
    <title>Bound Analysis of Imperative Programs with the Size-change Abstraction
  (extended version)</title>
    <summary>  The size-change abstraction (SCA) is an important program abstraction for
termination analysis, which has been successfully implemented in many tools for
functional and logic programs. In this paper, we demonstrate that SCA is also a
highly effective abstract domain for the bound analysis of imperative programs.
  We have implemented a bound analysis tool based on SCA for imperative
programs. We abstract programs in a pathwise and context dependent manner,
which enables our tool to analyze real-world programs effectively. Our work
shows that SCA captures many of the essential ideas of previous termination and
bound analysis and goes beyond in a conceptually simpler framework.
</summary>
    <author>
      <name>Florian Zuleger</name>
    </author>
    <author>
      <name>Sumit Gulwani</name>
    </author>
    <author>
      <name>Moritz Sinn</name>
    </author>
    <author>
      <name>Helmut Veith</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of SAS 2011 conference article</arxiv:comment>
    <link href="http://arxiv.org/abs/1203.5303v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1203.5303v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.1147v1</id>
    <updated>2012-04-05T08:33:16Z</updated>
    <published>2012-04-05T08:33:16Z</published>
    <title>Numerical Invariants through Convex Relaxation and Max-Strategy
  Iteration</title>
    <summary>  In this article we develop a max-strategy improvement algorithm for computing
least fixpoints of operators on on the reals that are point-wise maxima of
finitely many monotone and order-concave operators. Computing the uniquely
determined least fixpoint of such operators is a problem that occurs frequently
in the context of numerical program/systems verification/analysis. As an
example for an application we discuss how our algorithm can be applied to
compute numerical invariants of programs by abstract interpretation based on
quadratic templates.
</summary>
    <author>
      <name>Thomas Martin Gawlitza</name>
    </author>
    <author>
      <name>Helmut Seidl</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">42 pages, conference version appears in the proceedings of the Static
  Analysis Symposium 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1204.1147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.1147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.5541v1</id>
    <updated>2012-04-25T02:41:47Z</updated>
    <published>2012-04-25T02:41:47Z</published>
    <title>The Design of GP 2</title>
    <summary>  This papers defines the syntax and semantics of GP 2, a revised version of
the graph programming language GP. New concepts are illustrated and explained
with example programs. Changes to the first version of GP include an improved
type system for labels, a built-in marking mechanism for nodes and edges, a
more powerful edge predicate for conditional rule schemata, and functions
returning the indegree and outdegree of matched nodes. Moreover, the semantics
of the branching and loop statement have been simplified to allow their
efficient implementation.
</summary>
    <author>
      <name>Detlef Plump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of York</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.82.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.82.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WRS 2011, arXiv:1204.5318</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 82, 2012, pp. 1-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1204.5541v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.5541v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1204.6411v1</id>
    <updated>2012-04-28T14:26:56Z</updated>
    <published>2012-04-28T14:26:56Z</published>
    <title>Catroid: A Mobile Visual Programming System for Children</title>
    <summary>  Catroid is a free and open source visual programming language, programming
environment, image manipulation program, and website. Catroid allows casual and
first-time users starting from age eight to develop their own animations and
games solely using their Android phones or tablets. Catroid also allows to
wirelessly control external hardware such as Lego Mindstorms robots via
Bluetooth, Bluetooth Arduino boards, as well as Parrot's popular and
inexpensive AR.Drone quadcopters via WiFi.
</summary>
    <author>
      <name>Wolfgang Slany</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages. Demo paper at the 11th International Conference on
  Interaction Design and Children (IDC 2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1204.6411v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1204.6411v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1206.5112v1</id>
    <updated>2012-06-22T11:07:14Z</updated>
    <published>2012-06-22T11:07:14Z</published>
    <title>Lucretia - a type system for objects in languages with reflection</title>
    <summary>  Object-oriented scripting languages such as JavaScript or Python gain in
popularity due to their flexibility. Still, the growing code bases written in
the languages call for methods that make possible to automatically control the
properties of the programs that ensure their stability in the running time. We
propose a type system, called Lucretia, that makes possible to control the
object structure of languages with reflection. Subject reduction and soundness
of the type system with respect to the semantics of the language is proved.
</summary>
    <author>
      <name>Viviana Bono</name>
    </author>
    <author>
      <name>Marcin Benke</name>
    </author>
    <author>
      <name>Aleksy Schubert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1206.5112v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1206.5112v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.3; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6369v1</id>
    <updated>2012-07-26T18:56:59Z</updated>
    <published>2012-07-26T18:56:59Z</published>
    <title>Concept of the abstract program</title>
    <summary>  The aim of this paper is to alter the abstract definition of the program of
the theoretical programming model which has been developed at Eotvos Lorand
University for many years in order to investigate methods that support
designing correct programs. The motivation of this modification was that the
dynamic properties of programs appear in the model. This new definition of the
program gives a hand to extend the model with the concept of subprograms while
the earlier results of the original programming model are preserved.
</summary>
    <author>
      <name>T. Gregorics</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Acta Universitatis Sapientiae, Informatica, 4, 1 (2012) 7-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1207.6369v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6369v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N30" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6541v1</id>
    <updated>2012-07-27T13:40:23Z</updated>
    <published>2012-07-27T13:40:23Z</published>
    <title>Guided Grammar Convergence. Full Case Study Report. Generated by
  converge::Guided</title>
    <summary>  This report is meant to be used as auxiliary material for the guided grammar
convergence technique proposed earlier as problem-specific improvement in the
topic of convergence of grammars. It contains a narrated MegaL megamodel, as
well as full results of the guided grammar convergence experiment on the
Factorial Language, with details about each grammar source packaged in a
readable form. All formulae used within this document, are generated
automatically by the convergence infrastructure in order to avoid any mistakes.
The generator source code and the source of the introduction text can be found
publicly available in the Software Language Processing Suite repository.
</summary>
    <author>
      <name>Vadim Zaytsev</name>
    </author>
    <link href="http://arxiv.org/abs/1207.6541v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6541v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.2; F.4.3; I.2.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1207.6816v1</id>
    <updated>2012-07-30T01:11:12Z</updated>
    <published>2012-07-30T01:11:12Z</published>
    <title>Transforming floundering into success</title>
    <summary>  We show how logic programs with "delays" can be transformed to programs
without delays in a way which preserves information concerning floundering
(also known as deadlock). This allows a declarative (model-theoretic),
bottom-up or goal independent approach to be used for analysis and debugging of
properties related to floundering. We rely on some previously introduced
restrictions on delay primitives and a key observation which allows properties
such as groundness to be analysed by approximating the (ground) success set.
This paper is to appear in Theory and Practice of Logic Programming (TPLP).
  Keywords: Floundering, delays, coroutining, program analysis, abstract
interpretation, program transformation, declarative debugging
</summary>
    <author>
      <name>Lee Naish</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S147106841200035X</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S147106841200035X" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Number of pages: 24 Number of figures: 9 Number of tables: none</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 14 (2014) 215-238</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1207.6816v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1207.6816v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1208.0535v1</id>
    <updated>2012-08-02T16:38:13Z</updated>
    <published>2012-08-02T16:38:13Z</published>
    <title>Modular Type-Safety Proofs using Dependant Types</title>
    <summary>  While methods of code abstraction and reuse are widespread and well
researched, methods of proof abstraction and reuse are still emerging. We
consider the use of dependent types for this purpose, introducing a completely
mechanical approach to proof composition. We show that common techniques for
abstracting algorithms over data structures naturally translate to abstractions
over proofs. We first introduce a language composed of a series of smaller
language components tied together by standard techniques from Malcom (1990). We
proceed by giving proofs of type preservation for each language component and
show that the basic ideas used in composing the syntactic data structures can
be applied to their semantics as well.
</summary>
    <author>
      <name>Christopher Schwaab</name>
    </author>
    <author>
      <name>Jeremy G. Siek</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1208.0535v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1208.0535v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1209.1711v2</id>
    <updated>2018-01-09T15:22:10Z</updated>
    <published>2012-09-08T12:31:50Z</published>
    <title>Programming Languages for Scientific Computing</title>
    <summary>  Scientific computation is a discipline that combines numerical analysis,
physical understanding, algorithm development, and structured programming.
Several yottacycles per year on the world's largest computers are spent
simulating problems as diverse as weather prediction, the properties of
material composites, the behavior of biomolecules in solution, and the quantum
nature of chemical compounds. This article is intended to review specfic
languages features and their use in computational science. We will review the
strengths and weaknesses of different programming styles, with examples taken
from widely used scientific codes.
</summary>
    <author>
      <name>Matthew G. Knepley</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-540-70529-1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-540-70529-1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">21 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Encyclopedia of Applied and Computational Mathematics, Springer,
  2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1209.1711v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1209.1711v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1209.5145v1</id>
    <updated>2012-09-24T03:55:45Z</updated>
    <published>2012-09-24T03:55:45Z</published>
    <title>Julia: A Fast Dynamic Language for Technical Computing</title>
    <summary>  Dynamic languages have become popular for scientific computing. They are
generally considered highly productive, but lacking in performance. This paper
presents Julia, a new dynamic language for technical computing, designed for
performance from the beginning by adapting and extending modern programming
language techniques. A design based on generic functions and a rich type system
simultaneously enables an expressive programming model and successful type
inference, leading to good performance for a wide range of programs. This makes
it possible for much of the Julia library to be written in Julia itself, while
also incorporating best-of-breed C and Fortran libraries.
</summary>
    <author>
      <name>Jeff Bezanson</name>
    </author>
    <author>
      <name>Stefan Karpinski</name>
    </author>
    <author>
      <name>Viral B. Shah</name>
    </author>
    <author>
      <name>Alan Edelman</name>
    </author>
    <link href="http://arxiv.org/abs/1209.5145v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1209.5145v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.2297v2</id>
    <updated>2012-10-09T12:43:36Z</updated>
    <published>2012-10-08T14:34:25Z</published>
    <title>Diagrammatic confluence for Constraint Handling Rules</title>
    <summary>  Confluence is a fundamental property of Constraint Handling Rules (CHR)
since, as in other rewriting formalisms, it guarantees that the computations
are not dependent on rule application order, and also because it implies the
logical consistency of the program declarative view. In this paper we are
concerned with proving the confluence of non-terminating CHR programs. For this
purpose, we derive from van Oostrom's decreasing diagrams method a novel
criterion on CHR critical pairs that generalizes all preexisting criteria. We
subsequently improve on a result on the modularity of CHR confluence, which
permits modular combinations of possibly non-terminating confluent programs,
without loss of confluence.
</summary>
    <author>
      <name>Rémy Haemmerlé</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068412000270</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068412000270" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 12(4-5): 737-753, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.2297v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.2297v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.3937v1</id>
    <updated>2012-10-15T08:31:38Z</updated>
    <published>2012-10-15T08:31:38Z</published>
    <title>Introduction to the 28th International Conference on Logic Programming
  Special Issue</title>
    <summary>  We are proud to introduce this special issue of the Journal of Theory and
Practice of Logic Programming (TPLP), dedicated to the full papers accepted for
the 28th International Conference on Logic Programming (ICLP). The ICLP
meetings started in Marseille in 1982 and since then constitute the main venue
for presenting and discussing work in the area of logic programming.
</summary>
    <author>
      <name>Agostino Dovier</name>
    </author>
    <author>
      <name>Vítor Santos Costa</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068412000300</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068412000300" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">TPLP 12 (4-5): 421-426, 2012</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.3937v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.3937v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.5935v1</id>
    <updated>2012-10-22T15:36:56Z</updated>
    <published>2012-10-22T15:36:56Z</published>
    <title>GADT meet Subtyping</title>
    <summary>  While generalized abstract datatypes (GADT) are now considered
well-understood, adding them to a language with a notion of subtyping comes
with a few surprises. What does it mean for a GADT parameter to be covariant?
The answer turns out to be quite subtle. It involves fine-grained properties of
the subtyping relation that raise interesting design questions. We allow
variance annotations in GADT definitions, study their soundness, and present a
sound and complete algorithm to check them. Our work may be applied to
real-world ML-like languages with explicit subtyping such as OCaml, or to
languages with general subtyping constraints.
</summary>
    <author>
      <name>Gabriel Scherer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Didier Rémy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">No. RR-8114 (2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1210.5935v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.5935v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1210.6114v1</id>
    <updated>2012-10-23T02:55:15Z</updated>
    <published>2012-10-23T02:55:15Z</published>
    <title>Adding Sessions to BPEL</title>
    <summary>  By considering an essential subset of the BPEL orchestration language, we
define SeB, a session based style of this subset. We discuss the formal
semantics of SeB and we present its main properties. We use a new approach to
address the formal semantics, based on a translation into so-called control
graphs. Our semantics handles control links and addresses the static semantics
that prescribes the valid usage of variables. We also provide the semantics of
collections of networked services.
  Relying on these semantics, we define precisely what is meant by interaction
safety, paving the way to the formal analysis of safe interactions between BPEL
services.
</summary>
    <author>
      <name>Jonathan Michaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Télécom ParisTech</arxiv:affiliation>
    </author>
    <author>
      <name>Elie Najm</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Télécom ParisTech</arxiv:affiliation>
    </author>
    <author>
      <name>Alessandro Fantechi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università degli Studi di Firenze</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.98.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.98.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2012, arXiv:1210.5783</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 98, 2012, pp. 60-76</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1210.6114v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1210.6114v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1211.6192v1</id>
    <updated>2012-11-27T02:37:00Z</updated>
    <published>2012-11-27T02:37:00Z</published>
    <title>Static Analysis of Lockless Microcontroller C Programs</title>
    <summary>  Concurrently accessing shared data without locking is usually a subject to
race conditions resulting in inconsistent or corrupted data. However, there are
programs operating correctly without locking by exploiting the atomicity of
certain operations on a specific hardware. In this paper, we describe how to
precisely analyze lockless microcontroller C programs with interrupts by taking
the hardware architecture into account. We evaluate this technique in an
octagon-based value range analysis using access-based localization to increase
efficiency.
</summary>
    <author>
      <name>Eva Beckschulze</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Sebastian Biallas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Stefan Kowalewski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Embedded Software Laboratory RWTH Aachen University, Germany</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.102.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.102.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings SSV 2012, arXiv:1211.5873</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 102, 2012, pp. 103-114</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1211.6192v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1211.6192v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1212.6844v1</id>
    <updated>2012-12-31T09:20:05Z</updated>
    <published>2012-12-31T09:20:05Z</published>
    <title>Improving Robustness via Disjunctive Statements in Imperative
  Programming</title>
    <summary>  To deal with failures as simply as possible, we propose a new foun- dation
for the core (untyped) C, which is based on a new logic called task logic or
imperative logic. We then introduce a sequential-disjunctive statement of the
form S : R. This statement has the following semantics: execute S and R
sequentially. It is considered a success if at least one of S;R is a success.
This statement is useful for dealing with inessential errors without explicitly
catching them.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Sungwoo Hur</name>
    </author>
    <author>
      <name>Mi-Young Park</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1587/transinf.E96.D.2036</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1587/transinf.E96.D.2036" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">IEICE transaction on information and system, vol.E96-D, no. 9,
  Sep, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1212.6844v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1212.6844v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.2903v1</id>
    <updated>2013-01-14T10:22:57Z</updated>
    <published>2013-01-14T10:22:57Z</published>
    <title>GADTs meet subtyping</title>
    <summary>  While generalized algebraic datatypes (\GADTs) are now considered
well-understood, adding them to a language with a notion of subtyping comes
with a few surprises. What does it mean for a \GADT parameter to be covariant?
The answer turns out to be quite subtle. It involves fine-grained properties of
the subtyping relation that raise interesting design questions. We allow
variance annotations in \GADT definitions, study their soundness, and present a
sound and complete algorithm to check them. Our work may be applied to
real-world ML-like languages with explicit subtyping such as OCaml, or to
languages with general subtyping constraints.
</summary>
    <author>
      <name>Gabriel Scherer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Didier Rémy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1210.5935</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">22nd European Symposium on Programming (ESOP), Rome : Italy (2013)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.2903v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.2903v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.4779v1</id>
    <updated>2013-01-21T08:12:22Z</updated>
    <published>2013-01-21T08:12:22Z</published>
    <title>Formal Verification of Hardware Synthesis</title>
    <summary>  We report on the implementation of a certified compiler for a high-level
hardware description language (HDL) called Fe-Si (FEatherweight SynthesIs).
Fe-Si is a simplified version of Bluespec, an HDL based on a notion of guarded
atomic actions. Fe-Si is defined as a dependently typed deep embedding in Coq.
The target language of the compiler corresponds to a synthesisable subset of
Verilog or VHDL. A key aspect of our approach is that input programs to the
compiler can be defined and proved correct inside Coq. Then, we use extraction
and a Verilog back-end (written in OCaml) to get a certified version of a
hardware design.
</summary>
    <author>
      <name>Thomas Braibant</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Adam Chlipala</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CSAIL</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-39799-8_14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-39799-8_14" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Aided Verification, Saint Petersburg : Russie,
  F\'ed\'eration De (2013)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.4779v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.4779v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.5076v1</id>
    <updated>2013-01-22T05:17:40Z</updated>
    <published>2013-01-22T05:17:40Z</published>
    <title>Mathematics Is Imprecise</title>
    <summary>  We commonly think of mathematics as bringing precision to application
domains, but its relationship with computer science is more complex. This
experience report on the use of Racket and Haskell to teach a required first
university CS course to students with very good mathematical skills focusses on
the ways that programming forces one to get the details right, with consequent
benefits in the mathematical domain. Conversely, imprecision in mathematical
abstractions and notation can work to the benefit of beginning programmers, if
handled carefully.
</summary>
    <author>
      <name>Prabhakar Ragde</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waterloo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.106.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.106.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2012, arXiv:1301.4650</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 106, 2013, pp. 40-49</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1301.5076v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.5076v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1;K.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.6260v1</id>
    <updated>2013-01-26T14:25:54Z</updated>
    <published>2013-01-26T14:25:54Z</published>
    <title>Problems of Inheritance at Java Inner Class</title>
    <summary>  Single inheritance has been widely accepted in the current programming
practice to avoid the complication that incurred by multiple inheritance.
Single inheritance enhances the reusability of codes and eliminates the
confusion of identical methods that possibly defined in two superclasses.
However, the mechanism of inner class in Java potentially reintroduces the
problems encountered by multiple inheritance. When the depth of Java inner
class is increased, the problem becomes severe. This paper aims at exposing the
problems of inheritance at the Java inner class. In addition, a measure is
proposed to evaluate the potential problem of inheritance for Java inner class
</summary>
    <author>
      <name>Sim-Hui Tee</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1301.6260v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.6260v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1301.7680v1</id>
    <updated>2013-01-31T16:55:52Z</updated>
    <published>2013-01-31T16:55:52Z</published>
    <title>Efficient Support for Mode-Directed Tabling in the YapTab Tabling System</title>
    <summary>  Mode-directed tabling is an extension to the tabling technique that supports
the definition of mode operators for specifying how answers are inserted into
the table space. In this paper, we focus our discussion on the efficient
support for mode directed-tabling in the YapTab tabling system. We discuss 7
different mode operators and explain how we have extended and optimized
YapTab's table space organization to support them. Initial experimental results
show that our implementation compares favorably with the B-Prolog and XSB
state-of-the-art Prolog tabling systems.
</summary>
    <author>
      <name>João Santos</name>
    </author>
    <author>
      <name>Ricardo Rocha</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in CICLOPS 2012. 15 Pages, 12 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1301.7680v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1301.7680v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.0722v1</id>
    <updated>2013-03-04T15:11:38Z</updated>
    <published>2013-03-04T15:11:38Z</published>
    <title>EasyTime++: A case study of incremental domain-specific language
  development</title>
    <summary>  EasyTime is a domain-specific language (DSL) for measuring time during sports
competitions. A distinguishing feature of DSLs is that they are much more
amenable to change, and EasyTime is no exception in this regard. This paper
introduces two new EasyTime features: classifications of competitors into
categories, and the inclusion of competitions where the number of laps must be
dynamically determined. It shows how such extensions can be incrementally added
into the base-language reusing most of the language specifications. Two case
studies are presented showing the suitability of this approach.
</summary>
    <author>
      <name>Iztok Fister Jr.</name>
    </author>
    <author>
      <name>Tomaž Kosar</name>
    </author>
    <author>
      <name>Iztok Fister</name>
    </author>
    <author>
      <name>Marjan Mernik</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Information technology and control, 42(1), 77--85, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1303.0722v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.0722v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.0908v1</id>
    <updated>2013-03-05T02:13:28Z</updated>
    <published>2013-03-05T02:13:28Z</published>
    <title>KRAB Algorithm - A Revised Algorithm for Incremental Call Graph
  Generation</title>
    <summary>  This paper is aimed to present the importance and implementation of an
incremental call graph plugin. An algorithm is proposed for the call graph
implementation which has better overall performance than the algorithm that has
been proposed previously. In addition to this, the algorithm has been
empirically proved to have excellent performance on recursive codes. The
algorithm also readily checks for function skip and returns exceptions.
</summary>
    <author>
      <name>Rajasekhara Babu</name>
    </author>
    <author>
      <name>Krishnakumar V.</name>
    </author>
    <author>
      <name>George Abraham</name>
    </author>
    <author>
      <name>Kiransinh Borasia</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 7 figures, 1 Table, Conference</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">World Applied Programming, Vol (2), Issue (5), May 2012. 294-299,
  Special section for proceeding of International E-Conference on Information
  Technology and Applications (IECITA), ISSN: 2222-2510</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1303.0908v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.0908v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1303.1880v2</id>
    <updated>2014-09-16T06:59:03Z</updated>
    <published>2013-03-08T04:02:33Z</published>
    <title>A Simple Algorithm for Global Value Numbering</title>
    <summary>  Global Value Numbering(GVN) is a method for detecting redundant computations
in programs. Here, we introduce the problem of Global Value Numbering in its
original form, as conceived by Kildall(1973), and present an algorithm which is
a simpler variant of Kildall's. The algorithm uses the concept of value
expression - an abstraction of a set of expressions - enabling a representation
of the equivalence information which is compact and simple to manipulate.
</summary>
    <author>
      <name>Nabizath Saleena</name>
    </author>
    <author>
      <name>Vineeth Paleri</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1303.1880v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1303.1880v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.0660v1</id>
    <updated>2013-04-02T15:07:47Z</updated>
    <published>2013-04-02T15:07:47Z</published>
    <title>Quantified Data Automata on Skinny Trees: an Abstract Domain for Lists</title>
    <summary>  We propose a new approach to heap analysis through an abstract domain of
automata, called automatic shapes. The abstract domain uses a particular kind
of automata, called quantified data automata on skinny trees (QSDAs), that
allows to define universally quantified properties of singly-linked lists. To
ensure convergence of the abstract fixed-point computation, we introduce a
sub-class of QSDAs called elastic QSDAs, which also form an abstract domain. We
evaluate our approach on several list manipulating programs and we show that
the proposed domain is powerful enough to prove a large class of these programs
correct.
</summary>
    <author>
      <name>Pranav Garg</name>
    </author>
    <author>
      <name>P. Madhusudan</name>
    </author>
    <author>
      <name>Gennaro Parlato</name>
    </author>
    <link href="http://arxiv.org/abs/1304.0660v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.0660v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.0864v1</id>
    <updated>2013-04-03T08:01:42Z</updated>
    <published>2013-04-03T08:01:42Z</published>
    <title>Efficient Generation of Correctness Certificates for the Abstract Domain
  of Polyhedra</title>
    <summary>  Polyhedra form an established abstract domain for inferring runtime
properties of programs using abstract interpretation. Computations on them need
to be certified for the whole static analysis results to be trusted. In this
work, we look at how far we can get down the road of a posteriori verification
to lower the overhead of certification of the abstract domain of polyhedra. We
demonstrate methods for making the cost of inclusion certificate generation
negligible. From a performance point of view, our single-representation,
constraints-based implementation compares with state-of-the-art
implementations.
</summary>
    <author>
      <name>Alexis Fouilhé</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Michaël Périn</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1304.0864v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.0864v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.1913v2</id>
    <updated>2013-05-07T16:47:24Z</updated>
    <published>2013-04-06T17:00:00Z</published>
    <title>Towards Efficient Abstractions for Concurrent Consensus</title>
    <summary>  Consensus is an often occurring problem in concurrent and distributed
programming. We present a programming language with simple semantics and
build-in support for consensus in the form of communicating transactions. We
motivate the need for such a construct with a characteristic example of
generalized consensus which can be naturally encoded in our language. We then
focus on the challenges in achieving an implementation that can efficiently run
such programs. We setup an architecture to evaluate different implementation
alternatives and use it to experimentally evaluate runtime heuristics. This is
the basis for a research project on realistic programming language support for
consensus.
</summary>
    <author>
      <name>Carlo Spaccasassi</name>
    </author>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 5 figures, symposium: TFP 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.1913v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.1913v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.3140v1</id>
    <updated>2013-04-09T04:20:23Z</updated>
    <published>2013-04-09T04:20:23Z</published>
    <title>On PROGRESS Operation. How to Make Object-Oriented Programming System
  More Object-Oriented (DRAFT)</title>
    <summary>  A system, which implements persistent objects, has to provide different
opportunities to change the objects in arbitrary ways during their existence. A
traditional realization of OO paradigm in modern programming systems has
fundamental drawbacks which complicate an implementation of persistent
modifiable objects considerably. There is alternative realization that does not
have these drawbacks. In the article the PROGRESS operation is offered, which
modify existing object within an existing inheritance hierarchy.
</summary>
    <author>
      <name>Evgeniy Grigoriev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.3140v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.3140v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.1; D.3.3; H.2.3; H.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.5485v1</id>
    <updated>2013-04-19T17:33:33Z</updated>
    <published>2013-04-19T17:33:33Z</published>
    <title>An Introduction to Quantum Programming in Quipper</title>
    <summary>  Quipper is a recently developed programming language for expressing quantum
computations. This paper gives a brief tutorial introduction to the language,
through a demonstration of how to make use of some of its key features. We
illustrate many of Quipper's language features by developing a few well known
examples of Quantum computation, including quantum teleportation, the quantum
Fourier transform, and a quantum circuit for addition.
</summary>
    <author>
      <name>Alexander S. Green</name>
    </author>
    <author>
      <name>Peter LeFanu Lumsdaine</name>
    </author>
    <author>
      <name>Neil J. Ross</name>
    </author>
    <author>
      <name>Peter Selinger</name>
    </author>
    <author>
      <name>Benoît Valiron</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-38986-3_10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-38986-3_10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, RC2013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Lecture Notes in Computer Science 7948:110-124, Springer, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1304.5485v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.5485v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.5661v1</id>
    <updated>2013-04-20T18:58:36Z</updated>
    <published>2013-04-20T18:58:36Z</published>
    <title>On Integrating Deductive Synthesis and Verification Systems</title>
    <summary>  We describe techniques for synthesis and verification of recursive functional
programs over unbounded domains. Our techniques build on top of an algorithm
for satisfiability modulo recursive functions, a framework for deductive
synthesis, and complete synthesis procedures for algebraic data types. We
present new counterexample-guided algorithms for constructing verified
programs. We have implemented these algorithms in an integrated environment for
interactive verification and synthesis from relational specifications. Our
system was able to synthesize a number of useful recursive functions that
manipulate unbounded numbers and data structures.
</summary>
    <author>
      <name>Etienne Kneuss</name>
    </author>
    <author>
      <name>Viktor Kuncak</name>
    </author>
    <author>
      <name>Ivan Kuraj</name>
    </author>
    <author>
      <name>Philippe Suter</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages. 46 references</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.5661v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.5661v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.6038v1</id>
    <updated>2013-04-22T18:07:36Z</updated>
    <published>2013-04-22T18:07:36Z</published>
    <title>Implementing hash-consed structures in Coq</title>
    <summary>  We report on three different approaches to use hash-consing in programs
certified with the Coq system, using binary decision diagrams (BDD) as running
example. The use cases include execution inside Coq, or execution of the
extracted OCaml code. There are different trade-offs between faithful use of
pristine extracted code, and code that is fine-tuned to make use of OCaml
programming constructs not available in Coq. We discuss the possible
consequences in terms of performances and guarantees.
</summary>
    <author>
      <name>Thomas Braibant</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>Jacques-Henri Jourdan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Rocquencourt</arxiv:affiliation>
    </author>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1304.6038v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.6038v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1304.7600v1</id>
    <updated>2013-04-29T09:30:33Z</updated>
    <published>2013-04-29T09:30:33Z</published>
    <title>C++11 - określanie typów</title>
    <summary>  This paper presents a review of some new futures introduced to C++ language
by ISO/IEC 14882:2011 standard (known as C++11). It describes new language
elements which allow to easier expressed of types of variables: auto and
decltype keywords, new function declaration syntax, and tools which are
included in type_traits header.
  -----
  Niniejszy artyku{\l} jest jednym z serii artyku{\l}\'ow w kt\'orych zawarto
przegl{\ka}d nowych element\'ow j{\ke}zyka C++ wprowadzonych przez standard
ISO/IEC 14882:2011, znany pod nazw{\ka} C++11. W artykule przedstawiono nowe
mo\.zliwo\'sci zwi{\ka}zane ze wskazywaniem typ\'ow zmiennych. Opisano s{\l}owa
kluczowe auto i decltype, now{\ka} sk{\l}adnie deklarowania funkcji/metod oraz
narz{\ke}dzia zawarte w pliku nag{\l}\'owkowym &lt;type_traits&gt;.
</summary>
    <author>
      <name>Piotr Beling</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, in Polish</arxiv:comment>
    <link href="http://arxiv.org/abs/1304.7600v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1304.7600v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.3103v1</id>
    <updated>2013-05-14T10:45:16Z</updated>
    <published>2013-05-14T10:45:16Z</published>
    <title>A fast method for implementation of the property lists in programming
  languages</title>
    <summary>  One of the major challenges in programming languages is to support different
data structures and their variations in both static and dynamic aspects. One of
the these data structures is the property list which applications use it as a
convenient way to store, organize, and access standard types of data. In this
paper, the standards methods for implementation of the Property Lists,
including the Static Array, Link List, Hash and Tree are reviewed. Then an
efficient method to implement the property list is presented. The experimental
results shows that our method is fast compared with the existing methods.
</summary>
    <author>
      <name>Hassan Rashidi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 Pages, 5 Figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.3103v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.3103v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.4584v1</id>
    <updated>2013-05-20T17:38:19Z</updated>
    <published>2013-05-20T17:38:19Z</published>
    <title>Functional Package Management with Guix</title>
    <summary>  We describe the design and implementation of GNU Guix, a purely functional
package manager designed to support a complete GNU/Linux distribution. Guix
supports transactional upgrades and roll-backs, unprivileged package
management, per-user profiles, and garbage collection. It builds upon the
low-level build and deployment layer of the Nix package manager. Guix uses
Scheme as its programming interface. In particular, we devise an embedded
domain-specific language (EDSL) to describe and compose packages. We
demonstrate how it allows us to benefit from the host general-purpose
programming language while not compromising on expressiveness. Second, we show
the use of Scheme to write build programs, leading to "two-tier" programming
system.
</summary>
    <author>
      <name>Ludovic Courtès</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">European Lisp Symposium (2013)</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.4584v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.4584v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1305.6721v1</id>
    <updated>2013-05-29T08:38:32Z</updated>
    <published>2013-05-29T08:38:32Z</published>
    <title>Type-based Dependency Analysis for JavaScript</title>
    <summary>  Dependency analysis is a program analysis that determines potential data flow
between program points. While it is not a security analysis per se, it is a
viable basis for investigating data integrity, for ensuring confidentiality,
and for guaranteeing sanitization. A noninterference property can be stated and
proved for the dependency analysis. We have designed and implemented a
dependency analysis for JavaScript. We formalize this analysis as an
abstraction of a tainting semantics. We prove the correctness of the tainting
semantics, the soundness of the abstraction, a noninterference property, and
the termination of the analysis.
</summary>
    <author>
      <name>Matthias Keil</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report</arxiv:comment>
    <link href="http://arxiv.org/abs/1305.6721v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1305.6721v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4474v1</id>
    <updated>2013-07-17T01:42:29Z</updated>
    <published>2013-07-17T01:42:29Z</published>
    <title>Probabilistic data flow analysis: a linear equational approach</title>
    <summary>  Speculative optimisation relies on the estimation of the probabilities that
certain properties of the control flow are fulfilled. Concrete or estimated
branch probabilities can be used for searching and constructing advantageous
speculative and bookkeeping transformations.
  We present a probabilistic extension of the classical equational approach to
data-flow analysis that can be used to this purpose. More precisely, we show
how the probabilistic information introduced in a control flow graph by branch
prediction can be used to extract a system of linear equations from a program
and present a method for calculating correct (numerical) solutions.
</summary>
    <author>
      <name>Alessandra Di Pierro</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Verona</arxiv:affiliation>
    </author>
    <author>
      <name>Herbert Wiklicky</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.119.14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.119.14" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GandALF 2013, arXiv:1307.4162</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 119, 2013, pp. 150-165</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.4474v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4474v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4635v1</id>
    <updated>2013-07-17T13:58:38Z</updated>
    <published>2013-07-17T13:58:38Z</published>
    <title>Integrating Datalog and Constraint Solving</title>
    <summary>  LP is a common formalism for the field of databases and CSP, both at the
theoretical level and the implementation level in the form of Datalog and CLP.
In the past, close correspondences have been made between both fields at the
theoretical level. Yet correspondence at the implementation level has been much
less explored. In this article we work towards relating them at the
implementation level. Concretely, we show how to derive the efficient Leapfrog
Triejoin execution algorithm of Datalog from a generic CP execution scheme.
</summary>
    <author>
      <name>Benoit Desouter</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4635v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4635v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4641v1</id>
    <updated>2013-07-17T14:13:50Z</updated>
    <published>2013-07-17T14:13:50Z</published>
    <title>Experimenting with X10 for Parallel Constraint-Based Local Search</title>
    <summary>  In this study, we have investigated the adequacy of the PGAS parallel
language X10 to implement a Constraint-Based Local Search solver. We decided to
code in this language to benefit from the ease of use and architectural
independence from parallel resources which it offers. We present the
implementation strategy, in search of different sources of parallelism in the
context of an implementation of the Adaptive Search algorithm. We extensively
discuss the algorithm and its implementation. The performance evaluation on a
representative set of benchmarks shows close to linear speed-ups, in all the
problems treated.
</summary>
    <author>
      <name>Danny Munera</name>
    </author>
    <author>
      <name>Daniel Diaz</name>
    </author>
    <author>
      <name>Salvador Abreu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4641v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4641v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4642v1</id>
    <updated>2013-07-17T14:14:08Z</updated>
    <published>2013-07-17T14:14:08Z</published>
    <title>A Prolog Specification of Giant Number Arithmetic</title>
    <summary>  The tree based representation described in this paper, hereditarily binary
numbers, applies recursively a run-length compression mechanism that enables
computations limited by the structural complexity of their operands rather than
by their bitsizes. While within constant factors from their traditional
counterparts for their worst case behavior, our arithmetic operations open the
doors for interesting numerical computations, impossible with traditional
number representations. We provide a complete specification of our algorithms
in the form of a purely declarative Prolog program.
</summary>
    <author>
      <name>Paul Tarau</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4642v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4642v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4644v1</id>
    <updated>2013-07-17T14:20:15Z</updated>
    <published>2013-07-17T14:20:15Z</published>
    <title>Interning Ground Terms in XSB</title>
    <summary>  This paper presents an implementation of interning of ground terms in the XSB
Tabled Prolog system. This is related to the idea of hash-consing. I describe
the concept of interning atoms and discuss the issues around interning ground
structured terms, motivating why tabling Prolog systems may change the
cost-benefit tradeoffs from those of traditional Prolog systems. I describe the
details of the implementation of interning ground terms in the XSB Tabled
Prolog System and show some of its performance properties. This implementation
achieves the effects of that of Zhou and Have but is tuned for XSB's
representations and is arguably simpler.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 13th International Colloquium on Implementation of
  Constraint LOgic Programming Systems (CICLOPS 2013), Istanbul, Turkey, August
  25, 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4644v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4644v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.4827v1</id>
    <updated>2013-07-18T04:06:49Z</updated>
    <published>2013-07-18T04:06:49Z</published>
    <title>Characterizing traits of coordination</title>
    <summary>  How can one recognize coordination languages and technologies? As this report
shows, the common approach that contrasts coordination with computation is
intellectually unsound: depending on the selected understanding of the word
"computation", it either captures too many or too few programming languages.
Instead, we argue for objective criteria that can be used to evaluate how well
programming technologies offer coordination services. Of the various criteria
commonly used in this community, we are able to isolate three that are strongly
characterizing: black-box componentization, which we had identified previously,
but also interface extensibility and customizability of run-time optimization
goals. These criteria are well matched by Intel's Concurrent Collections and
AstraKahn, and also by OpenCL, POSIX and VMWare ESX.
</summary>
    <author>
      <name>Raphael 'kena' Poss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 3 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1307.4827v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.4827v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.5277v1</id>
    <updated>2013-07-19T16:38:25Z</updated>
    <published>2013-07-19T16:38:25Z</published>
    <title>Formalisation of the lambda aleph Runtime</title>
    <summary>  In previous work we describe a novel approach to dependent typing based on a
multivalued term language. In this technical report we formalise the runtime, a
kind of operational semantics, for that language. We describe a fairly
comprehensive core language, and then give a small-step operational semantics
based on an abstract machine. Errors are explicit in the semantics. We also
prove several simple properties: that every non-terminated machine state steps
to something and that reduction is deterministic once input is fixed.
</summary>
    <author>
      <name>Neal Glew</name>
    </author>
    <author>
      <name>Tim Sweeney</name>
    </author>
    <author>
      <name>Leaf Petersen</name>
    </author>
    <link href="http://arxiv.org/abs/1307.5277v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.5277v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.7849v1</id>
    <updated>2013-07-30T07:23:59Z</updated>
    <published>2013-07-30T07:23:59Z</published>
    <title>Proceedings Sixth Workshop on Intersection Types and Related Systems</title>
    <summary>  This volume contains the proceedings of the Sixth Workshop on Intersection
Types and Related Systems (ITRS 2012). The workshop was held in Dubrovnik
(Croatia) on June 29th, 2012, affiliated to Twenty-Seventh Annual ACM/IEEE
Symposium on Logic in Computer Science (LICS 2012). The ITRS workshop aims to
bring together researchers working on both the theory and practical
applications of systems based on intersection types and related approaches
(e.g., union types, refinement types, behavioural types, recursive types, and
so on).
</summary>
    <author>
      <name>Stéphane Graham-Lengrand</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CNRS - École Polytechnique</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Paolini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.121</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.121" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 121, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.7849v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.7849v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1, D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1307.8207v1</id>
    <updated>2013-07-31T03:24:46Z</updated>
    <published>2013-07-31T03:24:46Z</published>
    <title>Reconciling positional and nominal binding</title>
    <summary>  We define an extension of the simply-typed lambda calculus where two
different binding mechanisms, by position and by name, nicely coexist. In the
former, as in standard lambda calculus, the matching between parameter and
argument is done on a positional basis, hence alpha-equivalence holds, whereas
in the latter it is done on a nominal basis. The two mechanisms also
respectively correspond to static binding, where the existence and type
compatibility of the argument are checked at compile-time, and dynamic binding,
where they are checked at run-time.
</summary>
    <author>
      <name>Davide Ancona</name>
    </author>
    <author>
      <name>Paola Giannini</name>
    </author>
    <author>
      <name>Elena Zucca</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.121.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.121.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2012, arXiv:1307.7849</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 121, 2013, pp. 81-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1307.8207v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1307.8207v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.3938v1</id>
    <updated>2013-08-19T07:15:23Z</updated>
    <published>2013-08-19T07:15:23Z</published>
    <title>Efficiently Retrieving Function Dependencies in the Linux Kernel Using
  XSB</title>
    <summary>  In this paper we investigate XSB-Prolog as a static analysis engine for data
represented by medium-sized graphs. We use XSB-Prolog to automatically identify
function dependencies in the Linux Kernel---queries that are difficult to
implement efficiently in a commodity database and that developers often have to
identify manually. This project illustrates that Prolog systems are ideal for
building tools for use in other disciplines that require sophisticated
inferences, because Prolog is both declarative and can efficiently implement
complex problem specifications through tabling and indexing.
</summary>
    <author>
      <name>Spyros Hadjichristodoulou</name>
    </author>
    <author>
      <name>Donald E. Porter</name>
    </author>
    <author>
      <name>David S. Warren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of WLPE 2013 proceedings (arXiv:1308.2055)</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.3938v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.3938v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.4452v4</id>
    <updated>2019-01-11T06:51:07Z</updated>
    <published>2013-08-21T00:13:32Z</published>
    <title>A New Statement for Selection and Exception Handling in Imperative
  Languages</title>
    <summary>  Diverse selection statements -- if-then-else, switch and try-catch -- are
commonly used in modern programming languages. To make things simple, we
propose a unifying statement for selection. This statement is of the form
seqor(G_1,...,G_n) where each $G_i$ is a statement. It has a a simple
semantics: sequentially choose the first successful statement $G_i$ and then
proceeds with executing $G_i$. Examples will be provided for this statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages. We add the notion of negative exception handling</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.4452v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.4452v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.4815v2</id>
    <updated>2013-08-23T09:02:41Z</updated>
    <published>2013-08-22T10:14:43Z</published>
    <title>Machine Code Optimization - Improving Executable Object Code</title>
    <summary>  This dissertation explores classes of compiler optimization techniques that
are applicable late in the compilation process, after all executable code for a
program has been linked. I concentrate on techniques which, for various
reasons, cannot be applied earlier in the compilation process. In addition to a
theoretical treatment of this class of optimization techniques, this
dissertation reports on an implementation of these techniques in a production
environment. I describe the details of the implementation which allows these
techniques to be re-targeted easily and report on improvements gained when
optimizing production software.
</summary>
    <author>
      <name>Clinton F. Goss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report #246, Courant Institute of Mathematical Sciences,
  New York University. Initially published June 1986; Revised August 22, 2013.
  41 pages, 9 figures, 7 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.4815v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.4815v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1308.6096v1</id>
    <updated>2013-08-28T08:59:41Z</updated>
    <published>2013-08-28T08:59:41Z</published>
    <title>Micro Spitbol</title>
    <summary>  A compact version of MACRO SPITBOL, a compiler/ interpreter for a variant of
SNOBOL4, has been developed for use on microcomputer systems. The techniques
for producing an implementation are largely automatic in order to preserve the
integrity and portability of the SPITBOL system. These techniques are discussed
along with a description of an initial implementation on a 65K byte
minicomputer. An interesting theoretical problem which arises when using
procedures which compact the interpretive object code is also analyzed.
</summary>
    <author>
      <name>Robert B. K. Dewar</name>
    </author>
    <author>
      <name>Martin Charles Golumbic</name>
    </author>
    <author>
      <name>Clinton F. Goss</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Initially published October 1979; Revised August 28, 2013. 8 pages, 3
  figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1308.6096v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1308.6096v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N20" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1261v1</id>
    <updated>2013-09-05T08:04:31Z</updated>
    <published>2013-09-05T08:04:31Z</published>
    <title>Proving termination of evaluation for System F with control operators</title>
    <summary>  We present new proofs of termination of evaluation in reduction semantics
(i.e., a small-step operational semantics with explicit representation of
evaluation contexts) for System F with control operators. We introduce a
modified version of Girard's proof method based on reducibility candidates,
where the reducibility predicates are defined on values and on evaluation
contexts as prescribed by the reduction semantics format. We address both
abortive control operators (callcc) and delimited-control operators (shift and
reset) for which we introduce novel polymorphic type systems, and we consider
both the call-by-value and call-by-name evaluation strategies.
</summary>
    <author>
      <name>Małgorzata Biernacka</name>
    </author>
    <author>
      <name>Dariusz Biernacki</name>
    </author>
    <author>
      <name>Sergueï Lenglet</name>
    </author>
    <author>
      <name>Marek Materzok</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.127.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.127.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings COS 2013, arXiv:1309.0924</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 127, 2013, pp. 15-29</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.1261v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1261v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1, F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.1307v1</id>
    <updated>2013-09-05T10:48:52Z</updated>
    <published>2013-09-05T10:48:52Z</published>
    <title>C++11 -- idea r-wartości i przenoszenia</title>
    <summary>  This paper presents a review of some new futures introduced to C++ language
by ISO/IEC 14882:2011 standard (known as C++11). It describes the ideas of
r-values and move constructors.
  ----
  Niniejszy artyku{\l} jest jednym z serii artyku{\l}\'ow w kt\'orych zawarto
przegl{\ka}d nowych element\'ow j{\ke}zyka C++ wprowadzonych przez standard
ISO/IEC 14882:2011, znany pod nazw{\ka} C++11. W artykule przedstawiono nowe
mo\.zliwo\'sci zwi{\ka}zane z przekazywaniem parametr\'ow i pisaniem
konstruktor\'ow. Zawarto w nim dok{\l}adne om\'owienie idei r-warto\'sci i
przenoszenia obiekt\'ow.
</summary>
    <author>
      <name>Piotr Beling</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages, in Polish</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.1307v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.1307v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.3919v1</id>
    <updated>2013-09-16T11:52:40Z</updated>
    <published>2013-09-16T11:52:40Z</published>
    <title>Environmental Bisimulations for Delimited-Control Operators</title>
    <summary>  We present a theory of environmental bisimilarity for the delimited-control
operators {\it shift} and {\it reset}. We consider two different notions of
contextual equivalence: one that does not require the presence of a top-level
control delimiter when executing tested terms, and another one, fully
compatible with the original CPS semantics of shift and reset, that does. For
each of them, we develop sound and complete environmental bisimilarities, and
we discuss up-to techniques.
</summary>
    <author>
      <name>Dariusz Biernacki</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Nancy - Grand Est / LORIA</arxiv:affiliation>
    </author>
    <author>
      <name>Sergueï Lenglet</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Nancy - Grand Est / LORIA</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Long version of the corresponding APLAS13 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1309.3919v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.3919v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.4557v1</id>
    <updated>2013-09-18T07:26:07Z</updated>
    <published>2013-09-18T07:26:07Z</published>
    <title>Semantics, Abstract Interpretation, and Reasoning about Programs: Essays
  Dedicated to David A. Schmidt on the Occasion of his Sixtieth Birthday</title>
    <summary>  This Liber Amicorum is a collection of essays ranging from personal memories
to technical contributions. It is a tribute to Dave Schmidt and his career, and
was composed at the occasion of his sixtieth birthday.
</summary>
    <author>
      <name>Anindya Banerjee</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IMDEA Software Institute</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Danvy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Aarhus University</arxiv:affiliation>
    </author>
    <author>
      <name>Kyung-Goo Doh</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Hanyang University</arxiv:affiliation>
    </author>
    <author>
      <name>John Hatcliff</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Kansas State University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.4557v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.4557v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5130v1</id>
    <updated>2013-09-20T01:43:16Z</updated>
    <published>2013-09-20T01:43:16Z</published>
    <title>A Comparison of Well-Quasi Orders on Trees</title>
    <summary>  Well-quasi orders such as homeomorphic embedding are commonly used to ensure
termination of program analysis and program transformation, in particular
supercompilation.
  We compare eight well-quasi orders on how discriminative they are and their
computational complexity. The studied well-quasi orders comprise two very
simple examples, two examples from literature on supercompilation and four new
proposed by the author.
  We also discuss combining several well-quasi orders to get well-quasi orders
of higher discriminative power. This adds 19 more well-quasi orders to the
list.
</summary>
    <author>
      <name>Torben Æ. Mogensen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DIKU, University of Copenhagen, Denmark</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 30-40</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5130v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5130v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="E.1; F.2.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5132v1</id>
    <updated>2013-09-20T01:43:32Z</updated>
    <published>2013-09-20T01:43:32Z</published>
    <title>Notions of Monad Strength</title>
    <summary>  Over the past two decades the notion of a strong monad has found wide
applicability in computing. Arising out of a need to interpret products in
computational and semantic settings, different approaches to this concept have
arisen. In this paper we introduce and investigate the connections between
these approaches and also relate the results to monad composition. We also
introduce new methods for checking and using the required laws associated with
such compositions, as well as provide examples illustrating problems and issues
that arise.
</summary>
    <author>
      <name>Philip Mulry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Colgate University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 67-83</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5132v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5132v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5137v1</id>
    <updated>2013-09-20T01:44:04Z</updated>
    <published>2013-09-20T01:44:04Z</published>
    <title>Online partial evaluation of sheet-defined functions</title>
    <summary>  We present a spreadsheet implementation, extended with sheet-defined
functions, that allows users to define functions using only standard
spreadsheet concepts such as cells, formulas and references, requiring no new
syntax. This implements an idea proposed by Peyton-Jones and others.
  As the main contribution of this paper, we then show how to add an online
partial evaluator for such sheet-defined functions. The result is a
higher-order functional language that is dynamically typed, in keeping with
spreadsheet traditions, and an interactive platform for function definition and
function specialization.
  We describe an implementation of these ideas, present some performance data
from microbenchmarks, and outline desirable improvements and extensions.
</summary>
    <author>
      <name>Peter Sestoft</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IT University of Copenhagen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 136-160</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5137v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5137v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5144v1</id>
    <updated>2013-09-20T01:45:17Z</updated>
    <published>2013-09-20T01:45:17Z</published>
    <title>A Simple Semantics and Static Analysis for Stack Inspection</title>
    <summary>  The Java virtual machine and the .NET common language runtime feature an
access control mechanism specified operationally in terms of run-time stack
inspection. We give a denotational semantics in "eager" form, and show that it
is equivalent to the "lazy" semantics using stack inspection. We give a static
analysis of safety, i.e., the absence of security errors, that is simpler than
previous proposals. We identify several program transformations that can be
used to remove run-time checks. We give complete, detailed proofs for safety of
the analysis and for the transformations, exploiting compositionality of the
eager semantics.
</summary>
    <author>
      <name>Anindya Banerjee</name>
    </author>
    <author>
      <name>David A. Naumann</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.17</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.17" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 284-308</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5144v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5144v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5147v1</id>
    <updated>2013-09-20T01:45:44Z</updated>
    <published>2013-09-20T01:45:44Z</published>
    <title>A short note on Simulation and Abstraction</title>
    <summary>  This short note is written in celebration of David Schmidt's sixtieth
birthday. He has now been active in the program analysis research community for
over thirty years and we have enjoyed many interactions with him. His work on
characterising simulations between Kripke structures using Galois connections
was particularly influential in our own work on using probabilistic abstract
interpretation to study Larsen and Skou's notion of probabilistic bisimulation.
We briefly review this work and discuss some recent applications of these ideas
in a variety of different application areas.
</summary>
    <author>
      <name>Chris Hankin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.20</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.20" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 337-340</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1309.5149v1</id>
    <updated>2013-09-20T01:46:06Z</updated>
    <published>2013-09-20T01:46:06Z</published>
    <title>Pretty-big-step-semantics-based Certified Abstract Interpretation
  (Preliminary version)</title>
    <summary>  We present a technique for deriving semantic program analyses from a natural
semantics specification of the programming language. The technique is based on
a particular kind of semantics called pretty-big-step semantics. We present a
pretty-big-step semantics of a language with simple objects called O'While and
specify a series of instrumentations of the semantics that explicitates the
flows of values in a program. This leads to a semantics-based dependency
analysis, at the core, e.g., of tainting analysis in software security. The
formalization has been realized with the Coq proof assistant.
</summary>
    <author>
      <name>Martin Bodin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">ENS Lyon and Inria</arxiv:affiliation>
    </author>
    <author>
      <name>Thomas Jensen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Inria</arxiv:affiliation>
    </author>
    <author>
      <name>Alan Schmitt</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Inria</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.129.23</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.129.23" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Festschrift for Dave Schmidt, arXiv:1309.4557</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 129, 2013, pp. 360-383</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1309.5149v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1309.5149v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.3473v1</id>
    <updated>2013-10-13T12:28:54Z</updated>
    <published>2013-10-13T12:28:54Z</published>
    <title>A Domain-Specific Language for Discrete Mathematics</title>
    <summary>  This paper discusses a Domain Specific Language (DSL) that has been developed
to enable implementation of concepts of discrete mathematics. A library of data
types and functions provides functionality which is frequently required by
users. Covering the areas of Mathematical Logic, Set Theory, Functions, Graph
Theory, Number Theory, Linear Algebra and Combinatorics, the language's syntax
is close to the actual notation used in the specific fields.
</summary>
    <author>
      <name>Rohit Jha</name>
    </author>
    <author>
      <name>Alfy Samuel</name>
    </author>
    <author>
      <name>Ashmee Pawar</name>
    </author>
    <author>
      <name>M. Kiruthika</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5120/12036-7257</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5120/12036-7257" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">International Journal of Computer Applications 70(15):6-19, May
  2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1310.3473v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.3473v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1310.7449v1</id>
    <updated>2013-10-28T15:08:28Z</updated>
    <published>2013-10-28T15:08:28Z</published>
    <title>Deadlock detection in linear recursive programs</title>
    <summary>  Deadlock detection in recursive programs that admit dynamic resource creation
is extremely complex and solutions either give imprecise answers or do not
scale.
  We define an algorithm for detecting deadlocks of "linear recursive programs"
of a basic model. The theory that underpins the algorithm is a generalization
of the theory of permutations of names to so-called "mutations", which
transform tuples by introducing duplicates and fresh names.
  Our algorithm realizes the back-end of deadlock analyzers for object-oriented
programming languages, once the association programs/basic-model-programs has
been defined as front-end.
</summary>
    <author>
      <name>Elena Giachino</name>
    </author>
    <author>
      <name>Cosimo Laneve</name>
    </author>
    <link href="http://arxiv.org/abs/1310.7449v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1310.7449v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68Q85" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2; F.1.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.0864v1</id>
    <updated>2013-11-04T15:32:51Z</updated>
    <published>2013-11-04T15:32:51Z</published>
    <title>Two automated techniques for analyzing and debugging Mpi-based programs</title>
    <summary>  Message Passing Interface (MPI) is the most commonly used paradigm in writing
parallel programs since it can be employed not only within a single processing
node but also across several connected ones. Data flow analysis concepts,
techniques and tools are needed to understand and analyze MPI-based programs to
detect bugs arise in these programs. In this paper we propose two automated
techniques to analyze and debug MPI-based programs source codes.
</summary>
    <author>
      <name>Alaa Ismail Elnashar</name>
    </author>
    <author>
      <name>Sultan Aljahdali</name>
    </author>
    <author>
      <name>Mosaid Al Sadhan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1311.0731</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.0864v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.0864v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.5810v1</id>
    <updated>2013-11-22T16:50:48Z</updated>
    <published>2013-11-22T16:50:48Z</published>
    <title>Deciding $k$CFA is complete for EXPTIME</title>
    <summary>  We give an exact characterization of the computational complexity of the
$k$CFA hierarchy. For any $k &gt; 0$, we prove that the control flow decision
problem is complete for deterministic exponential time. This theorem validates
empirical observations that such control flow analysis is intractable. It also
provides more general insight into the complexity of abstract interpretation.
</summary>
    <author>
      <name>David Van Horn</name>
    </author>
    <author>
      <name>Harry G. Mairson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appeared in The 13th ACM SIGPLAN International Conference on
  Functional Programming (ICFP'08), Victoria, British Columbia, Canada,
  September 2008</arxiv:comment>
    <link href="http://arxiv.org/abs/1311.5810v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.5810v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1311.7242v1</id>
    <updated>2013-11-28T09:15:55Z</updated>
    <published>2013-11-28T09:15:55Z</published>
    <title>Programming with Permissions in Mezzo</title>
    <summary>  We present Mezzo, a typed programming language of ML lineage. Mezzo is
equipped with a novel static discipline of duplicable and affine permissions,
which controls aliasing and ownership. This rules out certain mistakes,
including representation exposure and data races, and enables new idioms, such
as gradual initialization, memory re-use, and (type)state changes. Although the
core static discipline disallows sharing a mutable data structure, Mezzo offers
several ways of working around this restriction, including a novel dynamic
ownership control mechanism which we dub "adoption and abandon".
</summary>
    <author>
      <name>Jonathan Protzenko</name>
    </author>
    <author>
      <name>François Pottier</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2500365.2500598</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2500365.2500598" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ICFP 2013, Proceedings of the 18th ACM SIGPLAN international
  conference on Functional programming</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1311.7242v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1311.7242v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0078v1</id>
    <updated>2013-11-30T08:48:02Z</updated>
    <published>2013-11-30T08:48:02Z</published>
    <title>Hop and HipHop : Multitier Web Orchestration</title>
    <summary>  Rich applications merge classical computing, client-server concurrency,
web-based interfaces, and the complex time- and event-based reactive
programming found in embedded systems. To handle them, we extend the Hop web
programming platform by HipHop, a domain-specific language dedicated to
event-based process orchestration. Borrowing the synchronous reactive model of
Esterel, HipHop is based on synchronous concurrency and preemption primitives
that are known to be key components for the modular design of complex reactive
behaviors. HipHop departs from Esterel by its ability to handle the dynamicity
of Web applications, thanks to the reflexivity of Hop. Using a music player
example, we show how to modularly build a non-trivial Hop application using
HipHop orchestration code.
</summary>
    <author>
      <name>Gérard Berry</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA Sophia Antipolis</arxiv:affiliation>
    </author>
    <author>
      <name>Manuel Serrano</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">International Conference on Distributed Computing and Internet
  Technology (2014)</arxiv:comment>
    <link href="http://arxiv.org/abs/1312.0078v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0078v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0138v1</id>
    <updated>2013-11-30T18:43:31Z</updated>
    <published>2013-11-30T18:43:31Z</published>
    <title>The bitwise operations related to a fast sorting algorithm</title>
    <summary>  In the work we discuss the benefit of using bitwise operations in
programming. Some interesting examples in this respect have been shown. What is
described in detail is an algorithm for sorting an integer array with the
substantial use of the bitwise operations. Besides its correctness we strictly
prove that the described algorithm works in time O(n). In the work during the
realisation of each of the examined algorithms we use the apparatus of the
object-oriented programming with the syntax and the semantics of the
programming language C++.
</summary>
    <author>
      <name>Krasimir Yordzhev</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">(IJACSA) International Journal of Advanced Computer Science and
  Applications, Vol. 4, No. 9, 2013</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.0138v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0138v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.0342v1</id>
    <updated>2013-12-02T06:59:06Z</updated>
    <published>2013-12-02T06:59:06Z</published>
    <title>The Petri-Nets to Statecharts Transformation Case</title>
    <summary>  This paper describes a case study for the sixth Transformation Tool Contest.
The case is based on a mapping from Petri-Nets to statecharts (i.e., from flat
process models to hierarchical ones). The case description separates a simple
mapping phase from a phase that involves the step by step destruction Petri-Net
elements and the corresponding construction of a hierarchy of statechart
elements. Although the focus of this case study is on the comparison of the
runtime performance of solutions, we also include correctness tests as well as
bonus criteria for evaluating transformation language and tool features.
</summary>
    <author>
      <name>Pieter Van Gorp</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Eindhoven University of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Louis M. Rose</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of York</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.135.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.135.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TTC 2013, arXiv:1311.7536</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 135, 2013, pp. 16-31</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.0342v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.0342v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.2;F.4.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2334v3</id>
    <updated>2014-09-11T19:51:32Z</updated>
    <published>2013-12-09T08:13:19Z</published>
    <title>Inferring Algebraic Effects</title>
    <summary>  We present a complete polymorphic effect inference algorithm for an ML-style
language with handlers of not only exceptions, but of any other algebraic
effect such as input &amp; output, mutable references and many others. Our main aim
is to offer the programmer a useful insight into the effectful behaviour of
programs. Handlers help here by cutting down possible effects and the resulting
lengthy output that often plagues precise effect systems. Additionally, we
present a set of methods that further simplify the displayed types, some even
by deliberately hiding inferred information from the programmer.
</summary>
    <author>
      <name>Matija Pretnar</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Ljubljana</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-10(3:21)2014</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-10(3:21)2014" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 10, Issue 3 (September
  12, 2014) lmcs:1004</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2334v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2334v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2698v1</id>
    <updated>2013-12-10T08:03:18Z</updated>
    <published>2013-12-10T08:03:18Z</published>
    <title>From Lock Freedom to Progress Using Session Types</title>
    <summary>  Inspired by Kobayashi's type system for lock freedom, we define a behavioral
type system for ensuring progress in a language of binary sessions. The key
idea is to annotate actions in session types with priorities representing the
urgency with which such actions must be performed and to verify that processes
perform such actions with the required priority. Compared to related systems
for session-based languages, the presented type system is relatively simpler
and establishes progress for a wider range of processes.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 3-19</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2698v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2698v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.3; D.3.3; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2702v1</id>
    <updated>2013-12-10T08:03:57Z</updated>
    <published>2013-12-10T08:03:57Z</published>
    <title>Coinductive Big-Step Semantics for Concurrency</title>
    <summary>  In a paper presented at SOS 2010, we developed a framework for big-step
semantics for interactive input-output in combination with divergence, based on
coinductive and mixed inductive-coinductive notions of resumptions, evaluation
and termination-sensitive weak bisimilarity. In contrast to standard
inductively defined big-step semantics, this framework handles divergence
properly; in particular, runs that produce some observable effects and then
diverge, are not "lost". Here we scale this approach for shared-variable
concurrency on a simple example language. We develop the metatheory of our
semantics in a constructive logic.
</summary>
    <author>
      <name>Tarmo Uustalu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 63-78</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2702v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2702v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.1.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1312.2704v1</id>
    <updated>2013-12-10T08:04:18Z</updated>
    <published>2013-12-10T08:04:18Z</published>
    <title>Session Types Go Dynamic or How to Verify Your Python Conversations</title>
    <summary>  This paper presents the first implementation of session types in a
dynamically-typed language - Python. Communication safety of the whole system
is guaranteed at runtime by monitors that check the execution traces comply
with an associated protocol. Protocols are written in Scribble, a choreography
description language based on multiparty session types, with addition of logic
formulas for more precise behaviour properties. The presented framework
overcomes the limitations of previous works on the session types where all
endpoints should be statically typed so that they do not permit
interoperability with untyped participants. The advantages, expressiveness and
performance of dynamic protocol checking are demonstrated through use case and
benchmarks.
</summary>
    <author>
      <name>Rumyana Neykova</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.137.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.137.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2013, arXiv:1312.2218</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 137, 2013, pp. 95-102</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1312.2704v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1312.2704v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1402.2949v1</id>
    <updated>2014-02-10T21:35:37Z</updated>
    <published>2014-02-10T21:35:37Z</published>
    <title>A Programming Language Oriented Approach to Computability</title>
    <summary>  The field of computability and complexity was, where computer science sprung
from. Turing, Church, and Kleene all developed formalisms that demonstrated
what they held "intuitively computable". The times change however and today's
(aspiring) computer scientists are less proficient in building automata or
composing functions and are much more native to the world of programming
languages. This article will try to introduce typical concepts of computability
theory and complexity in a form more fitted for a modern developer. It is
mostly based on \cite{jones}, but takes input from other sources to provide
examples, additional information, etc.
</summary>
    <author>
      <name>Aaron Karper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Bachelor thesis at the University of Bern, supervised by Professor
  Dr. Thomas Strahm</arxiv:comment>
    <link href="http://arxiv.org/abs/1402.2949v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1402.2949v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.0073v1</id>
    <updated>2014-04-01T00:36:54Z</updated>
    <published>2014-04-01T00:36:54Z</published>
    <title>General dynamic recovery for compensating CSP</title>
    <summary>  Compensation is a technique to roll-back a system to a consistent state in
case of failure. Recovery mechanisms for compensating calculi specify the order
of execution of compensation sequences. Dynamic recovery means that the order
of execution is determined at runtime. In this paper, we define an extension of
Compensating CSP, called DEcCSP, with general dynamic recovery. We provide a
formal, operational semantics for the calculus, and illustrate its expressive
power with a case study. In contrast with previous versions of Compensating
CSP, DEcCSP provides mechanisms to replace or discard compensations at runtime.
Additionally, we bring back to DEcCSP standard CSP operators that are not
available in other compensating CSP calculi, and introduce channel
communication.
</summary>
    <author>
      <name>Abeer S. Al-Humaimeedy</name>
    </author>
    <author>
      <name>Maribel Fernández</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.143.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.143.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DCM 2012, arXiv:1403.7579</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 143, 2014, pp. 3-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1404.0073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.0073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1404.3407v1</id>
    <updated>2014-04-13T18:20:40Z</updated>
    <published>2014-04-13T18:20:40Z</published>
    <title>Annotated imports</title>
    <summary>  Presented simple extensions to scala language related to import statements:
exported imports, which provide ability to reuse sequence of import clauses in
composable form and default rewriters, which provide mechanism for pluggable
macro-based AST transformation of overall compilation unit, activated by import
of library object. Using these facilities not only allows more compact code, it
prevents application programmer from producing certain type of errors too and
allows to implement local language extension as libraries on top of standard
compiler. Part of discussed extensions is submitted to scala language committee
as pre-sip \cite{ai-presip} and can be used as first step for refining imports
semantics in the future version of scala language.
</summary>
    <author>
      <name>Ruslan Shevchenko</name>
    </author>
    <link href="http://arxiv.org/abs/1404.3407v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1404.3407v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.2538v1</id>
    <updated>2014-05-11T14:45:07Z</updated>
    <published>2014-05-11T14:45:07Z</published>
    <title>Combinatorial Search With Picat</title>
    <summary>  Picat, a new member of the logic programming family, follows a different
doctrine than Prolog in offering the core logic programming concepts: arrays
and maps as built-in data types; implicit pattern matching with explicit
unification and explicit non-determinism; functions for deterministic
computations; and loops for convenient scripting and modeling purposes. Picat
provides facilities for solving combinatorial search problems, including a
common interface with CP, SAT, and MIP solvers, tabling for dynamic
programming, and a module for planning. Picat's planner module, which is
implemented by the use of tabling, has produced surprising and encouraging
results. Thanks to term-sharing and resource-bounded tabled search, Picat
overwhelmingly outperforms the cutting-edge ASP and PDDL planners on the
planning benchmarks used in recent ASP competitions.
</summary>
    <author>
      <name>Neng-Fa Zhou</name>
    </author>
    <link href="http://arxiv.org/abs/1405.2538v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.2538v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.2564v1</id>
    <updated>2014-05-11T18:39:26Z</updated>
    <published>2014-05-11T18:39:26Z</published>
    <title>Towards an Efficient Prolog System by Code Introspection</title>
    <summary>  To appear in Theory and Practice of Logic Programming (TPLP). Several Prolog
interpreters are based on the Warren Abstract Machine (WAM), an elegant model
to compile Prolog programs. In order to improve the performance several
strategies have been proposed, such as: optimize the selection of clauses,
specialize the unification, global analysis, native code generation and
tabling. This paper proposes a different strategy to implement an efficient
Prolog System, the creation of specialized emulators on the fly. The proposed
strategy was implemented and evaluated at YAP Prolog System, and the
experimental evaluation showed interesting results.
</summary>
    <author>
      <name>George Souza Oliveira</name>
    </author>
    <author>
      <name>Anderson Faustino da Silva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.2564v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.2564v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3791v1</id>
    <updated>2014-05-15T10:27:52Z</updated>
    <published>2014-05-15T10:27:52Z</published>
    <title>On contour representation of two dimensional patterns</title>
    <summary>  Two-dimensional patterns are used in many research areas in computer science,
ranging from image processing to specification and verification of complex
software systems (via scenarios). The contribution of this paper is twofold.
First, we present the basis of a new formal representation of two-dimensional
patterns based on contours and their compositions. Then, we present efficient
algorithms to verify correctness of the contour-representation. Finally, we
briefly discuss possible applications, in particular using them as a basic
instrument in developing software tools for handling two dimensional words.
</summary>
    <author>
      <name>Iulia Teodora Banu-Demergian</name>
    </author>
    <author>
      <name>Gheorghe Stefanescu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in: Carpathian J. Math., 2014</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3791v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3791v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.3795v1</id>
    <updated>2014-05-15T10:48:10Z</updated>
    <published>2014-05-15T10:48:10Z</published>
    <title>Logic Programming as Scripting Language for Bots in Computer Games --
  Research Overview</title>
    <summary>  This publication is to present a summary of research (referred as Klabs -
http://www.kappalabs.org) carried out in author's Ph.D studies on topic of
application of Logic Programming as scripting language for virtual character
behavior control in First Person Shooter (FPS) games. The research goal is to
apply reasoning and knowledge representation techniques to create character
behavior, which results in increased players' engagement. An extended abstract
/ full version of a paper accepted to be presented at the Doctoral Consortium
of the 30th International Conference on Logic Programming (ICLP 2014), July
19-22, Vienna, Austria
</summary>
    <author>
      <name>Grzegorz Jaśkiewicz</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.3795v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.3795v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1405.5590v2</id>
    <updated>2016-10-23T19:45:46Z</updated>
    <published>2014-05-22T01:50:47Z</published>
    <title>Language to Specify Syntax-Guided Synthesis Problems</title>
    <summary>  We present a language to specify syntax guided synthesis (SyGuS) problems.
Syntax guidance is a prominent theme in contemporary program synthesis
approaches, and SyGuS was first described in [1]. This paper describes
concretely the input format of a SyGuS solver.
  [1] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. Syntax-guided synthesis. In FMCAD, pages 1--17,
2013.
</summary>
    <author>
      <name>Mukund Raghothaman</name>
    </author>
    <author>
      <name>Abhishek Udupa</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Fixed small typo in the SyGuS grammar specification pointed out by
  Sergey Mechtaev</arxiv:comment>
    <link href="http://arxiv.org/abs/1405.5590v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1405.5590v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1393v1</id>
    <updated>2014-06-05T14:09:30Z</updated>
    <published>2014-06-05T14:09:30Z</published>
    <title>Interclausal Logic Variables</title>
    <summary>  Unification of logic variables instantly connects present and future
observations of their value, independently of their location in the data areas
of the runtime system. The paper extends this property to "interclausal logic
variables", an easy to implement Prolog extension that supports instant global
information exchanges without dynamic database updates. We illustrate their
usefulness with two of algorithms, {\em graph coloring} and {\em minimum
spanning tree}. Implementations of interclausal variables as source-level
transformations and as abstract machine adaptations are given. To address the
need for globally visible chained transitions of logic variables we describe a
DCG-based program transformation that extends the functionality of interclausal
variables.
</summary>
    <author>
      <name>Paul Tarau</name>
    </author>
    <author>
      <name>Fahmida Hamid</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">to appear as a ICLP'14 technical contribution</arxiv:comment>
    <link href="http://arxiv.org/abs/1406.1393v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1393v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.1534v1</id>
    <updated>2014-06-05T22:07:03Z</updated>
    <published>2014-06-05T22:07:03Z</published>
    <title>Proceedings 5th Workshop on Mathematically Structured Functional
  Programming</title>
    <summary>  This volume contains the proceedings of the Fifth Workshop on Mathematically
Structured Functional Programming (MSFP 2014), taking place on 12 April, 2014
in Grenoble, France, as a satellite event of the European Joint Conferences on
Theory and Practice of Software, ETAPS 2014.
  MSFP is devoted to the derivation of functionality from structure. It
highlights concepts from algebra, semantics and type theory as they are
increasingly reflected in programming practice, especially functional
programming. As the range of papers presented in this year's workshop shows,
this continues to be a fruitful interface.
</summary>
    <author>
      <name>Paul Levy</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Birmingham</arxiv:affiliation>
    </author>
    <author>
      <name>Neel Krishnaswami</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Birmingham</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.1534v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.1534v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3; F.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2058v1</id>
    <updated>2014-06-09T03:29:29Z</updated>
    <published>2014-06-09T03:29:29Z</published>
    <title>Monad Transformers for Backtracking Search</title>
    <summary>  This paper extends Escardo and Oliva's selection monad to the selection monad
transformer, a general monadic framework for expressing backtracking search
algorithms in Haskell. The use of the closely related continuation monad
transformer for similar purposes is also discussed, including an implementation
of a DPLL-like SAT solver with no explicit recursion. Continuing a line of work
exploring connections between selection functions and game theory, we use the
selection monad transformer with the nondeterminism monad to obtain an
intuitive notion of backward induction for a certain class of nondeterministic
games.
</summary>
    <author>
      <name>Jules Hedges</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Queen Mary University of London</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2014, arXiv:1406.1534</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014, pp. 31-50</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.2058v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2058v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2062v1</id>
    <updated>2014-06-09T03:30:38Z</updated>
    <published>2014-06-09T03:30:38Z</published>
    <title>Categorical Semantics for Functional Reactive Programming with Temporal
  Recursion and Corecursion</title>
    <summary>  Functional reactive programming (FRP) makes it possible to express temporal
aspects of computations in a declarative way. Recently we developed two kinds
of categorical models of FRP: abstract process categories (APCs) and concrete
process categories (CPCs). Furthermore we showed that APCs generalize CPCs. In
this paper, we extend APCs with additional structure. This structure models
recursion and corecursion operators that are related to time. We show that the
resulting categorical models generalize those CPCs that impose an additional
constraint on time scales. This constraint boils down to ruling out
$\omega$-supertasks, which are closely related to Zeno's paradox of Achilles
and the tortoise.
</summary>
    <author>
      <name>Wolfgang Jeltsch</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">TTÜ Küberneetika Instituut</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.153.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.153.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2014, arXiv:1406.1534</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 153, 2014, pp. 127-142</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.2062v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2062v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.1.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.2121v1</id>
    <updated>2014-06-09T10:03:26Z</updated>
    <published>2014-06-09T10:03:26Z</published>
    <title>Constraint Handling Rules with Multiset Comprehension Patterns</title>
    <summary>  CHR is a declarative, concurrent and committed choice rule-based constraint
programming language. We extend CHR with multiset comprehension patterns,
providing the programmer with the ability to write multiset rewriting rules
that can match a variable number of constraints in the store. This enables
writing more readable, concise and declarative code for algorithms that
coordinate large amounts of data or require aggregate operations. We call this
extension $\mathit{CHR}^\mathit{cp}$. We give a high-level abstract semantics
of $\mathit{CHR}^\mathit{cp}$, followed by a lower-level operational semantics.
We then show the soundness of this operational semantics with respect to the
abstract semantics.
</summary>
    <author>
      <name>Edmund S. L. Lam</name>
    </author>
    <author>
      <name>Iliano Cervesato</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of CHR 2014 proceedings (arXiv:1406.1510)</arxiv:comment>
    <link href="http://arxiv.org/abs/1406.2121v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.2121v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.3479v1</id>
    <updated>2014-06-13T10:16:41Z</updated>
    <published>2014-06-13T10:16:41Z</published>
    <title>Sessions as Propositions</title>
    <summary>  Recently, Wadler presented a continuation-passing translation from a
session-typed functional language, GV, to a process calculus based on classical
linear logic, CP. However, this translation is one-way: CP is more expressive
than GV. We propose an extension of GV, called HGV, and give translations
showing that it is as expressive as CP. The new translations shed light both on
the original translation from GV to CP, and on the limitations in
expressiveness of GV.
</summary>
    <author>
      <name>Sam Lindley</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Edinburgh</arxiv:affiliation>
    </author>
    <author>
      <name>J. Garrett Morris</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Edinburgh</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.155.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.155.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2014, arXiv:1406.3313</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 155, 2014, pp. 9-16</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.3479v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.3479v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2;F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1406.3483v1</id>
    <updated>2014-06-13T10:17:23Z</updated>
    <published>2014-06-13T10:17:23Z</published>
    <title>Lightening Global Types</title>
    <summary>  Global session types prevent participants from waiting for never coming
messages. Some interactions take place just for the purpose of informing
receivers that some message will never arrive or the session is terminated. By
decomposing a big global type into several light global types, one can avoid
such kind of redundant interactions. Lightening global types gives us cleaner
global types, which keep all necessary communications. This work proposes a
framework which allows to easily decompose global types into light global
types, preserving the interaction sequences of the original ones but for
redundant interactions.
</summary>
    <author>
      <name>Tzu-chun Chen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Universita' di Torino, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.155.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.155.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2014, arXiv:1406.3313</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 155, 2014, pp. 38-46</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1406.3483v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1406.3483v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1407.3892v1</id>
    <updated>2014-07-15T06:40:59Z</updated>
    <published>2014-07-15T06:40:59Z</published>
    <title>Verified Subtyping with Traits and Mixins</title>
    <summary>  Traits allow decomposing programs into smaller parts and mixins are a form of
composition that resemble multiple inheritance. Unfortunately, in the presence
of traits, programming languages like Scala give up on subtyping relation
between objects. In this paper, we present a method to check subtyping between
objects based on entailment in separation logic. We implement our method as a
domain specific language in Scala and apply it on the Scala standard library.
We have verified that 67% of mixins used in the Scala standard library do
indeed conform to subtyping between the traits that are used to build them.
</summary>
    <author>
      <name>Asankhaya Sharma</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.156.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.156.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FSFMA 2014, arXiv:1407.1952</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 156, 2014, pp. 45-51</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1407.3892v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1407.3892v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.1458v1</id>
    <updated>2014-08-07T01:57:17Z</updated>
    <published>2014-08-07T01:57:17Z</published>
    <title>Distributive Laws and Decidable Properties of SOS Specifications</title>
    <summary>  Some formats of well-behaved operational specifications, correspond to
natural transformations of certain types (for example, GSOS and coGSOS laws).
These transformations have a common generalization: distributive laws of monads
over comonads. We prove that this elegant theoretical generalization has
limited practical benefits: it does not translate to any concrete rule format
that would be complete for specifications that contain both GSOS and coGSOS
rules. This is shown for the case of labeled transition systems and
deterministic stream systems.
</summary>
    <author>
      <name>Bartek Klin</name>
    </author>
    <author>
      <name>Beata Nachyła</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.160.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.160.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS 2014, arXiv:1408.1271</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 160, 2014, pp. 79-93</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1408.1458v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.1458v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.1754v1</id>
    <updated>2014-08-08T03:11:41Z</updated>
    <published>2014-08-08T03:11:41Z</published>
    <title>A Partial-Order Approach to Array Content Analysis</title>
    <summary>  We present a parametric abstract domain for array content analysis. The
method maintains invariants for contiguous regions of the array, similar to the
methods of Gopan, Reps and Sagiv, and of Halbwachs and Peron. However, it
introduces a novel concept of an array content graph, avoiding the need for an
up-front factorial partitioning step. The resulting analysis can be used with
arbitrary numeric relational abstract domains; we evaluate the domain on a
range of array manipulating program fragments.
</summary>
    <author>
      <name>Graeme Gange</name>
    </author>
    <author>
      <name>Jorge A. Navas</name>
    </author>
    <author>
      <name>Peter Schachte</name>
    </author>
    <author>
      <name>Harald Sondergaard</name>
    </author>
    <author>
      <name>Peter J. Stuckey</name>
    </author>
    <link href="http://arxiv.org/abs/1408.1754v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.1754v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.1; F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1408.5564v1</id>
    <updated>2014-08-24T05:47:04Z</updated>
    <published>2014-08-24T05:47:04Z</published>
    <title>Proceedings Third Workshop on Behavioural Types</title>
    <summary>  This volume contains the proceedings of BEAT 2014, the third Workshop on
Behavioural Types. The workshop took place in Rome, Italy, on September 1st
2014, as a satellite even of CONCUR 2014, the 25th International Conference on
Concurrency Theory.
  The aim of this workshop is to bring together researchers in all aspects of
behavioural type theory and its applications, in order to share results,
consolidate the community, and discover opportunities for new collaborations
and future directions.
</summary>
    <author>
      <name>Marco Carbone</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IT University of Copenhagen</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.162</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.162" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 162, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1408.5564v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1408.5564v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.05338v2</id>
    <updated>2015-11-15T15:34:03Z</updated>
    <published>2015-01-21T21:56:06Z</published>
    <title>Semantics for Locking Specifications</title>
    <summary>  To prevent concurrency errors, programmers need to obey a locking discipline.
Annotations that specify that discipline, such as Java's @GuardedBy, are
already widely used. Unfortunately, their semantics is expressed informally and
is consequently ambiguous. This article highlights such ambiguities and
formalizes the semantics of @GuardedBy in two alternative ways, building on an
operational semantics for a small concurrent fragment of a Java-like language.
It also identifies when such annotations are actual guarantees against data
races. Our work aids in understanding the annotations and supports the
development of sound formal tools that verify or infer such annotations.
</summary>
    <author>
      <name>Michael Ernst</name>
    </author>
    <author>
      <name>Damiano Macedonio</name>
    </author>
    <author>
      <name>Massimo Merro</name>
    </author>
    <author>
      <name>Fausto Spoto</name>
    </author>
    <link href="http://arxiv.org/abs/1501.05338v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.05338v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1501.05425v1</id>
    <updated>2015-01-22T08:45:10Z</updated>
    <published>2015-01-22T08:45:10Z</published>
    <title>Foundational Extensible Corecursion</title>
    <summary>  This paper presents a formalized framework for defining corecursive functions
safely in a total setting, based on corecursion up-to and relational
parametricity. The end product is a general corecursor that allows corecursive
(and even recursive) calls under well-behaved operations, including
constructors. Corecursive functions that are well behaved can be registered as
such, thereby increasing the corecursor's expressiveness. The metatheory is
formalized in the Isabelle proof assistant and forms the core of a prototype
tool. The corecursor is derived from first principles, without requiring new
axioms or extensions of the logic.
</summary>
    <author>
      <name>Jasmin Christian Blanchette</name>
    </author>
    <author>
      <name>Andrei Popescu</name>
    </author>
    <author>
      <name>Dmitriy Traytel</name>
    </author>
    <link href="http://arxiv.org/abs/1501.05425v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1501.05425v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.00693v1</id>
    <updated>2015-04-02T21:14:38Z</updated>
    <published>2015-04-02T21:14:38Z</published>
    <title>Comparative Studies of Six Programming Languages</title>
    <summary>  Comparison of programming languages is a common topic of discussion among
software engineers. Multiple programming languages are designed, specified, and
implemented every year in order to keep up with the changing programming
paradigms, hardware evolution, etc. In this paper we present a comparative
study between six programming languages: C++, PHP, C#, Java, Python, VB ; These
languages are compared under the characteristics of reusability, reliability,
portability, availability of compilers and tools, readability, efficiency,
familiarity and expressiveness.
</summary>
    <author>
      <name>Zakaria Alomari</name>
    </author>
    <author>
      <name>Oualid El Halimi</name>
    </author>
    <author>
      <name>Kaushik Sivaprasad</name>
    </author>
    <author>
      <name>Chitrang Pandit</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: text overlap with arXiv:1008.3434 by other authors</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.00693v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.00693v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.02621v1</id>
    <updated>2015-04-10T09:50:23Z</updated>
    <published>2015-04-10T09:50:23Z</published>
    <title>A Reference Interpreter for the Graph Programming Language GP 2</title>
    <summary>  GP 2 is an experimental programming language for computing by graph
transformation. An initial interpreter for GP 2, written in the functional
language Haskell, provides a concise and simply structured reference
implementation. Despite its simplicity, the performance of the interpreter is
sufficient for the comparative investigation of a range of test programs. It
also provides a platform for the development of more sophisticated
implementations.
</summary>
    <author>
      <name>Christopher Bak</name>
    </author>
    <author>
      <name>Glyn Faulkner</name>
    </author>
    <author>
      <name>Detlef Plump</name>
    </author>
    <author>
      <name>Colin Runciman</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.181.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.181.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GaM 2015, arXiv:1504.02448</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 181, 2015, pp. 48-64</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1504.02621v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.02621v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.03239v1</id>
    <updated>2015-04-13T16:14:43Z</updated>
    <published>2015-04-13T16:14:43Z</published>
    <title>Global Value Numbering: A Precise and Efficient Algorithm</title>
    <summary>  Global Value Numbering (GVN) is an important static analysis to detect
equivalent expressions in a program. We present an iterative data-flow analysis
GVN algorithm in SSA for the purpose of detecting total redundancies. The
central challenge is defining a join operation to detect equivalences at a join
point in polynomial time such that later occurrences of redundant expressions
could be detected. For this purpose, we introduce the novel concept of value
$\phi$-function. We claim the algorithm is precise and takes only polynomial
time.
</summary>
    <author>
      <name>Rekha R Pai</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages, 3 figures, an extended version to be submitted to journal</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.03239v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.03239v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1504.05372v1</id>
    <updated>2015-04-21T10:19:57Z</updated>
    <published>2015-04-21T10:19:57Z</published>
    <title>Inferring Program Transformations from Type Transformations for
  Partitioning of Ordered Sets</title>
    <summary>  In this paper I introduce a mechanism to derive program transforma- tions
from order-preserving transformations of vector types. The purpose of this work
is to allow automatic generation of correct-by-construction instances of
programs in a streaming data processing paradigm suitable for FPGA processing.
We show that for it is possible to automatically derive instances for programs
based on combinations of opaque element- processing functions combined using
foldl and map, purely from the type transformations.
</summary>
    <author>
      <name>Wim Vanderbauwhede</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This work is supported by the EPSRC through the TyTra project
  (EP/L00058X/1)</arxiv:comment>
    <link href="http://arxiv.org/abs/1504.05372v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1504.05372v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.00385v1</id>
    <updated>2015-07-01T22:14:45Z</updated>
    <published>2015-07-01T22:14:45Z</published>
    <title>Bounded Refinement Types</title>
    <summary>  We present a notion of bounded quantification for refinement types and show
how it expands the expressiveness of refinement typing by using it to develop
typed combinators for: (1) relational algebra and safe database access, (2)
Floyd-Hoare logic within a state transformer monad equipped with combinators
for branching and looping, and (3) using the above to implement a refined IO
monad that tracks capabilities and resource usage. This leap in expressiveness
comes via a translation to "ghost" functions, which lets us retain the
automated and decidable SMT based checking and inference that makes refinement
typing effective in practice.
</summary>
    <author>
      <name>Niki Vazou</name>
    </author>
    <author>
      <name>Alexander Bakst</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, International Conference on Functional Programming, ICFP
  2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.00385v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.00385v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.3; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.01656v1</id>
    <updated>2015-07-07T01:47:31Z</updated>
    <published>2015-07-07T01:47:31Z</published>
    <title>Languages for Mobile Agents</title>
    <summary>  Mobile agents represent a new model for network computing. Many different
languages have been used to implement mobile agents. The characteristics that
make a language useful for writing mobile agents are: (1) their support of
agent migration, (2) their support for agent-to-agent communication, (3) how
they allow agents to interact with local resources, (4) security mechanisms,
(5) execution efficiency, (6) language implementation across multiple
platforms, and (7) the language's ease of programming of the tasks mobile
agents perform.
</summary>
    <author>
      <name>Steve Versteeg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Honours Thesis. Department of Computer Science and Sofware
  Engineering, University of Melbourne. 1997</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.01656v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.01656v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.05454v1</id>
    <updated>2015-07-20T11:41:49Z</updated>
    <published>2015-07-20T11:41:49Z</published>
    <title>Concolic Testing in Logic Programming</title>
    <summary>  Software testing is one of the most popular validation techniques in the
software industry. Surprisingly, we can only find a few approaches to testing
in the context of logic programming. In this paper, we introduce a systematic
approach for dynamic testing that combines both concrete and symbolic
execution. Our approach is fully automatic and guarantees full path coverage
when it terminates. We prove some basic properties of our technique and
illustrate its practical usefulness through a prototype implementation.
</summary>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <author>
      <name>Étienne Payet</name>
    </author>
    <author>
      <name>Germán Vidal</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068415000332</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068415000332" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP),
  Proceedings of ICLP 2015</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 15 (2015) 711-725</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.05454v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.05454v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.06576v2</id>
    <updated>2018-02-14T21:18:28Z</updated>
    <published>2015-07-23T17:26:57Z</published>
    <title>Abstract Gringo</title>
    <summary>  This paper defines the syntax and semantics of the input language of the ASP
grounder GRINGO. The definition covers several constructs that were not
discussed in earlier work on the semantics of that language, including
intervals, pools, division of integers, aggregates with non-numeric values, and
lparse-style aggregate expressions. The definition is abstract in the sense
that it disregards some details related to representing programs by strings of
ASCII characters. It serves as a specification for GRINGO from Version 4.5 on.
</summary>
    <author>
      <name>Martin Gebser</name>
    </author>
    <author>
      <name>Amelia Harrison</name>
    </author>
    <author>
      <name>Roland Kaminski</name>
    </author>
    <author>
      <name>Vladimir Lifschitz</name>
    </author>
    <author>
      <name>Torsten Schaub</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068415000150</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068415000150" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 15 (2015) 449-463</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.06576v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.06576v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.06988v1</id>
    <updated>2015-07-24T18:26:21Z</updated>
    <published>2015-07-24T18:26:21Z</published>
    <title>A Binary Data Stream Scripting Language</title>
    <summary>  Any file is fundamentally a binary data stream. A practical solution was
achieved to interpret binary data stream. A new scripting language named Data
Format Scripting Language (DFSL) was developed to describe the physical layout
of the data in a structural, more intelligible way. On the basis of the
solution, a generic software application was implemented; it parses various
binary data streams according to their respective DFSL scripts and generates
human-readable result and XML document for data sharing. Our solution helps
eliminate the error-prone low-level programming, especially in the hardware
devices or network protocol development/debugging processes.
</summary>
    <author>
      <name>Lihua Wang</name>
    </author>
    <author>
      <name>Luz Fernando Capretz</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Transactions on Information Science and Applications,
  3(2):291-298, 2006</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.06988v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.06988v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08087v1</id>
    <updated>2015-07-29T10:01:22Z</updated>
    <published>2015-07-29T10:01:22Z</published>
    <title>Tabling as a Library with Delimited Control</title>
    <summary>  Tabling is probably the most widely studied extension of Prolog. But despite
its importance and practicality, tabling is not implemented by most Prolog
systems. Existing approaches require substantial changes to the Prolog engine,
which is an investment out of reach of most systems. To enable more widespread
adoption, we present a new implementation of tabling in under 600 lines of
Prolog code. Our lightweight approach relies on delimited control and provides
reasonable performance.
</summary>
    <author>
      <name>Benoit Desouter</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <author>
      <name>Marko van Dooren</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068415000137</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068415000137" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages. To appear in Theory and Practice of Logic Programming
  (TPLP), Proceedings of ICLP 2015</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 15 (2015) 419-433</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1507.08087v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08087v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1507.08610v1</id>
    <updated>2015-07-30T18:15:02Z</updated>
    <published>2015-07-30T18:15:02Z</published>
    <title>Fast, Flexible, and Declarative Construction of Abstract Syntax Trees
  with PEGs</title>
    <summary>  We address a declarative construction of abstract syntax trees with Parsing
Expression Grammars. AST operators (constructor, connector, and tagging) are
newly defined to specify flexible AST constructions. A new challenge coming
with PEGs is the consistency management of ASTs in backtracking and packrat
parsing. We make the transaction AST machine in order to perform AST operations
in the context of the speculative parsing of PEGs. All the consistency control
is automated by the analysis of AST operators. The proposed approach is
implemented in the Nez parser, written in Java. The performance study shows
that the transactional AST machine requires 25\% approximately more time in
CSV, XML, and C grammars.
</summary>
    <author>
      <name>Kimio Kuramitsu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Journal of Information Processing (2015)</arxiv:comment>
    <link href="http://arxiv.org/abs/1507.08610v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1507.08610v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03536v1</id>
    <updated>2015-08-14T15:05:14Z</updated>
    <published>2015-08-14T15:05:14Z</published>
    <title>Proceedings of the 3rd Workshop on Domain-Specific Language Design and
  Implementation (DSLDI 2015)</title>
    <summary>  The goal of the DSLDI workshop is to bring together researchers and
practitioners interested in sharing ideas on how DSLs should be designed,
implemented, supported by tools, and applied in realistic application contexts.
We are both interested in discovering how already known domains such as graph
processing or machine learning can be best supported by DSLs, but also in
exploring new domains that could be targeted by DSLs. More generally, we are
interested in building a community that can drive forward the development of
modern DSLs. These informal post-proceedings contain the submitted talk
abstracts to the 3rd DSLDI workshop (DSLDI'15), and a summary of the panel
discussion on Language Composition.
</summary>
    <author>
      <name>Tijs van der Storm</name>
    </author>
    <author>
      <name>Sebastian Erdweg</name>
    </author>
    <link href="http://arxiv.org/abs/1508.03536v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03536v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03892v1</id>
    <updated>2015-08-17T01:36:36Z</updated>
    <published>2015-08-17T01:36:36Z</published>
    <title>Building an IDE for the Calculational Derivation of Imperative Programs</title>
    <summary>  In this paper, we describe an IDE called CAPS (Calculational Assistant for
Programming from Specifications) for the interactive, calculational derivation
of imperative programs. In building CAPS, our aim has been to make the IDE
accessible to non-experts while retaining the overall flavor of the
pen-and-paper calculational style. We discuss the overall architecture of the
CAPS system, the main features of the IDE, the GUI design, and the trade-offs
involved.
</summary>
    <author>
      <name>Dipak L. Chaudhari</name>
    </author>
    <author>
      <name>Om Damani</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.187.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.187.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings F-IDE 2015, arXiv:1508.03388</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 187, 2015, pp. 1-13</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1508.03892v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03892v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.03901v1</id>
    <updated>2015-08-17T01:51:02Z</updated>
    <published>2015-08-17T01:51:02Z</published>
    <title>Unlocking Blocked Communicating Processes</title>
    <summary>  We study the problem of disentangling locked processes via code refactoring.
We identify and characterise a class of processes that is not lock-free; then
we formalise an algorithm that statically detects potential locks and propose
refactoring procedures that disentangle detected locks. Our development is cast
within a simple setting of a finite linear CCS variant \^a although it suffices
to illustrate the main concepts, we also discuss how our work extends to other
language extensions.
</summary>
    <author>
      <name>Adrian Francalanza</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CS, ICT, University of Malta</arxiv:affiliation>
    </author>
    <author>
      <name>Marco Giunti</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">RELEASE, DI, Universidade da Beira Interior &amp; NOVA LINCS, DI-FCT, Universidade NOVA de Lisboa</arxiv:affiliation>
    </author>
    <author>
      <name>António Ravara</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">NOVA LINCS, DI-FCT, Universidade NOVA de Lisboa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.188.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.188.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WWV 2015, arXiv:1508.03389</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 188, 2015, pp. 23-32</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1508.03901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.03901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1508.07547v2</id>
    <updated>2016-03-22T00:50:14Z</updated>
    <published>2015-08-30T09:11:14Z</published>
    <title>Protocol Programming: A Connection of the Digital World</title>
    <summary>  The current computer programmings encapsulate attributes and behaviours into
objects, but miss the mechanism to support the connection among objects. A
programming paradigm is presented to connect all objects. The connection
supports communications. Protocols are defined to coordinate the behaviours
between objects, which enable the interaction of objects across different
platforms. The connection also provides an efficient mechanism to support the
concurrency, parallelism, distribution, pipeline and adaptability, etc. They
can be governed transparently, autonomously, even adaptively. In this paper, an
implementation is also discussed to show the effectiveness of protocol
programming.
</summary>
    <author>
      <name>Yanping Chen</name>
    </author>
    <author>
      <name>Qinghua Zheng</name>
    </author>
    <author>
      <name>Ping Chen</name>
    </author>
    <link href="http://arxiv.org/abs/1508.07547v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1508.07547v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.00713v1</id>
    <updated>2016-01-05T01:44:35Z</updated>
    <published>2016-01-05T01:44:35Z</published>
    <title>Almost Continuous Transformations of Software and Higher-order Dataflow
  Programming</title>
    <summary>  We consider two classes of stream-based computations which admit taking
linear combinations of execution runs: probabilistic sampling and generalized
animation. The dataflow architecture is a natural platform for programming with
streams. The presence of linear combinations allows us to introduce the notion
of almost continuous transformation of dataflow graphs. We introduce a new
approach to higher-order dataflow programming: a dynamic dataflow program is a
stream of dataflow graphs evolving by almost continuous transformations. A
dynamic dataflow program would typically run while it evolves. We introduce
Fluid, an experimental open source system for programming with dataflow graphs
and almost continuous transformations.
</summary>
    <author>
      <name>Michael Bukatin</name>
    </author>
    <author>
      <name>Steve Matthews</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, July 9, 2015 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1601.00713v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.00713v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.02059v1</id>
    <updated>2016-01-09T01:05:03Z</updated>
    <published>2016-01-09T01:05:03Z</published>
    <title>The Essence of Inheritance</title>
    <summary>  Programming languages serve a dual purpose: to communicate programs to
computers, and to communicate programs to humans. Indeed, it is this dual
purpose that makes programming language design a constrained and challenging
problem. Inheritance is an essential aspect of that second purpose: it is a
tool to improve communication. Humans understand new concepts most readily by
first looking at a number of concrete examples, and later abstracting over
those examples. The essence of inheritance is that it mirrors this process: it
provides a formal mechanism for moving from the concrete to the abstract.
</summary>
    <author>
      <name>Andrew P. Black</name>
    </author>
    <author>
      <name>Kim B. Bruce</name>
    </author>
    <author>
      <name>James Noble</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper was submitted for inclusion in a Festschrift entitled "A
  list of successes that can change the world", to be published by Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/1601.02059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.02059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1601.06517v2</id>
    <updated>2016-02-04T09:34:54Z</updated>
    <published>2016-01-25T08:56:27Z</published>
    <title>Programmable Restoration Granularity in Constraint Programming</title>
    <summary>  In most constraint programming systems, a limited number of search engines is
offered while the programming of user-customized search algorithms requires
low-level efforts, which complicates the deployment of such algorithms. To
alleviate this limitation, concepts such as computation spaces have been
developed. Computation spaces provide a coarse-grained restoration mechanism,
because they store all information contained in a search tree node. Other
granularities are possible, and in this paper we make the case for dynamically
adapting the restoration granularity during search. In order to elucidate
programmable restoration granularity, we present restoration as an aspect of a
constraint programming system, using the model of aspect-oriented programming.
A proof-of-concept implementation using Gecode shows promising results.
</summary>
    <author>
      <name>Yong Lin</name>
    </author>
    <author>
      <name>Martin Henz</name>
    </author>
    <link href="http://arxiv.org/abs/1601.06517v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1601.06517v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.06568v2</id>
    <updated>2017-04-23T18:35:46Z</updated>
    <published>2016-02-21T19:18:58Z</published>
    <title>Modelling homogeneous generative meta-programming</title>
    <summary>  Homogeneous generative meta-programming (HGMP) enables the generation of
program fragments at compile-time or run-time. We present the first
foundational calculus which can model powerful HGMP languages such as Template
Haskell. The calculus is designed such that we can gradually enhance it with
the features needed to model many of the advanced features of real languages.
As a demonstration of the flexibility of our approach, we also provide a simple
type system for the calculus.
</summary>
    <author>
      <name>Martin Berger</name>
    </author>
    <author>
      <name>Laurence Tratt</name>
    </author>
    <author>
      <name>Christian Urban</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ECOOP 2017, to appear</arxiv:comment>
    <link href="http://arxiv.org/abs/1602.06568v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.06568v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.07285v1</id>
    <updated>2016-02-23T20:09:33Z</updated>
    <published>2016-02-23T20:09:33Z</published>
    <title>Automatic Generation of Formula Simplifiers based on Conditional Rewrite
  Rules</title>
    <summary>  This paper addresses the problem of creating simplifiers for logic formulas
based on conditional term rewriting. In particular, the paper focuses on a
program synthesis application where formula simplifications have been shown to
have a significant impact. We show that by combining machine learning
techniques with constraint-based synthesis, it is possible to synthesize a
formula simplifier fully automatically from a corpus of representative
problems, making it possible to create formula simplifiers tailored to specific
problem domains. We demonstrate the benefits of our approach for synthesis
benchmarks from the SyGuS competition and automated grading.
</summary>
    <author>
      <name>Rohit Singh</name>
    </author>
    <author>
      <name>Armando Solar-Lezama</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted for peer reviewed conference</arxiv:comment>
    <link href="http://arxiv.org/abs/1602.07285v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.07285v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1602.08406v2</id>
    <updated>2016-08-14T15:28:05Z</updated>
    <published>2016-02-26T17:14:18Z</published>
    <title>Trace semantics for polymorphic references</title>
    <summary>  We introduce a trace semantics for a call-by-value language with full
polymorphism and higher-order references. This is an operational game semantics
model based on a nominal interpretation of parametricity whereby polymorphic
values are abstracted with special kinds of names. The use of polymorphic
references leads to violations of parametricity which we counter by closely
recoding the disclosure of typing information in the semantics. We prove the
model sound for the full language and strengthen our result to full abstraction
for a large fragment where polymorphic references obey specific inhabitation
conditions.
</summary>
    <author>
      <name>Guilhem Jaber</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <link href="http://arxiv.org/abs/1602.08406v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1602.08406v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.01106v2</id>
    <updated>2016-12-15T07:51:56Z</updated>
    <published>2016-08-03T08:23:34Z</published>
    <title>Probabilistic Resource Analysis by Program Transformation</title>
    <summary>  The aim of a probabilistic resource analysis is to derive a probability
distribution of possible resource usage for a program from a probability
distribution of its input. We present an automated multi- phase rewriting based
method to analyze programs written in a subset of C. It generates a probability
distribution of the resource usage as a possibly uncomputable expression and
then transforms it into a closed form expression using over-approximations. We
present the technique, outline the implementation and show results from
experiments with the system.
</summary>
    <author>
      <name>Maja H. Kirkeby</name>
    </author>
    <author>
      <name>Mads Rosendahl</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-46559-3_4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-46559-3_4" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Lecture Notes in Computer Science 9964 (2016) 60-80</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.01106v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.01106v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.01723v2</id>
    <updated>2017-06-16T10:41:54Z</updated>
    <published>2016-08-05T00:13:42Z</published>
    <title>Synthesizing Program Input Grammars</title>
    <summary>  We present an algorithm for synthesizing a context-free grammar encoding the
language of valid program inputs from a set of input examples and blackbox
access to the program. Our algorithm addresses shortcomings of existing grammar
inference algorithms, which both severely overgeneralize and are prohibitively
slow. Our implementation, GLADE, leverages the grammar synthesized by our
algorithm to fuzz test programs with structured inputs. We show that GLADE
substantially increases the incremental coverage on valid inputs compared to
two baseline fuzzers.
</summary>
    <author>
      <name>Osbert Bastani</name>
    </author>
    <author>
      <name>Rahul Sharma</name>
    </author>
    <author>
      <name>Alex Aiken</name>
    </author>
    <author>
      <name>Percy Liang</name>
    </author>
    <link href="http://arxiv.org/abs/1608.01723v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.01723v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.02534v2</id>
    <updated>2016-09-01T15:52:11Z</updated>
    <published>2016-08-08T17:57:30Z</published>
    <title>Pre-proceedings of the 26th International Symposium on Logic-Based
  Program Synthesis and Transformation (LOPSTR 2016)</title>
    <summary>  This volume constitutes the pre-proceedings of the 26th International
Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2016),
held on 6-8th September 2016 in Edinburgh, Scotland UK, and co-located with the
18th International Symposium on Principles and Practice of Declarative
Programming (PPDP 2016) and the 23rd Static Analysis Symposium (SAS 2016).
After discussion at the symposium papers will go through a second round of
refereeing and selection for the formal proceedings.
</summary>
    <author>
      <name>Manuel V. Hermenegildo</name>
    </author>
    <author>
      <name>Pedro Lopez-Garcia</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Papers selected for presentation at LOPSTR 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.02534v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.02534v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.03327v1</id>
    <updated>2016-08-11T00:26:43Z</updated>
    <published>2016-08-11T00:26:43Z</published>
    <title>A Step Towards Checking Security in IoT</title>
    <summary>  The Internet of Things (IoT) is smartifying our everyday life. Our starting
point is IoT-LySa, a calculus for describing IoT systems, and its static
analysis, which will be presented at Coordination 2016. We extend the mentioned
proposal in order to begin an investigation about security issues, in
particular for the static verification of secrecy and some other security
properties.
</summary>
    <author>
      <name>Chiara Bodei</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa</arxiv:affiliation>
    </author>
    <author>
      <name>Pierpaolo Degano</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa</arxiv:affiliation>
    </author>
    <author>
      <name>Gian-Luigi Ferrari</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa</arxiv:affiliation>
    </author>
    <author>
      <name>Letterio Galletta</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.223.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.223.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2016, arXiv:1608.03131</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 223, 2016, pp. 128-142</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.03327v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.03327v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2;D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.03771v1</id>
    <updated>2016-08-12T12:21:30Z</updated>
    <published>2016-08-12T12:21:30Z</published>
    <title>Nominal Unification of Higher Order Expressions with Recursive Let</title>
    <summary>  A sound and complete algorithm for nominal unification of higher-order
expressions with a recursive let is described, and shown to run in
non-deterministic polynomial time. We also explore specializations like nominal
letrec-matching for plain expressions and for DAGs and determine the complexity
of corresponding unification problems.
</summary>
    <author>
      <name>Manfred Schmidt-Schauß</name>
    </author>
    <author>
      <name>Temur Kutsia</name>
    </author>
    <author>
      <name>Jordi Levy</name>
    </author>
    <author>
      <name>Mateu Villaret</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-63139-4_19</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-63139-4_19" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 26th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2016), Edinburgh,
  Scotland UK, 6-8 September 2016 (arXiv:1608.02534)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logic-Based Program Synthesis and Transformation, LNCS 10184, pp
  328-344, Springer (2016)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1608.03771v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.03771v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.04016v1</id>
    <updated>2016-08-13T18:41:11Z</updated>
    <published>2016-08-13T18:41:11Z</published>
    <title>A New Functional-Logic Compiler for Curry: Sprite</title>
    <summary>  We introduce a new native code compiler for Curry codenamed Sprite. Sprite is
based on the Fair Scheme, a compilation strategy that provides instructions for
transforming declarative, non-deterministic programs of a certain class into
imperative, deterministic code. We outline salient features of Sprite, discuss
its implementation of Curry programs, and present benchmarking results. Sprite
is the first-to-date operationally complete implementation of Curry.
Preliminary results show that ensuring this property does not incur a
significant penalty.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <author>
      <name>Andy Jost</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 26th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2016), Edinburgh,
  Scotland UK, 6-8 September 2016 (arXiv:1608.02534)</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.04016v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.04016v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.05521v1</id>
    <updated>2016-08-19T08:01:25Z</updated>
    <published>2016-08-19T08:01:25Z</published>
    <title>Towards Reversible Computation in Erlang</title>
    <summary>  In a reversible language, any forward computation can be undone by a finite
sequence of backward steps. Reversible computing has been studied in the
context of different programming languages and formalisms, where it has been
used for debugging and for enforcing fault-tolerance, among others. In this
paper, we consider a subset of Erlang, a concurrent language based on the actor
model. We formally introduce a reversible semantics for this language. To the
best of our knowledge, this is the first attempt to define a reversible
semantics for Erlang.
</summary>
    <author>
      <name>Naoki Nishida</name>
    </author>
    <author>
      <name>Adrián Palacios</name>
    </author>
    <author>
      <name>Germán Vidal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 26th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2016), Edinburgh,
  Scotland UK, 6-8 September 2016 (arXiv:1608.02534)</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.05521v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.05521v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.07206v1</id>
    <updated>2016-08-25T16:17:29Z</updated>
    <published>2016-08-25T16:17:29Z</published>
    <title>Embedded SML using the MLton compiler</title>
    <summary>  In this extended abstract we present our current work on leveraging Standard
ML for developing embedded and real-time systems. Specifically we detail our
experiences in modifying MLton, a whole program, optimizing compiler for
Standard ML, for use in such contexts. We focus primarily on the language
runtime, re-working the threading subsystem and garbage collector, as well as
necessary changes for integrating MLton generated programs into a light weight
operating system kernel. We compare and contrast these changes to our previous
work on extending MLton for multicore systems, which focused around acheiving
scalability.
</summary>
    <author>
      <name>Jeffrey Murphy</name>
    </author>
    <author>
      <name>Bhargav Shivkumar</name>
    </author>
    <author>
      <name>Lukasz Ziarek</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IFL 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1608.07206v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.07206v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1608.08330v2</id>
    <updated>2016-09-02T08:21:00Z</updated>
    <published>2016-08-30T05:18:07Z</published>
    <title>Static Trace-Based Deadlock Analysis for Synchronous Mini-Go</title>
    <summary>  We consider the problem of static deadlock detection for programs in the Go
programming language which make use of synchronous channel communications. In
our analysis, regular expressions extended with a fork operator capture the
communication behavior of a program. Starting from a simple criterion that
characterizes traces of deadlock-free programs, we develop automata-based
methods to check for deadlock-freedom. The approach is implemented and
evaluated with a series of examples.
</summary>
    <author>
      <name>Kai Stadtmüller</name>
    </author>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <link href="http://arxiv.org/abs/1608.08330v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1608.08330v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.01985v1</id>
    <updated>2016-09-03T11:14:51Z</updated>
    <published>2016-09-03T11:14:51Z</published>
    <title>Behavioural Prototypes</title>
    <summary>  We sketch a simple language of concurrent objects which explores the design
space between type systems and continuous testing. In our language, programs
are collections of communicating automata checked automatically for multiparty
compatibility. This property, taken from the session types literature but here
applied to terms rather than types, guarantees that no state-related errors
arise during execution: no object gets stuck because it was sent the wrong
message, and every message is processed.
</summary>
    <author>
      <name>Roly Perera</name>
    </author>
    <author>
      <name>Simon J. Gay</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract; presented at 0th Workshop on New Object-Oriented
  Languages (NOOL) 2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1609.01985v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.01985v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.03640v1</id>
    <updated>2016-09-13T00:17:01Z</updated>
    <published>2016-09-13T00:17:01Z</published>
    <title>Compiling Process Networks to Interaction Nets</title>
    <summary>  Kahn process networks are a model of computation based on a collection of
sequential, deterministic processes that communicate by sending messages
through unbounded channels. They are well suited for modelling stream-based
computations, but are in no way restricted to this application. Interaction
nets are graph rewriting systems that have many interesting properties for
implementation. In this paper we show how to encode process networks using
interaction nets, where we model both networks and messages in the same
framework.
</summary>
    <author>
      <name>Ian Mackie</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIX, Ecole Polytechnique</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.225.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.225.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TERMGRAPH 2016, arXiv:1609.03014</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 225, 2016, pp. 5-14</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1609.03640v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.03640v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.03643v1</id>
    <updated>2016-09-13T00:17:26Z</updated>
    <published>2016-09-13T00:17:26Z</published>
    <title>Reasoning about Graph Programs</title>
    <summary>  GP 2 is a non-deterministic programming language for computing by graph
transformation. One of the design goals for GP 2 is syntactic and semantic
simplicity, to facilitate formal reasoning about programs. In this paper, we
demonstrate with four case studies how programmers can prove termination and
partial correctness of their solutions. We argue that GP 2's graph
transformation rules, together with induction on the length of program
executions, provide a convenient framework for program verification.
</summary>
    <author>
      <name>Detlef Plump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of York, United Kingdom</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.225.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.225.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TERMGRAPH 2016, arXiv:1609.03014</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 225, 2016, pp. 35-44</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1609.03643v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.03643v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.04233v1</id>
    <updated>2016-09-14T12:16:24Z</updated>
    <published>2016-09-14T12:16:24Z</published>
    <title>Liveness for Verification</title>
    <summary>  We explore the use of liveness for interactive program verification for a
simple concurrent object language. Our experimental IDE integrates two
(formally dual) kinds of continuous testing into the development environment:
compatibility-checking, which verifies an object's use of other objects, and
compliance-checking, which verifies an object's claim to refine the behaviour
of another object. Source code errors highlighted by the IDE are not static
type errors but the reflection back to the source of runtime errors that occur
in some execution of the system. We demonstrate our approach, and discuss
opportunities and challenges.
</summary>
    <author>
      <name>Roly Perera</name>
    </author>
    <author>
      <name>Simon J. Gay</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2nd Workshop on Live Programming Systems, LIVE 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1609.04233v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.04233v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.05337v1</id>
    <updated>2016-09-17T13:53:10Z</updated>
    <published>2016-09-17T13:53:10Z</published>
    <title>miniAdapton: A Minimal Implementation of Incremental Computation in
  Scheme</title>
    <summary>  We describe a complete Scheme implementation of miniAdapton, which implements
the core functionality of the Adapton system for incremental computation (also
known as self-adjusting computation). Like Adapton, miniAdapton allows
programmers to safely combine mutation and memoization. miniAdapton is built on
top of an even simpler system, microAdapton. Both miniAdapton and microAdapton
are designed to be easy to understand, extend, and port to host languages other
than Scheme. We also present adapton variables, a new interface in Adapton for
variables intended to represent expressions.
</summary>
    <author>
      <name>Dakota Fisher</name>
    </author>
    <author>
      <name>Matthew A. Hammer</name>
    </author>
    <author>
      <name>William Byrd</name>
    </author>
    <author>
      <name>Matthew Might</name>
    </author>
    <link href="http://arxiv.org/abs/1609.05337v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.05337v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.09709v1</id>
    <updated>2016-09-30T13:03:25Z</updated>
    <published>2016-09-30T13:03:25Z</published>
    <title>Type checking through unification</title>
    <summary>  In this paper we describe how to leverage higher-order unification to type
check a dependently typed language with meta-variables. The literature usually
presents the unification algorithm as a standalone component, however the need
to check definitional equality of terms while type checking gives rise to a
tight interplay between type checking and unification. This interplay is a
major source of complexity in the type-checking algorithm for existing
dependently typed programming languages. We propose an algorithm that encodes a
type-checking problem entirely in the form of unification constraints, reducing
the complexity of the type-checking code by taking advantage of higher order
unification, which is already part of the implementation of many dependently
typed languages.
</summary>
    <author>
      <name>Francesco Mazzoli</name>
    </author>
    <author>
      <name>Andreas Abel</name>
    </author>
    <link href="http://arxiv.org/abs/1609.09709v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.09709v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1609.09718v1</id>
    <updated>2016-09-30T13:25:05Z</updated>
    <published>2016-09-30T13:25:05Z</published>
    <title>Jolie Community on the Rise</title>
    <summary>  Jolie is a programming language that follows the microservices paradigm. As
an open source project, it has built a community of developers worldwide - both
in the industry as well as in academia - taken care of the development,
continuously improved its usability, and therefore broadened the adoption. In
this paper, we present some of the most recent results and work in progress
that has been made within our research team.
</summary>
    <author>
      <name>Alexey Bandura</name>
    </author>
    <author>
      <name>Nikita Kurilenko</name>
    </author>
    <author>
      <name>Manuel Mazzara</name>
    </author>
    <author>
      <name>Victor Rivera</name>
    </author>
    <author>
      <name>Larisa Safina</name>
    </author>
    <author>
      <name>Alexander Tchitchigin</name>
    </author>
    <link href="http://arxiv.org/abs/1609.09718v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1609.09718v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.00602v1</id>
    <updated>2016-11-02T13:38:36Z</updated>
    <published>2016-11-02T13:38:36Z</published>
    <title>Scala-gopher: CSP-style programming techniques with idiomatic Scala</title>
    <summary>  Cala-gopher is a library-level Scala implementation of communication sequence
process constructs: channels, selectors (similar to analogical constructs in
Limbo or Go) transputers (similar to Occam proc) and a set of high-level
operations on top of akka and SIP-22 async. The framework integrates CSP-style
programming into standard Scala concurrency environment via idiomatic API. This
allows usage of communication patterns, well known in Go world, but not easy
expressable in mainstream scala concurrency frameworks, along with algebraic
approach for composing computation builders. Besides, we want to discuss
current implementation issues and future directions in the context of evolving
of compiler and libraries ecosystem.
</summary>
    <author>
      <name>Ruslan Shevchenko</name>
    </author>
    <link href="http://arxiv.org/abs/1611.00602v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.00602v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.07629v1</id>
    <updated>2016-11-23T03:28:09Z</updated>
    <published>2016-11-23T03:28:09Z</published>
    <title>Approaching Symbolic Parallelization by Synthesis of Recurrence
  Decompositions</title>
    <summary>  We present GraSSP, a novel approach to perform automated parallelization
relying on recent advances in formal verification and synthesis. GraSSP
augments an existing sequential program with an additional functionality to
decompose data dependencies in loop iterations, to compute partial results, and
to compose them together. We show that for some classes of the sequential
prefix sum problems, such parallelization can be performed efficiently.
</summary>
    <author>
      <name>Grigory Fedyukovich</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">UW</arxiv:affiliation>
    </author>
    <author>
      <name>Rastislav Bodík</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">UW</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.229.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.229.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings SYNT 2016, arXiv:1611.07178</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 229, 2016, pp. 55-66</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1611.07629v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.07629v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.08888v1</id>
    <updated>2016-11-27T19:06:42Z</updated>
    <published>2016-11-27T19:06:42Z</published>
    <title>Propositions in Linear Multirole Logic as Multiparty Session Types</title>
    <summary>  We identify multirole logic as a new form of logic and formalize linear
multirole logic (LMRL) as a natural generalization of classical linear logic
(CLL). Among various meta-properties established for LMRL, we obtain one named
multi-cut elimination stating that every cut between three (or more) sequents
(as a generalization of a cut between two sequents) can be eliminated, thus
extending the celebrated result of cut-elimination by Gentzen. We also present
a variant of $\pi$-calculus for multiparty sessions that demonstrates a tight
correspondence between process communication in this variant and multi-cut
elimination in LMRL, thus extending some recent results by Caires and Pfenning
(2010) and Wadler (2012), among others, along a similar line of work.
</summary>
    <author>
      <name>Hongwei Xi</name>
    </author>
    <author>
      <name>Hanwen Wu</name>
    </author>
    <link href="http://arxiv.org/abs/1611.08888v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.08888v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.09473v1</id>
    <updated>2016-11-29T03:40:04Z</updated>
    <published>2016-11-29T03:40:04Z</published>
    <title>Proust: A Nano Proof Assistant</title>
    <summary>  Proust is a small Racket program offering rudimentary interactive assistance
in the development of verified proofs for propositional and predicate logic. It
is constructed in stages, some of which are done by students before using it to
complete proof exercises, and in parallel with the study of its theoretical
underpinnings, including elements of Martin-Lof type theory. The goal is
twofold: to demystify some of the machinery behind full-featured proof
assistants such as Coq and Agda, and to better integrate the study of formal
logic with other core elements of an undergraduate computer science curriculum.
</summary>
    <author>
      <name>Prabhakar Ragde</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waterloo</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.230.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.230.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2015/6, arXiv:1611.08651</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 230, 2016, pp. 63-75</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1611.09473v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.09473v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1611.09606v1</id>
    <updated>2016-11-29T12:47:15Z</updated>
    <published>2016-11-29T12:47:15Z</published>
    <title>An Inductive Proof Method for Simulation-based Compiler Correctness</title>
    <summary>  We study induction on the program structure as a proof method for
bisimulation-based compiler correctness. We consider a first-order language
with mutually recursive function definitions, system calls, and an environment
semantics. The proof method relies on a generalization of compatibility of
function definition with the bisimulation. We use the inductive method to show
correctness of a form of dead code elimination. This is an interesting case
study because the transformation removes function, variable, and parameter
definitions from the program. While such transformations require modification
of the simulation in a coinductive proof, the inductive method deals with them
naturally. All our results are formalized in Coq.
</summary>
    <author>
      <name>Sigurd Schneider</name>
    </author>
    <author>
      <name>Gert Smolka</name>
    </author>
    <author>
      <name>Sebastian Hack</name>
    </author>
    <link href="http://arxiv.org/abs/1611.09606v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1611.09606v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.00233v1</id>
    <updated>2017-01-01T12:26:14Z</updated>
    <published>2017-01-01T12:26:14Z</published>
    <title>Proceedings Third International Workshop on Rewriting Techniques for
  Program Transformations and Evaluation</title>
    <summary>  This volume contains the formal proceedings of the Third International
Workshop on Rewriting Techniques for Program Transformations and Evaluation
(WPTE 2016), held on 23rd June 2016 in Porto, Portugal, as a satellite event of
the First International Conference on Formal Structures for Computation and
Deduction (FSCD 2016). The workshop brought together researchers working on
program transformations, evaluation, and operationally based programming
language semantics, using rewriting methods, in order to share the techniques
and recent developments and to exchange ideas to encourage further activation
of research in this area.
</summary>
    <author>
      <name>Horatiu Cirstea</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LORIA, Université de Lorraine, France</arxiv:affiliation>
    </author>
    <author>
      <name>Santiago Escobar</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universitat Politècnica de València, Spain</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.235</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.235" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Dedicated to the memory of Kristoffer H. Rose</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 235, 2017</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.00233v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.00233v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.00633v1</id>
    <updated>2017-01-03T10:33:05Z</updated>
    <published>2017-01-03T10:33:05Z</published>
    <title>A Framework for Extending microKanren with Constraints</title>
    <summary>  We present a framework for building CLP languages with symbolic constraints
based on microKanren, a domain-specific logic language shallowly embedded in
Racket. We rely on Racket's macro system to generate a constraint solver and
other components of the microKanren embedding. The framework itself and the
constraints' implementations amounts to just over 100 lines of code. Our
framework is both a teachable implementation for CLP as well as a test-bed and
prototyping tool for symbolic constraint systems.
</summary>
    <author>
      <name>Jason Hemann</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Indiana University</arxiv:affiliation>
    </author>
    <author>
      <name>Daniel P. Friedman</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Indiana University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.234.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.234.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WLP'15/'16/WFLP'16, arXiv:1701.00148</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 234, 2017, pp. 135-149</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.00633v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.00633v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6 Logic Programming; D.3.2 Constraint and Logic Languages; D.3.3&#10;  Constraints" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.00640v1</id>
    <updated>2017-01-03T10:38:53Z</updated>
    <published>2017-01-03T10:38:53Z</published>
    <title>An Environment for Analyzing Space Optimizations in Call-by-Need
  Functional Languages</title>
    <summary>  We present an implementation of an interpreter LRPi for the call-by-need
calculus LRP, based on a variant of Sestoft's abstract machine Mark 1, extended
with an eager garbage collector. It is used as a tool for exact space usage
analyses as a support for our investigations into space improvements of
call-by-need calculi.
</summary>
    <author>
      <name>Nils Dallmeyer</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Goethe-University Frankfurt, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Manfred Schmidt-Schauss</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Goethe-University Frankfurt, Germany</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.235.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.235.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WPTE 2016, arXiv:1701.00233</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 235, 2017, pp. 78-92</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.00640v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.00640v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1;D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.01785v1</id>
    <updated>2017-01-07T01:55:13Z</updated>
    <published>2017-01-07T01:55:13Z</published>
    <title>A Concurrent Model for Imperative Languages with Improved Atomicity</title>
    <summary>  We propose a new concurrent model for imperative languages where concurrency
occurs at a subprogram level. This model introduces a new {\it block
sequential} statement of the form $#(G_1,\ldots,G_n)$ where each $G_i$ is a
statement. This statement tells the machine to execute $G_1,\ldots,G_n$
sequentially and atomically (\ie, without interleaving). It therefore enhances
atomicity and predictability in concurrent programming. We illustrate our idea
via $C^{\|}$, an extension of the core concurrent C with the new block
sequential statement.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Daeseong Kang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages. Our scheduler is quite adaptive to the requests of the
  processes. This makes synchronization simpler</arxiv:comment>
    <link href="http://arxiv.org/abs/1701.01785v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.01785v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.02189v1</id>
    <updated>2017-01-02T06:53:48Z</updated>
    <published>2017-01-02T06:53:48Z</published>
    <title>A Modularity Bug in Java 8</title>
    <summary>  We demonstrate a modularity bug in the interface system of Java 8 on the
practical example of a textbook design of a modular interface for vector
spaces. Our example originates in our teaching of modular object-oriented
design in Java 8 to undergraduate students, simply following standard
programming practices and mathematical definitions. The bug shows up as a
compilation error and should be fixed with a language extension due to the
importance of best practices (design fidelity).
</summary>
    <author>
      <name>Simon Kramer</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.20904/283001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.20904/283001" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theoretical and Applied Informatics, Volume 28, Issue 3, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.02189v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.02189v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.02668v1</id>
    <updated>2017-01-10T16:29:06Z</updated>
    <published>2017-01-10T16:29:06Z</published>
    <title>Constraint Handling Rules - What Else?</title>
    <summary>  Constraint Handling Rules (CHR) is both an effective concurrent declarative
constraint-based programming language and a versatile computational formalism.
While conceptually simple, CHR is distinguished by a remarkable combination of
desirable features: - semantic foundation in classical and linear logic, -
effective and efficient sequential and parallel execution model - guaranteed
properties like the anytime online algorithm properties - powerful analysis
methods for deciding essential program properties. This overview of CHR
research and applications is by no complete. It concentrates on the years since
2000. Up-to-date information on CHR can be found at the CHR web-site
www.constraint-handling-rules.org, including the slides of the keynote talk
associated with this article, an extensive bibliography, online demo versions
and free downloads of the language.
</summary>
    <author>
      <name>Thom Fruehwirth</name>
    </author>
    <link href="http://arxiv.org/abs/1701.02668v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.02668v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.03320v1</id>
    <updated>2017-01-12T12:05:03Z</updated>
    <published>2017-01-12T12:05:03Z</published>
    <title>An Introduction to Liquid Haskell</title>
    <summary>  This paper is a tutorial introducing the underlying technology and the use of
the tool Liquid Haskell, a type-checker for the functional language Haskell
that can help programmers to verify non-trivial properties of their programs
with a low effort.
  The first sections introduce the technology of Liquid Types by explaining its
principles and summarizing how its type inference algorithm manages to prove
properties. The remaining sections present a selection of Haskell examples and
show the kind of properties that can be proved with the system.
</summary>
    <author>
      <name>Ricardo Peña</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universidad Complutense de Madrid</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.237.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.237.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PROLE 2016, arXiv:1701.03069</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 237, 2017, pp. 68-80</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.03320v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.03320v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.04089v1</id>
    <updated>2017-01-15T18:04:44Z</updated>
    <published>2017-01-15T18:04:44Z</published>
    <title>Probabilistic Termination by Monadic Affine Sized Typing (Long Version)</title>
    <summary>  We introduce a system of monadic affine sized types, which substantially
generalise usual sized types, and allows this way to capture probabilistic
higher-order programs which terminate almost surely. Going beyond plain, strong
normalisation without losing soundness turns out to be a hard task, which
cannot be accomplished without a richer, quantitative notion of types, but also
without imposing some affinity constraints. The proposed type system is
powerful enough to type classic examples of probabilistically terminating
programs such as random walks. The way typable programs are proved to be almost
surely terminating is based on reducibility, but requires a substantial
adaptation of the technique.
</summary>
    <author>
      <name>Ugo Dal Lago</name>
    </author>
    <author>
      <name>Charles Grellois</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">63 pages. To appear in ESOP 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1701.04089v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.04089v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.04929v1</id>
    <updated>2017-01-18T02:58:50Z</updated>
    <published>2017-01-18T02:58:50Z</published>
    <title>Design and Implementation of Concurrent C0</title>
    <summary>  We describe Concurrent C0, a type-safe C-like language with contracts and
session-typed communication over channels. Concurrent C0 supports an operation
called forwarding which allows channels to be combined in a well-defined way.
The language's type system enables elegant expression of session types and
message-passing concurrent programs. We provide a Go-based implementation with
language based optimizations that outperforms traditional message passing
techniques.
</summary>
    <author>
      <name>Max Willsey</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <author>
      <name>Rokhini Prabhu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <author>
      <name>Frank Pfenning</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.238.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.238.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings LINEARITY 2016, arXiv:1701.04522. Extended version at:
  http://mwillsey.com/papers/cc0-thesis.pdf</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 238, 2017, pp. 73-82</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1701.04929v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.04929v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1701.06104v3</id>
    <updated>2024-01-02T09:10:09Z</updated>
    <published>2017-01-21T23:41:35Z</published>
    <title>Verifying Concurrent Stacks by Divergence-Sensitive Bisimulation</title>
    <summary>  The verification of linearizability -- a key correctness criterion for
concurrent objects -- is based on trace refinement whose checking is
PSPACE-complete. This paper suggests to use \emph{branching} bisimulation
instead. Our approach is based on comparing an abstract specification in which
object methods are executed atomically to a real object program. Exploiting
divergence sensitivity, this also applies to progress properties such as
lock-freedom. These results enable the use of \emph{polynomial-time}
divergence-sensitive branching bisimulation checking techniques for verifying
linearizability and progress. We conducted the experiment on concurrent
lock-free stacks to validate the efficiency and effectiveness of our methods.
</summary>
    <author>
      <name>Xiaoxiao Yang</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <author>
      <name>Hao Wu</name>
    </author>
    <link href="http://arxiv.org/abs/1701.06104v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1701.06104v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1704.02375v1</id>
    <updated>2017-04-07T21:10:00Z</updated>
    <published>2017-04-07T21:10:00Z</published>
    <title>AppLP: A Dialogue on Applications of Logic Programming</title>
    <summary>  This document describes the contributions of the 2016 Applications of Logic
Programming Workshop (AppLP), which was held on October 17 and associated with
the International Conference on Logic Programming (ICLP) in Flushing, New York
City.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">David S. Warren and Yanhong A. Liu (Editors). 33 pages. Including
  summaries by Christopher Kane and abstracts or position papers by M. Aref, J.
  Rosenwald, I. Cervesato, E.S.L. Lam, M. Balduccini, J. Lobo, A. Russo, E.
  Lupu, N. Leone, F. Ricca, G. Gupta, K. Marple, E. Salazar, Z. Chen, A. Sobhi,
  S. Srirangapalli, C.R. Ramakrishnan, N. Bj{\o}rner, N.P. Lopes, A.
  Rybalchenko, and P. Tarau</arxiv:comment>
    <link href="http://arxiv.org/abs/1704.02375v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1704.02375v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1704.07004v1</id>
    <updated>2017-04-24T00:33:36Z</updated>
    <published>2017-04-24T00:33:36Z</published>
    <title>Dependent Session Types</title>
    <summary>  Session types offer a type-based discipline for enforcing communication
protocols in distributed programming. We have previously formalized simple
session types in the setting of multi-threaded $\lambda$-calculus with linear
types. In this work, we build upon our earlier work by presenting a form of
dependent session types (of DML-style). The type system we formulate provides
linearity and duality guarantees with no need for any runtime checks or special
encodings. Our formulation of dependent session types is the first of its kind,
and it is particularly suitable for practical implementation. As an example, we
describe one implementation written in ATS that compiles to an Erlang/Elixir
back-end.
</summary>
    <author>
      <name>Hanwen Wu</name>
    </author>
    <author>
      <name>Hongwei Xi</name>
    </author>
    <link href="http://arxiv.org/abs/1704.07004v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1704.07004v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.1.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1704.08073v1</id>
    <updated>2017-04-26T12:17:20Z</updated>
    <published>2017-04-26T12:17:20Z</published>
    <title>Microservices: a Language-based Approach</title>
    <summary>  Microservices is an emerging development paradigm where software is obtained
by composing autonomous entities, called (micro)services. However, microservice
systems are currently developed using general-purpose programming languages
that do not provide dedicated abstractions for service composition. Instead,
current practice is focused on the deployment aspects of microservices, in
particular by using containerization. In this chapter, we make the case for a
language-based approach to the engineering of microservice architectures, which
we believe is complementary to current practice. We discuss the approach in
general, and then we instantiate it in terms of the Jolie programming language.
</summary>
    <author>
      <name>Claudio Guidi</name>
    </author>
    <author>
      <name>Ivan Lanese</name>
    </author>
    <author>
      <name>Manuel Mazzara</name>
    </author>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <link href="http://arxiv.org/abs/1704.08073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1704.08073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1707.03668v1</id>
    <updated>2017-07-12T12:14:20Z</updated>
    <published>2017-07-12T12:14:20Z</published>
    <title>Proceedings 15th Workshop on Quantitative Aspects of Programming
  Languages and Systems</title>
    <summary>  This volume of the EPTCS contains the proceedings of the 15th international
workshop on Qualitative Aspects of Programming Languages and Systems, QAPL
2017, held at April 23, 2017 in Uppsala, Sweden as a satellite event of ETAPS
2017, the 20th European Joint Conferencec on Theory and Practice of Software.
The volume contains two invited contributions by Erika Abraham and by Andrea
Vandin as well as six technical papers selected by the QAPL 2017 program
committee.
</summary>
    <author>
      <name>Herbert Wiklicky</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Imperial College London</arxiv:affiliation>
    </author>
    <author>
      <name>Erik de Vink</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Eindhoven University of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.250</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.250" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 250, 2017</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1707.03668v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1707.03668v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1708.02710v1</id>
    <updated>2017-08-09T04:03:13Z</updated>
    <published>2017-08-09T04:03:13Z</published>
    <title>From Reversible Programs to Univalent Universes and Back</title>
    <summary>  We establish a close connection between a reversible programming language
based on type isomorphisms and a formally presented univalent universe. The
correspondence relates combinators witnessing type isomorphisms in the
programming language to paths in the univalent universe; and combinator
optimizations in the programming language to 2-paths in the univalent universe.
The result suggests a simple computational interpretation of paths and of
univalence in terms of familiar programming constructs whenever the universe in
question is computable.
</summary>
    <author>
      <name>Jacques Carette</name>
    </author>
    <author>
      <name>Chao-Hong Chen</name>
    </author>
    <author>
      <name>Vikraman Choudhury</name>
    </author>
    <author>
      <name>Amr Sabry</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.entcs.2018.03.013</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.entcs.2018.03.013" rel="related"/>
    <link href="http://arxiv.org/abs/1708.02710v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1708.02710v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1708.03882v1</id>
    <updated>2017-08-13T10:29:06Z</updated>
    <published>2017-08-13T10:29:06Z</published>
    <title>Monadic Remote Invocation</title>
    <summary>  In order to achieve Separation of Concerns in the domain of remote method
invocation, a small functional adapter is added atop Java RMI, eliminating the
need for every remote object to implement java.rmi.Remote and making it
possible to remotely access existing code, unchanged. The Remote monad is
introduced, and its implementation and usage are detailed. Reusing the
existing, proven technology of RMI allows not to re-invent the underlying
network protocol. As a result, orthogonal remote invocation is achieved with
little or no implementation effort.
</summary>
    <author>
      <name>Raphael Jolly</name>
    </author>
    <link href="http://arxiv.org/abs/1708.03882v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1708.03882v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1708.07854v2</id>
    <updated>2017-08-31T11:57:03Z</updated>
    <published>2017-08-24T14:54:20Z</published>
    <title>Pre-proceedings of the 27th International Symposium on Logic-Based
  Program Synthesis and Transformation (LOPSTR 2017)</title>
    <summary>  This volume constitutes the pre-proceedings of the 27th International
Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2016),
held on 10-12th October 2017 in Namur, Belgium, and co-located with the 19th
International Symposium on Principles and Practice of Declarative Programming
(PPDP 2017). After discussion at the symposium papers will go through a second
round of refereeing and selection for the formal proceedings.
</summary>
    <author>
      <name>Fabio Fioravanti</name>
    </author>
    <author>
      <name>John P. Gallagher</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Papers selected for presentation at LOPSTR 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1708.07854v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1708.07854v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.00077v1</id>
    <updated>2017-09-29T20:14:47Z</updated>
    <published>2017-09-29T20:14:47Z</published>
    <title>Efficient Pattern Matching in Python</title>
    <summary>  Pattern matching is a powerful tool for symbolic computations. Applications
include term rewriting systems, as well as the manipulation of symbolic
expressions, abstract syntax trees, and XML and JSON data. It also allows for
an intuitive description of algorithms in the form of rewrite rules. We present
the open source Python module MatchPy, which offers functionality and
expressiveness similar to the pattern matching in Mathematica. In particular,
it includes syntactic pattern matching, as well as matching for commutative
and/or associative functions, sequence variables, and matching with
constraints. MatchPy uses new and improved algorithms to efficiently find
matches for large pattern sets by exploiting similarities between patterns. The
performance of MatchPy is investigated on several real-world problems.
</summary>
    <author>
      <name>Manuel Krebber</name>
    </author>
    <author>
      <name>Henrik Barthels</name>
    </author>
    <author>
      <name>Paolo Bientinesi</name>
    </author>
    <link href="http://arxiv.org/abs/1710.00077v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.00077v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.03912v3</id>
    <updated>2020-03-11T12:24:14Z</updated>
    <published>2017-10-11T05:31:26Z</published>
    <title>Consistency of the Predicative Calculus of Cumulative Inductive
  Constructions (pCuIC)</title>
    <summary>  In order to avoid well-know paradoxes associated with self-referential
definitions, higher-order dependent type theories stratify the theory using a
countably infinite hierarchy of universes (also known as sorts), Type$_0$ :
Type$_1$ : $\cdots$ . Such type systems are called cumulative if for any type
$A$ we have that $A$ : Type$_{i}$ implies $A$ : Type$_{i+1}$. The predicative
calculus of inductive constructions (pCIC) which forms the basis of the Coq
proof assistant, is one such system.
  In this paper we present and establish the soundness of the predicative
calculus of cumulative inductive constructions (pCuIC) which extends the
cumulativity relation to inductive types.
</summary>
    <author>
      <name>Amin Timany</name>
    </author>
    <author>
      <name>Matthieu Sozeau</name>
    </author>
    <link href="http://arxiv.org/abs/1710.03912v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.03912v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.03984v1</id>
    <updated>2017-10-11T09:57:51Z</updated>
    <published>2017-10-11T09:57:51Z</published>
    <title>Abductive functional programming, a semantic approach</title>
    <summary>  We propose a call-by-value lambda calculus extended with a new construct
inspired by abductive inference and motivated by the programming idioms of
machine learning. Although syntactically simple the abductive construct has a
complex and subtle operational semantics which we express using a style based
on the Geometry of Interaction. We show that the calculus is sound, in the
sense that well typed programs terminate normally. We also give a visual
implementation of the semantics which relies on additional garbage collection
rules, which we also prove sound.
</summary>
    <author>
      <name>Koko Muroya</name>
    </author>
    <author>
      <name>Steven Cheung</name>
    </author>
    <author>
      <name>Dan R. Ghica</name>
    </author>
    <link href="http://arxiv.org/abs/1710.03984v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.03984v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.06915v1</id>
    <updated>2017-10-16T22:29:25Z</updated>
    <published>2017-10-16T22:29:25Z</published>
    <title>MatchPy: A Pattern Matching Library</title>
    <summary>  Pattern matching is a powerful tool for symbolic computations, based on the
well-defined theory of term rewriting systems. Application domains include
algebraic expressions, abstract syntax trees, and XML and JSON data.
Unfortunately, no lightweight implementation of pattern matching as general and
flexible as Mathematica exists for Python Mathics,MacroPy,patterns,PyPatt.
Therefore, we created the open source module MatchPy which offers similar
pattern matching functionality in Python using a novel algorithm which finds
matches for large pattern sets more efficiently by exploiting similarities
between patterns.
</summary>
    <author>
      <name>Manuel Krebber</name>
    </author>
    <author>
      <name>Henrik Barthels</name>
    </author>
    <author>
      <name>Paolo Bientinesi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.25080/shinma-7f4c6e7-00b</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.25080/shinma-7f4c6e7-00b" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1710.00077</arxiv:comment>
    <link href="http://arxiv.org/abs/1710.06915v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.06915v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.07021v1</id>
    <updated>2017-10-19T07:41:12Z</updated>
    <published>2017-10-19T07:41:12Z</published>
    <title>E3Solver: decision tree unification by enumeration</title>
    <summary>  We introduce E3Solver, a unification-based solver for programming-by-example
(PBE) participating in the 2017 edition of the SyGuS Competition. Our tool
proceeds in two phases. First, for each individual example, we enumerate a
terminal expression consistent with it. Then, we unify these expressions using
conditional expressions in a decision tree. To this end, a suitable condition
is enumerated for each pair of conflicting examples. This incremental method
terminates after fitting all examples in the decision tree. E3Solver solves all
750 instances in the bitvector sub-track in an average time of few seconds
each. We make our contributions publicly available
(https://github.com/sygus-tools)
</summary>
    <author>
      <name>M. Ammar Ben Khadra</name>
    </author>
    <link href="http://arxiv.org/abs/1710.07021v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.07021v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1710.08444v1</id>
    <updated>2017-10-23T18:30:04Z</updated>
    <published>2017-10-23T18:30:04Z</published>
    <title>Locally Nameless Permutation Types</title>
    <summary>  We define "Locally Nameless Permutation Types", which fuse permutation types
as used in Nominal Isabelle with the locally nameless representation. We show
that this combination is particularly useful when formalizing programming
languages where bound names may become free during execution ("extrusion"),
common in process calculi. It inherits the generic definition of permutations
and support, and associated lemmas, from the Nominal approach, and the ability
to stay close to pencil-and-paper proofs from the locally nameless approach. We
explain how to use cofinite quantification in this setting, show why reasoning
about renaming is more important here than in languages without extrusion, and
provide results about infinite support, necessary when reasoning about
countable choice.
</summary>
    <author>
      <name>Edsko de Vries</name>
    </author>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Coq code in ancillary files</arxiv:comment>
    <link href="http://arxiv.org/abs/1710.08444v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1710.08444v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1711.03433v1</id>
    <updated>2017-11-09T15:52:18Z</updated>
    <published>2017-11-09T15:52:18Z</published>
    <title>h: A Plank for Higher-order Attribute Contraction Schemes</title>
    <summary>  We present and formalize h, a core (or "plank") calculus that can serve as
the foundation for several compiler specification languages, notably CRSX
(Combinatory Reductions Systems with eXtensions), HACS (Higher-order Attribute
Contraction Schemes), and TransScript. We discuss how the h typing and
formation rules introduce the necessary restrictions to ensure that rewriting
is well-defined, even in the presence of h's powerful extensions for
manipulating free variables and environments as first class elements (including
in pattern matching).
</summary>
    <author>
      <name>Cynthia Kop</name>
    </author>
    <author>
      <name>Kristoffer Rose</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">workshop proceedings for HOR 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1711.03433v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1711.03433v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1711.06115v2</id>
    <updated>2017-12-10T17:05:21Z</updated>
    <published>2017-11-12T12:15:09Z</published>
    <title>An introduction to approximate computing</title>
    <summary>  Approximate computing is a research area where we investigate a wide spectrum
of techniques to trade off computation accuracy for better performance or
energy consumption. In this work, we provide a general introduction to
approximate computing. Also, we propose a taxonomy to make it easier to discuss
the merits of different approximation techniques. Our taxonomy emphasizes the
expected cost of tackling approximate computing across the entire system stack.
We conclude by discussing the unique opportunities as well as challenges of
nondeterministic approximate computing.
</summary>
    <author>
      <name>M. Ammar Ben Khadra</name>
    </author>
    <link href="http://arxiv.org/abs/1711.06115v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1711.06115v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1711.09197v1</id>
    <updated>2017-11-25T06:20:10Z</updated>
    <published>2017-11-25T06:20:10Z</published>
    <title>Declarativeness: the work done by something else</title>
    <summary>  Being declarative means that we do computer programming on higher levels of
abstraction. This vague definition identifies declarativeness with the act of
ignoring details, but it is a special case of abstraction. The unspecified part
is some computational work. Automating computations and offloading mental
processing are essentially the same concept, which is fundamental for both
computational and mathematical thinking. This shows that declarativeness is not
just a particular style, but it is the core idea of programming. Here we
demonstrate this argument and examine its consequences for teaching by a
systematic study of coding examples from an introductory programming course.
The chosen language is Clojure, as it is proven to be accessible for novices.
</summary>
    <author>
      <name>Attila Egri-Nagy</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, first public draft, final version will be published
  elsewhere</arxiv:comment>
    <link href="http://arxiv.org/abs/1711.09197v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1711.09197v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.00077v1</id>
    <updated>2018-07-31T21:19:50Z</updated>
    <published>2018-07-31T21:19:50Z</published>
    <title>Multiparty Dependent Session Types (Extended Abstract)</title>
    <summary>  Programs are more distributed and concurrent today than ever before, and
structural communications are at the core. Constructing and debugging such
programs are hard due to the lack of formal specification/verification of
concurrency. This work formalizes the first multiparty dependent session types
as an expressive and practical type discipline for enforcing communication
protocols. The type system is formulated in the setting of multi-threaded
$\lambda$-calculus with inspirations from multirole logic, a generalization of
classical logic we discovered earlier. We prove its soundness by a novel
technique called deadlock-freeness reducibility. The soundness of the type
system implies communication fidelity and absence of deadlock.
</summary>
    <author>
      <name>Hanwen Wu</name>
    </author>
    <author>
      <name>Hongwei Xi</name>
    </author>
    <link href="http://arxiv.org/abs/1808.00077v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.00077v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.01232v1</id>
    <updated>2018-08-03T15:43:08Z</updated>
    <published>2018-08-03T15:43:08Z</published>
    <title>Data-Flow Guided Slicing</title>
    <summary>  We propose a flow-insensitive analysis that prunes out portions of code which
are irrelevant to a specified set of data-flow paths. Our approach is fast and
scalable, in addition to being able to generate a certificate as an audit for
the computed result. We have implemented our technique in a tool called DSlicer
and applied it to a set of 10600 real-world Android applications. Results are
conclusive, we found out that the program code can be significantly reduced by
36% on average with respect to a specified set of data leak paths.
</summary>
    <author>
      <name>Mohamed Nassim Seghir</name>
    </author>
    <link href="http://arxiv.org/abs/1808.01232v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.01232v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.03916v1</id>
    <updated>2018-08-12T09:38:34Z</updated>
    <published>2018-08-12T09:38:34Z</published>
    <title>Linguistic Relativity and Programming Languages</title>
    <summary>  The use of programming languages can wax and wane across the decades. We
examine the split-apply- combine pattern that is common in statistical
computing, and consider how its invocation or implementation in languages like
MATLAB and APL differ from R/dplyr. The differences in spelling illustrate how
the concept of linguistic relativity applies to programming languages in ways
that are analogous to human languages. Finally, we discuss how Julia, by being
a high performance yet general purpose dynamic language, allows its users to
express different abstractions to suit individual preferences.
</summary>
    <author>
      <name>Jiahao Chen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, repo at
  https://github.com/jiahao/statistical-computing-linguistics, Published in
  Proceedings of the 2016 Joint Statistical Meetings, Chicago, IL, USA</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.03916v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.03916v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.CO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.04190v1</id>
    <updated>2018-08-13T13:13:14Z</updated>
    <published>2018-08-13T13:13:14Z</published>
    <title>A prototype-based approach to object reclassification</title>
    <summary>  We investigate, in the context of functional prototype-based lan- guages, a
calculus of objects which might extend themselves upon receiving a message, a
capability referred to by Cardelli as a self-inflicted operation. We present a
sound type system for this calculus which guarantees that evaluating a
well-typed expression will never yield a message-not-found runtime error. The
resulting calculus is an attempt towards the definition of a language combining
the safety advantage of static type checking with the flexibility normally
found in dynamically typed languages.
</summary>
    <author>
      <name>Ciaffaglione Alberto</name>
    </author>
    <author>
      <name>Di Gianantonio Pietro</name>
    </author>
    <author>
      <name>Honsell Furio</name>
    </author>
    <author>
      <name>Liquori Luigi</name>
    </author>
    <link href="http://arxiv.org/abs/1808.04190v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.04190v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.05065v2</id>
    <updated>2018-11-08T06:45:55Z</updated>
    <published>2018-08-15T13:13:37Z</published>
    <title>Guided Unfoldings for Finding Loops in Standard Term Rewriting</title>
    <summary>  In this paper, we reconsider the unfolding-based technique that we have
introduced previously for detecting loops in standard term rewriting. We
improve it by guiding the unfolding process, using distinguished positions in
the rewrite rules. This results in a depth-first computation of the unfoldings,
whereas the original technique was breadth-first. We have implemented this new
approach in our tool NTI and compared it to the previous one on a bunch of
rewrite systems. The results we get are promising (better times, more
successful proofs).
</summary>
    <author>
      <name>Etienne Payet</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 28th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2018), Frankfurt
  am Main, Germany, 4-6 September 2018 (arXiv:1808.03326)</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.05065v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.05065v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.06052v5</id>
    <updated>2018-09-07T02:54:21Z</updated>
    <published>2018-08-18T07:19:08Z</published>
    <title>Doubly F-Bounded Generics</title>
    <summary>  In this paper we suggest how f-bounded generics in nominally-typed OOP can be
extended to the more general notion we call `doubly f-bounded generics' and we
suggest how doubly f-bounded generics can be reasoned about. We also (attempt
to) prove, using a coinductive argument, that our reasoning method is
mathematically sound.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.06052v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.06052v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.06348v1</id>
    <updated>2018-08-20T08:48:48Z</updated>
    <published>2018-08-20T08:48:48Z</published>
    <title>Every Data Structure Deserves Lock-Free Memory Reclamation</title>
    <summary>  Memory-management support for lock-free data structures is well known to be a
tough problem. Recent work has successfully reduced the overhead of such
schemes. However, applying memory-management support to a data structure
remains complex and, in many cases, requires redesigning the data structure. In
this paper, we present the first lock-free memory-management scheme that is
applicable to general (arbitrary) lock-free data structures and that can be
applied automatically via a compiler plug-in. In addition to the simplicity of
incorporating to data structures, this scheme provides low overhead and does
not rely on the lock freedom of any OS services.
</summary>
    <author>
      <name>Nachshon Cohen</name>
    </author>
    <link href="http://arxiv.org/abs/1808.06348v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.06348v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.07401v1</id>
    <updated>2018-08-22T15:13:56Z</updated>
    <published>2018-08-22T15:13:56Z</published>
    <title>Synthesizing Set Functions</title>
    <summary>  Set functions are a feature of functional logic programming to encapsulate
all results of a non-deterministic computation in a single data structure.
Given a function $f$ of a functional logic program written in Curry, we
describe a technique to synthesize the definition of the set function of $f$.
The definition produced by our technique is based on standard Curry constructs.
Our approach is interesting for three reasons. It allows reasoning about set
functions, it offers an implementation of set functions which can be added to
any Curry system, and it has the potential of changing our thinking about the
implementation of non-determinism, a notoriously difficult problem.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <author>
      <name>Michael Hanus</name>
    </author>
    <author>
      <name>Finn Teegen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages, Accepted for presentation in WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.07401v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.07401v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.07771v1</id>
    <updated>2018-08-23T14:10:39Z</updated>
    <published>2018-08-23T14:10:39Z</published>
    <title>FMS: Functional Programming as a Modelling Language</title>
    <summary>  In this paper we introduce the Functional Modelling System (FMS). The system
introduces the Functional Modelling Language (FML), which is a modelling
language for NP-complete search problems based on concepts of functional
programming. Internally, we translate FML specifications to an Answer Set
Program to obtain models. We give a general overview of the new FML language,
and how this language is handled in the system. We give a step-by-step
walkthrough of the system, pointing out what features are in place, and what
improvements are still possible.
</summary>
    <author>
      <name>Ingmar Dasseville</name>
    </author>
    <author>
      <name>Gerda Janssens</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, Accepted for presentation in WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.07771v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.07771v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.08330v1</id>
    <updated>2018-08-24T22:46:13Z</updated>
    <published>2018-08-24T22:46:13Z</published>
    <title>Code Generation for Higher Inductive Types</title>
    <summary>  Higher inductive types are inductive types that include nontrivial
higher-dimensional structure, represented as identifications that are not
reflexivity. While work proceeds on type theories with a computational
interpretation of univalence and higher inductive types, it is convenient to
encode these structures in more traditional type theories with mature
implementations. However, these encodings involve a great deal of error-prone
additional syntax. We present a library that uses Agda's metaprogramming
facilities to automate this process, allowing higher inductive types to be
specified with minimal additional syntax.
</summary>
    <author>
      <name>Paventhan Vivekanandan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, Accepted for presentation in WFLP 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.08330v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.08330v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.08651v1</id>
    <updated>2018-08-27T01:20:00Z</updated>
    <published>2018-08-27T01:20:00Z</published>
    <title>Reversing Parallel Programs with Blocks and Procedures</title>
    <summary>  We show how to reverse a while language extended with blocks, local
variables, procedures and the interleaving parallel composition. Annotation is
defined along with a set of operational semantics capable of storing necessary
reversal information, and identifiers are introduced to capture the
interleaving order of an execution. Inversion is defined with a set of
operational semantics that use saved information to undo an execution. We prove
that annotation does not alter the behaviour of the original program, and that
inversion correctly restores the initial program state.
</summary>
    <author>
      <name>James Hoey</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Leicester</arxiv:affiliation>
    </author>
    <author>
      <name>Irek Ulidowski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Leicester</arxiv:affiliation>
    </author>
    <author>
      <name>Shoji Yuen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Nagoya University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.276.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.276.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS 2018, arXiv:1808.08071</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 276, 2018, pp. 69-86</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1808.08651v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.08651v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.09234v1</id>
    <updated>2018-08-28T11:45:33Z</updated>
    <published>2018-08-28T11:45:33Z</published>
    <title>A Short Note on Collecting Dependently Typed Values</title>
    <summary>  Within dependently typed languages, such as Idris, types can depend on
values. This dependency, however, can limit the collection of items in standard
containers: all elements must have the same type, and as such their types must
contain the same values. We present two dependently typed data structures for
collecting dependent types: \texttt{DList} and \texttt{PList}. Use of these new
data structures allow for the creation of single succinct inductive ADT whose
constructions were previously verbose and split across many data structures.
</summary>
    <author>
      <name>Jan de Muijnck-Hughes</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A short paper illustrating minor semi-unpublished work</arxiv:comment>
    <link href="http://arxiv.org/abs/1808.09234v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.09234v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1808.09870v1</id>
    <updated>2018-08-29T15:04:58Z</updated>
    <published>2018-08-29T15:04:58Z</published>
    <title>Memory Consistency Models using Constraints</title>
    <summary>  Memory consistency models (MCMs) are at the heart of concurrent programming.
They represent the behaviour of concurrent programs at the chip level. To test
these models small program snippets called litmus test are generated, which
show allowed or forbidden behaviour of different MCMs. This paper is showcasing
the use of constraint programming to automate the generation and testing of
litmus tests for memory consistency models. We produce a few exemplary case
studies for two MCMs, namely Sequential Consistency and Total Store Order.
These studies demonstrate the flexibility of constrains programming in this
context and lay foundation to the direct verification of MCMs against the
software facing cache coherence protocols.
</summary>
    <author>
      <name>Ruth Hoffmann</name>
    </author>
    <author>
      <name>Özgür Akgün</name>
    </author>
    <author>
      <name>Susmit Sarkar</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ModRef 2018, The 17th workshop on Constraint Modelling and
  Reformulation, 2018</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1808.09870v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1808.09870v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.04308v1</id>
    <updated>2018-10-10T00:34:48Z</updated>
    <published>2018-10-10T00:34:48Z</published>
    <title>A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2
  in Java</title>
    <summary>  AIJ (ACL2 In Java) is a deep embedding in Java of an executable,
side-effect-free, non-stobj-accessing subset of the ACL2 language without
guards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2
functions into AIJ representations that are evaluated by the AIJ interpreter.
AIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate
with, Java code, without much of the ACL2 framework or any of the Lisp runtime.
The current speed of the resulting Java code may be adequate to some
applications.
</summary>
    <author>
      <name>Alessandro Coglio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Kestrel Institute</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.280.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.280.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ACL2 2018, arXiv:1810.03762</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 280, 2018, pp. 1-17</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1810.04308v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.04308v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.05555v2</id>
    <updated>2018-10-16T10:13:18Z</updated>
    <published>2018-10-12T14:42:45Z</published>
    <title>Semantic subtyping for non-strict languages</title>
    <summary>  Semantic subtyping is an approach to define subtyping relations for type
systems featuring union and intersection type connectives. It has been studied
only for strict languages, and it is unsound for non-strict semantics. In this
work, we study how to adapt this approach to non-strict languages: in
particular, we define a type system using semantic subtyping for a functional
language with a call-by-need semantics. We do so by introducing an explicit
representation for divergence in the types, so that the type system
distinguishes expressions that are results from those which are computations
that might diverge.
</summary>
    <author>
      <name>Tommaso Petrucciani</name>
    </author>
    <author>
      <name>Giuseppe Castagna</name>
    </author>
    <author>
      <name>Davide Ancona</name>
    </author>
    <author>
      <name>Elena Zucca</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4230/LIPIcs.TYPES.2018.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4230/LIPIcs.TYPES.2018.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of a submission to the post-proceedings of TYPES'18</arxiv:comment>
    <link href="http://arxiv.org/abs/1810.05555v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.05555v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.07951v4</id>
    <updated>2019-03-09T13:25:32Z</updated>
    <published>2018-10-18T08:48:12Z</published>
    <title>Don't Unroll Adjoint: Differentiating SSA-Form Programs</title>
    <summary>  This paper presents reverse-mode algorithmic differentiation (AD) based on
source code transformation, in particular of the Static Single Assignment (SSA)
form used by modern compilers. The approach can support control flow, nesting,
mutation, recursion, data structures, higher-order functions, and other
language constructs, and the output is given to an existing compiler to produce
highly efficient differentiated code. Our implementation is a new AD tool for
the Julia language, called Zygote, which presents high-level dynamic semantics
while transparently compiling adjoint code under the hood. We discuss the
benefits of this approach to both the usability and performance of AD tools.
</summary>
    <author>
      <name>Michael Innes</name>
    </author>
    <link href="http://arxiv.org/abs/1810.07951v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.07951v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.09611v1</id>
    <updated>2018-10-23T00:47:50Z</updated>
    <published>2018-10-23T00:47:50Z</published>
    <title>Some Challenges of Specifying Concurrent Program Components</title>
    <summary>  The purpose of this paper is to address some of the challenges of formally
specifying components of shared-memory concurrent programs. The focus is to
provide an abstract specification of a component that is suitable for use both
by clients of the component and as a starting point for refinement to an
implementation of the component. We present some approaches to devising
specifications, investigating different forms suitable for different contexts.
We examine handling atomicity of access to data structures, blocking operations
and progress properties, and transactional operations that may fail and need to
be retried.
</summary>
    <author>
      <name>Ian J. Hayes</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">The University of Queensland</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.282.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.282.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Refine 2018, arXiv:1810.08739</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 282, 2018, pp. 10-22</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1810.09611v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.09611v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1810.12190v1</id>
    <updated>2018-10-29T15:29:24Z</updated>
    <published>2018-10-29T15:29:24Z</published>
    <title>To Memory Safety through Proofs</title>
    <summary>  We present a type system capable of guaranteeing the memory safety of
programs that may involve (sophisticated) pointer manipulation such as pointer
arithmetic. With its root in a recently developed framework Applied Type System
(ATS), the type system imposes a level of abstraction on program states through
a novel notion of recursive stateful views and then relies on a form of linear
logic to reason about such stateful views. We consider the design and then the
formalization of the type system to constitute the primary contribution of the
paper. In addition, we also mention a running implementation of the type system
and then give some examples in support of the practicality of programming with
recursive stateful views.
</summary>
    <author>
      <name>Hongwei Xi</name>
    </author>
    <author>
      <name>Dengping Zhu</name>
    </author>
    <link href="http://arxiv.org/abs/1810.12190v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1810.12190v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.00043v1</id>
    <updated>2019-08-30T19:21:07Z</updated>
    <published>2019-08-30T19:21:07Z</published>
    <title>Declarative Programming for Microcontrollers -- Datalog on Arduino</title>
    <summary>  In this paper we describe an approach to programming microcontrollers based
on the Arduino platform using Datalog as a clear and concise description
language for system behaviors. The application areas of cheap and easily
programmable microcontrollers, like robotics, home automation, and IoT devices
hold mainstream appeal and are often used as motivation in natural science and
technology teaching. The choice of programming languages for microcontrollers
is severely limited, especially with regard to rule-based declarative
languages. We use an approach that is based on the Dedalus language augmented
with operations that allow for side-effects and takes the limited resources of
a microcontroller into account. Our compiler and runtime environment allow to
run Datalog programs on Arduino-based systems.
</summary>
    <author>
      <name>Mario Wenzel</name>
    </author>
    <author>
      <name>Stefan Brass</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of DECLARE 19 proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/1909.00043v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.00043v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.01465v2</id>
    <updated>2019-10-15T06:44:42Z</updated>
    <published>2019-09-03T21:37:55Z</published>
    <title>Towards Gradual Checking of Reference Capabilities</title>
    <summary>  Concurrent and parallel programming is difficult due to the presence of
memory side-effects, which may introduce data races. Type qualifiers, such as
reference capabilities, can remove data races by restricting sharing of mutable
data. Unfortunately, reference capability languages are an all-in or nothing
game, i.e., all the types must be annotated with reference capabilities. In
this work in progress, we propose to mix the ideas from the reference
capability literature with gradual typing, leading to gradual reference
capabilities.
</summary>
    <author>
      <name>Kiko Fernandez-Reyes</name>
    </author>
    <author>
      <name>Isaac Oscar Gariano</name>
    </author>
    <author>
      <name>James Noble</name>
    </author>
    <author>
      <name>Tobias Wrigstad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">draft</arxiv:comment>
    <link href="http://arxiv.org/abs/1909.01465v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.01465v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.03721v1</id>
    <updated>2019-09-09T09:36:56Z</updated>
    <published>2019-09-09T09:36:56Z</published>
    <title>CISE3: Verificação de aplicações com consistência fraca em
  Why3</title>
    <summary>  In this article we present a tool for the verification of programs built on
top replicated databases. The tool evaluates a sequential specification and
deduces which operations need to be synchronized for the program to function
properly in a distributed environment. Our prototype is built over the
deductive verification platform Why3. The Why3 Framework provides a
sophisticated user experience, the possibility to scale to realistic case
studies, as well as a high degree of automation. A case study is presented and
discussed, with the purpose of experimentally validating our approach.
</summary>
    <author>
      <name>Filipe Meirim</name>
    </author>
    <author>
      <name>Mário Pereira</name>
    </author>
    <author>
      <name>Carla Ferreira</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Article in Portuguese, accepted in the national informatics
  conference INForum 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1909.03721v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.03721v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.08671v1</id>
    <updated>2019-09-18T19:49:03Z</updated>
    <published>2019-09-18T19:49:03Z</published>
    <title>Mi-Cho-Coq, a framework for certifying Tezos Smart Contracts</title>
    <summary>  Tezos is a blockchain launched in June 2018. It is written in OCaml and
supports smart contracts. Its smart contract language is called Michelson and
it has been designed with formal verification in mind. In this article, we
present Mi-Cho-Coq, a Coq framework for verifying the functional correctness of
Michelson smart contracts. As a case study, we detail the certification of a
Multisig contract with the Mi-Cho-Coq framework.
</summary>
    <author>
      <name>Bruno Bernardo</name>
    </author>
    <author>
      <name>Raphaël Cauderlier</name>
    </author>
    <author>
      <name>Zhenlei Hu</name>
    </author>
    <author>
      <name>Basile Pesin</name>
    </author>
    <author>
      <name>Julien Tesson</name>
    </author>
    <link href="http://arxiv.org/abs/1909.08671v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.08671v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.08789v1</id>
    <updated>2019-09-19T03:44:51Z</updated>
    <published>2019-09-19T03:44:51Z</published>
    <title>Proof Pearl: Magic Wand as Frame</title>
    <summary>  Separation logic adds two connectives to assertion languages: separating
conjunction * ("star") and its adjoint, separating implication -* ("magic
wand"). Comparatively, separating implication is less widely used.
  This paper demonstrates that by using magic wand to express frames that
relate mutable local portions of data structures to global portions, we can
exploit its power while proofs are still easily understandable. Many useful
separation logic theorems about partial data structures can now be proved by
simple automated tactics, which were usually proved by induction. This
magic-wand-as-frame technique is especially useful when formalizing the proofs
by a high order logic. We verify binary search tree insert in Coq as an example
to demonstrate this proof technique.
</summary>
    <author>
      <name>Qinxiang Cao</name>
    </author>
    <author>
      <name>Shengyi Wang</name>
    </author>
    <author>
      <name>Aquinas Hobor</name>
    </author>
    <author>
      <name>Andrew W. Appel</name>
    </author>
    <link href="http://arxiv.org/abs/1909.08789v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.08789v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.09324v1</id>
    <updated>2019-09-20T05:20:34Z</updated>
    <published>2019-09-20T05:20:34Z</published>
    <title>Automated Verification of Integer Overflow</title>
    <summary>  Integer overflow accounts for one of the major source of bugs in software.
Verification systems typically assume a well defined underlying semantics for
various integer operations and do not explicitly check for integer overflow in
programs. In this paper we present a specification mechanism for expressing
integer overflow. We develop an automated procedure for integer overflow
checking during program verification. We have implemented a prototype integer
overflow checker and tested it on a benchmark consisting of already verified
programs (over 14k LOC). We have found 43 bugs in these programs due to integer
overflow.
</summary>
    <author>
      <name>Asankhaya Sharma</name>
    </author>
    <link href="http://arxiv.org/abs/1909.09324v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.09324v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1909.09562v1</id>
    <updated>2019-09-20T15:37:21Z</updated>
    <published>2019-09-20T15:37:21Z</published>
    <title>Equivalence Checking of Non-deterministic Operations</title>
    <summary>  Checking the semantic equivalence of operations is an important task in
software development. For instance, regression testing is a routine task
performed when software systems are developed and improved, and software
package managers require the equivalence of operations in different versions of
a package within the same major number version. A solid foundation is required
to support a good automation of this process. It has been shown that the notion
of equivalence is not obvious when non-deterministic features are present. In
this paper, we discuss a general notion of equivalence in functional logic
programs and develop a practical method to check it. Our method is integrated
in a property-based testing tool which is used in a software package manager to
check the semantic versioning of software packages.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <author>
      <name>Michael Hanus</name>
    </author>
    <link href="http://arxiv.org/abs/1909.09562v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1909.09562v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2006.02204v1</id>
    <updated>2020-06-03T12:20:45Z</updated>
    <published>2020-06-03T12:20:45Z</published>
    <title>Controlling the Size of Supercompiled Programs using Multi-result
  Supercompilation</title>
    <summary>  Supercompilation is a powerful program transformation technique with numerous
interesting applications. Existing methods of supercompilation, however, are
often very unpredictable with respect to the size of the resulting programs. We
consider an approach for controlling result size, based on a combination of
multi-result supercompilation and a specific generalization strategy, which
avoids code duplication. The current early experiments with this method show
promising results -- we can keep the size of the result small, while still
performing powerful optimizations.
</summary>
    <author>
      <name>Dimitur Krustev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of paper submitted to VPT 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2006.02204v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2006.02204v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.00862v1</id>
    <updated>2017-06-02T21:49:53Z</updated>
    <published>2017-06-02T21:49:53Z</published>
    <title>Efficient Textual Representation of Structure</title>
    <summary>  This paper attempts a more formal approach to the legibility of text based
programming languages, presenting, with proof, minimum possible ways of
representing structure in text interleaved with information. This presumes that
a minimalist approach is best for purposes of human readability, data storage
and transmission, and machine evaluation.
  Several proposals are given for improving the expression of interleaved
hierarchical structure. For instance, a single colon can replace a pair of
brackets, and bracket types do not need to be repeated in both opening and
closing symbols or words. Historic and customary uses of punctuation symbols
guided the chosen form and nature of the improvements.
</summary>
    <author>
      <name>Brenton Chapin</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">submitted to 10th ACM SIGPLAN International Conference on Software
  Language Engineering (SLE), 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.00862v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.00862v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.IT" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.IT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.03272v1</id>
    <updated>2017-06-10T19:00:51Z</updated>
    <published>2017-06-10T19:00:51Z</published>
    <title>Computational Thinking in Patch</title>
    <summary>  With the future likely to see even more pervasive computation, computational
thinking (problem-solving skills incorporating computing knowledge) is now
being recognized as a fundamental skill needed by all students. Computational
thinking is conceptualizing as opposed to programming, promotes natural human
thinking style than algorithmic reasoning, complements and combines
mathematical and engineering thinking, and it emphasizes ideas, not artifacts.
In this paper, we outline a new visual language, called Patch, using which
students are able to express their solutions to eScience computational problems
in abstract visual tools. Patch is closer to high level procedural languages
such as C++ or Java than Scratch or Snap! but similar to them in ease of use
and combines simplicity and expressive power in one single platform.
</summary>
    <author>
      <name>Hasan M. Jamil</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.03272v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.03272v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.05271v1</id>
    <updated>2017-06-16T13:33:45Z</updated>
    <published>2017-06-16T13:33:45Z</published>
    <title>A Coq-based synthesis of Scala programs which are
  correct-by-construction</title>
    <summary>  The present paper introduces Scala-of-Coq, a new compiler that allows a
Coq-based synthesis of Scala programs which are "correct-by-construction". A
typical workflow features a user implementing a Coq functional program, proving
this program's correctness with regards to its specification and making use of
Scala-of-Coq to synthesize a Scala program that can seamlessly be integrated
into an existing industrial Scala or Java application.
</summary>
    <author>
      <name>Youssef El Bakouny</name>
    </author>
    <author>
      <name>Tristan Crolard</name>
    </author>
    <author>
      <name>Dani Mezher</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3103111.3104041</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3103111.3104041" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">2 pages, accepted version of the paper as submitted to FTfJP 2017
  (Formal Techniques for Java-like Programs), June 18-23, 2017, Barcelona ,
  Spain</arxiv:comment>
    <link href="http://arxiv.org/abs/1706.05271v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.05271v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1706.05851v1</id>
    <updated>2017-06-19T09:39:01Z</updated>
    <published>2017-06-19T09:39:01Z</published>
    <title>Generic Approach to Certified Static Checking of Module-like Constructs</title>
    <summary>  In this paper we consider the problem of certified static checking of
module-like constructs of programming languages. We argue that there are
algorithms and properties related to modules that can be defined and proven in
an abstract way. We advocate the design of a generic Coq library, which is
aimed to provide three building blocks for each checking mechanism:
propositional, computable, and correctness proofs. Implemented part of the
library is justified by applying it to a certified static checker of an
extension of STLC.
</summary>
    <author>
      <name>Julia Belyakova</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3103111.3104045</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3103111.3104045" rel="related"/>
    <link href="http://arxiv.org/abs/1706.05851v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1706.05851v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.04152v1</id>
    <updated>2017-09-13T06:36:33Z</updated>
    <published>2017-09-13T06:36:33Z</published>
    <title>Deadlock detection of Java Bytecode</title>
    <summary>  This paper presents a technique for deadlock detection of Java programs. The
technique uses typing rules for extracting infinite-state abstract models of
the dependencies among the components of the Java intermediate language -- the
Java bytecode. Models are subsequently analysed by means of an extension of a
solver that we have defined for detecting deadlocks in process calculi. Our
technique is complemented by a prototype verifier that also covers most of the
Java features.
</summary>
    <author>
      <name>Abel Garcia</name>
    </author>
    <author>
      <name>Cosimo Laneve</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 27th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2017), Namur,
  Belgium, 10-12 October 2017 (arXiv:1708.07854)</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.04152v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.04152v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.04619v2</id>
    <updated>2018-12-26T09:02:39Z</updated>
    <published>2017-09-14T05:39:55Z</published>
    <title>Extending Functional Languages with High-Level Exception Handling</title>
    <summary>  We extend functional languages with high-level exception handling. To be
specific, we allow sequential-disjunction expressions of the form $E_0
\bigtriangledown E_1$ where $E_0, E_1$ are expressions. These expressions have
the following intended semantics: sequentially $choose$ the first successful
$E_i$ and evaluate $E_i$ where $i$ = 0 or 1. These expressions thus allow us to
specify an expression $E_0$ with the failure-handling (exception handling)
routine, i.e., expression $E_1$. We also discuss the class of
sequential-conjunction function declarations which is a dual of the former.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages. We discuss the notion of exception handling and its dual in
  functional languages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.04619v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.04619v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.05123v2</id>
    <updated>2017-10-03T07:24:14Z</updated>
    <published>2017-09-15T09:30:48Z</published>
    <title>Confluence and Convergence in Probabilistically Terminating Reduction
  Systems</title>
    <summary>  Convergence of an abstract reduction system (ARS) is the property that any
derivation from an initial state will end in the same final state, a.k.a.
normal form. We generalize this for probabilistic ARS as almost-sure
convergence, meaning that the normal form is reached with probability one, even
if diverging derivations may exist. We show and exemplify properties that can
be used for proving almost-sure convergence of probabilistic ARS, generalizing
known results from ARS.
</summary>
    <author>
      <name>Maja H. Kirkeby</name>
    </author>
    <author>
      <name>Henning Christiansen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 27th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2017), Namur,
  Belgium, 10-12 October 2017 (arXiv:1708.07854)</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.05123v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.05123v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.05384v1</id>
    <updated>2017-09-15T20:09:44Z</updated>
    <published>2017-09-15T20:09:44Z</published>
    <title>Nominal C-Unification</title>
    <summary>  Nominal unification is an extension of first-order unification that takes
into account the \alpha-equivalence relation generated by binding operators,
following the nominal approach. We propose a sound and complete procedure for
nominal unification with commutative operators, or nominal C-unification for
short, which has been formalised in Coq. The procedure transforms nominal
C-unification problems into simpler (finite families) of fixpoint problems,
whose solutions can be generated by algebraic techniques on combinatorics of
permutations.
</summary>
    <author>
      <name>Mauricio Ayala-Rincón</name>
    </author>
    <author>
      <name>Washington de Carvalho-Segundo</name>
    </author>
    <author>
      <name>Maribel Fernández</name>
    </author>
    <author>
      <name>Daniele Nantes-Sobrinho</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 27th International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2017), Namur,
  Belgium, 10-12 October 2017 (arXiv:1708.07854)</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.05384v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.05384v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1709.08056v4</id>
    <updated>2017-12-29T17:46:21Z</updated>
    <published>2017-09-23T14:10:29Z</published>
    <title>Novel Uses of Category Theory in Modeling OOP</title>
    <summary>  An outline and summary of four new potential applications of category theory
to OOP research are presented. These include (1) the use of operads to model
Java subtyping, (2) the use of Yoneda's lemma and representable functors in the
modeling of generic types in generic nominally-typed OOP, (3) using a
combination of category presentations and cartesian closed categories to model
structurally-typed OOP, and (4) the use of adjoint functors to model Java
erasure.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1709.08056v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1709.08056v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1901.05082v1</id>
    <updated>2019-01-15T23:03:02Z</updated>
    <published>2019-01-15T23:03:02Z</published>
    <title>Translation Validation for Security Properties</title>
    <summary>  Secure compilation aims to build compilation chains that preserve security
properties when translating programs from a source to a target language. Recent
research led to the definition of secure compilation principles that, if met,
guarantee that the compilation chain in hand never violates specific families
of security properties. Still, to the best of our knowledge, no effective
procedure is available to check if a compilation chain meets such requirements.
Here, we outline our ongoing research inspired by translation validation, to
effectively check one of those principles.
</summary>
    <author>
      <name>Matteo Busi</name>
    </author>
    <author>
      <name>Pierpaolo Degano</name>
    </author>
    <author>
      <name>Letterio Galletta</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at PriSC Workshop 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1901.05082v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1901.05082v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1901.06839v2</id>
    <updated>2019-01-24T08:30:55Z</updated>
    <published>2019-01-21T09:36:17Z</published>
    <title>Technical Report: Using Loop Scopes with for-Loops</title>
    <summary>  Loop scopes have been shown to be a helpful tool in creating sound loop
invariant rules which do not require program transformation of the loop body.
Here we extend this idea from while-loops to for-loops and also present sound
loop unrolling rules for while- and for-loops, which require neither program
transformation of the loop body, nor the use of nested modalities. This
approach allows for-loops to be treated as first-class citizens -- rather than
the usual approach of transforming for-loops into while-loops -- which makes
semi-automated proofs easier to follow for the user, who may need to provide
help in order to finish the proof.
</summary>
    <author>
      <name>Nathan Wasser</name>
    </author>
    <author>
      <name>Dominic Steinhöfel</name>
    </author>
    <link href="http://arxiv.org/abs/1901.06839v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1901.06839v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1911.03926v1</id>
    <updated>2019-11-10T13:19:02Z</updated>
    <published>2019-11-10T13:19:02Z</published>
    <title>Gemini: A Functional Programming Language for Hardware Description</title>
    <summary>  This paper presents Gemini, a functional programming language for hardware
description that provides features such as parametric polymorphism, recursive
datatypes, higher-order functions, and type inference for higher expressivity
compared to modern hardware description languages. Gemini demonstrates the
theory and implementation of novel type-theoretical concepts through its unique
type system consisting of multiple atomic kinds and dependent types, which
allows the language to model both software and hardware constructs safely and
perform type inference through multi-staged compilation. The primary technical
results of this paper include formalizations of the Gemini grammar, typing
rules, and evaluation rules, a proof of safety of Gemini's type system, and a
prototype implementation of the compiler's semantic analysis phase.
</summary>
    <author>
      <name>Aditya Srinivasan</name>
    </author>
    <author>
      <name>Andrew D. Hilton</name>
    </author>
    <link href="http://arxiv.org/abs/1911.03926v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1911.03926v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1911.12932v1</id>
    <updated>2019-11-29T03:00:51Z</updated>
    <published>2019-11-29T03:00:51Z</published>
    <title>Juniper: A Functional Reactive Programming Language for the Arduino</title>
    <summary>  This paper presents the design and implementation of Juniper: a functional
reactive programming language (FRP) targeting the Arduino and related
microcontroller systems. Juniper provides a number of high level features,
including parametric polymorphic functions, anonymous functions, automatic
memory management, and immutable data structures. Also included is a standard
library which offers many useful FRP signal processing functions. Juniper is
translated to standard C++ and compiled with the existing Arduino development
tools, allowing Juniper programs to fit on resource-constrained devices, and
enabling seamless interoperability with existing C++ libraries for these
devices.
</summary>
    <author>
      <name>Caleb Helbling</name>
    </author>
    <author>
      <name>Samuel Z Guyer</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2975980.2975982</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2975980.2975982" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages, ICFP FARM 2016</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the 4th International Workshop on Functional Art,
  Music, Modelling, and Design, 2016</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1911.12932v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1911.12932v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.1694v1</id>
    <updated>2014-03-07T09:30:38Z</updated>
    <published>2014-03-07T09:30:38Z</published>
    <title>Methods of executable code protection</title>
    <summary>  The article deals with the problems in constructing a protection system of
executable code. The techniques of breaking the integrity of executable code
and ways to eliminate them are described. The adoption of virtual machine
technology in the context of executable code protection from analysis is
considered. The substantiation of the application of virtual machines as the
best way to oppose the analysis of executable code is made. The protection of
executable code by transferring the protected code in a virtual execution
environment is considered. An efficient implementation of the method is
proposed.
</summary>
    <author>
      <name>Anton Petrov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1403.1694v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.1694v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="00-02" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1403.6997v1</id>
    <updated>2014-03-27T12:24:41Z</updated>
    <published>2014-03-27T12:24:41Z</published>
    <title>Optimizing large applications</title>
    <summary>  Both uppermost open source compilers, GCC and LLVM, are mature enough to
link-time optimize large applications. In case of large applications, we must
take into account, except standard speed efficiency and memory consumption,
different aspects. We focus on size of the code, cold start-up time, etc.
Developers of applications often come up with ad-hoc solutions such as Elfhack
utility, start-up of an application via a pre-loading utility and dlopen;
prelinking and variety of different tools that reorder functions to fit the
order of execution. The goal of the thesis is to analyse all existing
techniques of optimization, evaluate their efficiency and design new solutions
based on the link-time optimization platform.
</summary>
    <author>
      <name>Martin Liška</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">78 pages, diploma thesis</arxiv:comment>
    <link href="http://arxiv.org/abs/1403.6997v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1403.6997v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.0625v1</id>
    <updated>2014-12-01T20:20:04Z</updated>
    <published>2014-12-01T20:20:04Z</published>
    <title>Quipper: Concrete Resource Estimation in Quantum Algorithms</title>
    <summary>  Despite the rich literature on quantum algorithms, there is a surprisingly
small amount of coverage of their concrete logical design and implementation.
Most resource estimation is done at the level of complexity analysis, but
actual concrete numbers (of quantum gates, qubits, etc.) can differ by orders
of magnitude. The line of work we present here is a formal framework to write,
and reason about, quantum algorithms. Specifically, we designed a language,
Quipper, with scalability in mind, and we are able to report actual resource
counts for seven non-trivial algorithms found in the quantum computer science
literature.
</summary>
    <author>
      <name>Jonathan M. Smith</name>
    </author>
    <author>
      <name>Neil J. Ross</name>
    </author>
    <author>
      <name>Peter Selinger</name>
    </author>
    <author>
      <name>Benoît Valiron</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract for a talk given at QAPL 2014</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.0625v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.0625v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.ET" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4395v1</id>
    <updated>2014-12-14T19:04:47Z</updated>
    <published>2014-12-14T19:04:47Z</published>
    <title>Dafny: Statically Verifying Functional Correctness</title>
    <summary>  This report presents the Dafny language and verifier, with a focus on
describing the main features of the language, including pre- and
postconditions, assertions, loop invariants, termination metrics, quantifiers,
predicates and frames. Examples of Dafny code are provided to illustrate the
use of each feature, and an overview of how Dafny translates programming code
into a mathematical proof of functional verification is presented. The report
also includes references to useful resources on Dafny, with mentions of related
works in the domain of specification languages.
</summary>
    <author>
      <name>Rachel Gauci</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1412.4395v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4395v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1412.4882v1</id>
    <updated>2014-12-16T05:14:44Z</updated>
    <published>2014-12-16T05:14:44Z</published>
    <title>Simple Balanced Binary Search Trees</title>
    <summary>  Efficient implementations of sets and maps (dictionaries) are important in
computer science, and balanced binary search trees are the basis of the best
practical implementations. Pedagogically, however, they are often quite
complicated, especially with respect to deletion. I present complete code (with
justification and analysis not previously available in the literature) for a
purely-functional implementation based on AA trees, which is the simplest
treatment of the subject of which I am aware.
</summary>
    <author>
      <name>Prabhakar Ragde</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Waterloo, Waterloo, Ontario, Canada</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.170.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.170.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2014, arXiv:1412.4738</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 170, 2014, pp. 78-87</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1412.4882v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1412.4882v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1502.00138v1</id>
    <updated>2015-01-31T16:43:46Z</updated>
    <published>2015-01-31T16:43:46Z</published>
    <title>Compositional Invariant Generation via Linear Recurrence Analysis</title>
    <summary>  This paper presents a new method for automatically generating numerical
invariants for imperative programs. Given a program, our procedure computes a
binary input/output relation on program states which over-approximates the
behaviour of the program. It is compositional in the sense that it operates by
decomposing the program into parts, computing an abstract meaning of each part,
and then composing the meanings. Our method for approximating loop behaviour is
based on first approximating the meaning of the loop body, extracting
recurrence relations from that approximation, and then using the closed forms
to approximate the loop. Our experiments demonstrate that on verification
tasks, our method is competitive with leading invariant generation and
verification tools.
</summary>
    <author>
      <name>Azadeh Farzan</name>
    </author>
    <author>
      <name>Zachary Kincaid</name>
    </author>
    <link href="http://arxiv.org/abs/1502.00138v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1502.00138v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.00017v1</id>
    <updated>2015-04-30T20:16:47Z</updated>
    <published>2015-04-30T20:16:47Z</published>
    <title>Comparative Analysis of Classic Garbage-Collection Algorithms for a
  Lisp-like Language</title>
    <summary>  In this paper, we demonstrate the effectiveness of Cheney's Copy Algorithm
for a Lisp-like system and experimentally show the infeasability of developing
an optimal garbage collector for general use. We summarize and compare several
garbage-collection algorithms including Cheney's Algorithm, the canonical Mark
and Sweep Algorithm, and Knuth's Classical Lisp 2 Algorithm. We implement and
analyze these three algorithms in the context of a custom MicroLisp
environment. We conclude and present the core considerations behind the
development of a garbage collector---specifically for Lisp---and make an
attempt to investigate these issues in depth. We also discuss experimental
results that imply the effectiveness of Cheney's algorithm over Mark-Sweep for
Lisp-like languages.
</summary>
    <author>
      <name>Tyler Hannan</name>
    </author>
    <author>
      <name>Chester Holtz</name>
    </author>
    <author>
      <name>Jonathan Liao</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, 6 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1505.00017v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.00017v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.06003v1</id>
    <updated>2015-05-22T09:29:05Z</updated>
    <published>2015-05-22T09:29:05Z</published>
    <title>Opportunities for a Truffle-based Golo Interpreter</title>
    <summary>  Golo is a simple dynamically-typed language for the Java Virtual Machine.
Initially implemented as a ahead-of-time compiler to JVM bytecode, it leverages
invokedy-namic and JSR 292 method handles to implement a reasonably efficient
runtime. Truffle is emerging as a framework for building interpreters for JVM
languages with self-specializing AST nodes. Combined with the Graal compiler,
Truffle offers a simple path towards writing efficient interpreters while
keeping the engineering efforts balanced. The Golo project is interested in
experimenting with a Truffle interpreter in the future, as it would provides
interesting comparison elements between invokedynamic versus Truffle for
building a language runtime.
</summary>
    <author>
      <name>Julien Ponge</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Frédéric Le Mouël</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Nicolas Stouls</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CITI</arxiv:affiliation>
    </author>
    <author>
      <name>Yannick Loiseau</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LIMOS</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/1505.06003v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.06003v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.06299v1</id>
    <updated>2015-05-23T10:03:49Z</updated>
    <published>2015-05-23T10:03:49Z</published>
    <title>Tracking Causal Dependencies in Web Services Orchestrations Defined in
  ORC</title>
    <summary>  This article shows how the operational semantics of a language like ORC can
be instrumented so that the execution of a program produces information on the
causal dependencies between events. The concurrent semantics we obtain is based
on asymmetric labeled event structures. The approach is illustrated using a Web
service orchestration instance and the detection of race conditions.
</summary>
    <author>
      <name>Matthieu Perrin</name>
    </author>
    <author>
      <name>Claude Jard</name>
    </author>
    <author>
      <name>Achour Mostefaoui</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">NETYS - 3rd International Conference on NETwork sYStems, May 2015,
  Agadir, Morocco. 2015, Proceedings of the third international conference on
  network systems</arxiv:comment>
    <link href="http://arxiv.org/abs/1505.06299v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.06299v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1505.07375v1</id>
    <updated>2015-05-26T04:16:50Z</updated>
    <published>2015-05-26T04:16:50Z</published>
    <title>The Mysteries of Lisp -- I: The Way to S-expression Lisp</title>
    <summary>  Despite its old age, Lisp remains mysterious to many of its admirers. The
mysteries on one hand fascinate the language, on the other hand also obscure
it. Following Stoyan but paying attention to what he has neglected or omitted,
in this first essay of a series intended to unravel these mysteries, we trace
the development of Lisp back to its origin, revealing how the language has
evolved into its nowadays look and feel. The insights thus gained will not only
enhance existent understanding of the language but also inspires further
improvement of it.
</summary>
    <author>
      <name>Hong-Yi Dai</name>
    </author>
    <link href="http://arxiv.org/abs/1505.07375v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1505.07375v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04161v1</id>
    <updated>2015-06-12T20:12:57Z</updated>
    <published>2015-06-12T20:12:57Z</published>
    <title>A simple abstraction of arrays and maps by program translation</title>
    <summary>  We present an approach for the static analysis of programs handling arrays,
with a Galois connection between the semantics of the array program and
semantics of purely scalar operations. The simplest way to implement it is by
automatic, syntactic transformation of the array program into a scalar program
followed analysis of the scalar program with any static analysis technique
(abstract interpretation, acceleration, predicate abstraction,.. .). The
scalars invariants thus obtained are translated back onto the original program
as universally quantified array invariants. We illustrate our approach on a
variety of examples, leading to the " Dutch flag " algorithm.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Francesco Alberti</name>
    </author>
    <link href="http://arxiv.org/abs/1506.04161v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04161v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04498v1</id>
    <updated>2015-06-15T07:48:14Z</updated>
    <published>2015-06-15T07:48:14Z</published>
    <title>Egison: Non-Linear Pattern-Matching against Non-Free Data Types</title>
    <summary>  This paper introduces the Egison programming language whose feature is strong
pattern-matching facility against not only algebraic data types but also
non-free data types whose data have multiple ways of representation such as
sets and graphs. Our language supports multiple occurrences of the same
variables in a pattern, multiple results of pattern-matching, polymorphism of
pattern-constructors and loop-patterns, patterns that contain "and-so-forth"
whose repeat count can be changed by the parameter. This paper proposes the way
to design expressions that have all these features and demonstrates how these
features are useful to express programs concise. Egison has already implemented
in Haskell.
</summary>
    <author>
      <name>Satoshi Egi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages. arXiv admin note: text overlap with arXiv:1407.0729</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.04498v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04498v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.04857v1</id>
    <updated>2015-06-16T07:09:05Z</updated>
    <published>2015-06-16T07:09:05Z</published>
    <title>Mutually Exclusive Modules in Logic Programming</title>
    <summary>  Logic programming has traditionally lacked devices for expressing mutually
exclusive modules. We address this limitation by adopting choice-conjunctive
modules of the form $D_0 \&amp; D_1$ where $D_0, D_1$ are a conjunction of Horn
clauses and $\&amp;$ is a linear logic connective. Solving a goal $G$ using $D_0 \&amp;
D_1$ -- $exec(D_0 \&amp; D_1,G)$ -- has the following operational semantics:
$choose$ a successful one between $exec(D_0,G)$ and $exec(D_1,G)$. In other
words, if $D_0$ is chosen in the course of solving $G$, then $D_1$ will be
discarded and vice versa. Hence, the class of choice-conjunctive modules can
capture the notion of mutually exclusive modules.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.04857v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.04857v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.05270v1</id>
    <updated>2015-06-17T10:28:41Z</updated>
    <published>2015-06-17T10:28:41Z</published>
    <title>jUCM: Universal Class Morphing (position paper)</title>
    <summary>  We extend prior work on class-morphing to provide a more expressive
pattern-based compile-time reflection language. Our MorphJ language offers a
disciplined form of metaprogramming that produces types by statically iterating
over and pattern-matching on fields and methods of other types. We expand such
capabilities with "universal morphing", which also allows pattern-matching over
types (e.g., all classes nested in another, all supertypes of a class) while
maintaining modular type safety for our meta-programs. We present informal
examples of the functionality and discuss a design for adding universal
morphing to Java.
</summary>
    <author>
      <name>Aggelos Biboudis</name>
    </author>
    <author>
      <name>George Fourtounis</name>
    </author>
    <author>
      <name>Yannis Smaragdakis</name>
    </author>
    <link href="http://arxiv.org/abs/1506.05270v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.05270v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1506.07813v1</id>
    <updated>2015-06-25T16:59:52Z</updated>
    <published>2015-06-25T16:59:52Z</published>
    <title>ADsafety: Type-Based Verification of JavaScript Sandboxing</title>
    <summary>  Web sites routinely incorporate JavaScript programs from several sources into
a single page. These sources must be protected from one another, which requires
robust sandboxing. The many entry-points of sandboxes and the subtleties of
JavaScript demand robust verification of the actual sandbox source. We use a
novel type system for JavaScript to encode and verify sandboxing properties.
The resulting verifier is lightweight and efficient, and operates on actual
source. We demonstrate the effectiveness of our technique by applying it to
ADsafe, which revealed several bugs and other weaknesses.
</summary>
    <author>
      <name>Joe Gibbs Politz</name>
    </author>
    <author>
      <name>Spiridon Eliopoulos</name>
    </author>
    <author>
      <name>Arjun Guha</name>
    </author>
    <author>
      <name>Shriram Krishnamurthi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Proceedings of the USENIX Security Symposium (2011)</arxiv:comment>
    <link href="http://arxiv.org/abs/1506.07813v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1506.07813v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.01895v1</id>
    <updated>2015-12-07T03:16:36Z</updated>
    <published>2015-12-07T03:16:36Z</published>
    <title>Modular implicits</title>
    <summary>  We present modular implicits, an extension to the OCaml language for ad-hoc
polymorphism inspired by Scala implicits and modular type classes. Modular
implicits are based on type-directed implicit module parameters, and elaborate
straightforwardly into OCaml's first-class functors. Basing the design on
OCaml's modules leads to a system that naturally supports many features from
other languages with systematic ad-hoc overloading, including inheritance,
instance constraints, constructor classes and associated types.
</summary>
    <author>
      <name>Leo White</name>
    </author>
    <author>
      <name>Frédéric Bour</name>
    </author>
    <author>
      <name>Jeremy Yallop</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.198.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.198.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML/OCaml 2014, arXiv:1512.01438</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 198, 2015, pp. 22-63</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1512.01895v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.01895v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1512.07681v1</id>
    <updated>2015-12-24T01:39:47Z</updated>
    <published>2015-12-24T01:39:47Z</published>
    <title>A Context-Oriented Extension of F#</title>
    <summary>  Context-Oriented programming languages provide us with primitive constructs
to adapt program behaviour depending on the evolution of their operational
environment, namely the context. In previous work we proposed ML_CoDa, a
context-oriented language with two-components: a declarative constituent for
programming the context and a functional one for computing. This paper
describes the implementation of ML_CoDa as an extension of F#.
</summary>
    <author>
      <name>Andrea Canciani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Pierpaolo Degano</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Gian-Luigi Ferrari</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Letterio Galletta</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica, Università di Pisa, Pisa, Italy</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.201.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.201.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FOCLASA 2015, arXiv:1512.06947</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 201, 2015, pp. 18-32</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1512.07681v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1512.07681v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; D.1.6; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.01184v1</id>
    <updated>2016-04-05T09:03:53Z</updated>
    <published>2016-04-05T09:03:53Z</published>
    <title>Eilenberg--Moore Monoids and Backtracking Monad Transformers</title>
    <summary>  We develop an algebraic underpinning of backtracking monad transformers in
the general setting of monoidal categories. As our main technical device, we
introduce Eilenberg--Moore monoids, which combine monoids with algebras for
strong monads. We show that Eilenberg--Moore monoids coincide with algebras for
the list monad transformer ('done right') known from Haskell libraries.
  From this, we obtain a number of results, including the facts that the list
monad transformer is indeed a monad, a transformer, and an instance of the
MonadPlus class. Finally, we construct an Eilenberg--Moore monoid of
endomorphisms, which, via the codensity monad construction, yields a
continuation-based implementation a la Hinze.
</summary>
    <author>
      <name>Maciej Piróg</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, KU Leuven, Belgium</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.207.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.207.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2016, arXiv:1604.00384</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 207, 2016, pp. 23-56</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1604.01184v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.01184v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.01185v1</id>
    <updated>2016-04-05T09:04:03Z</updated>
    <published>2016-04-05T09:04:03Z</published>
    <title>SMT Solving for Functional Programming over Infinite Structures</title>
    <summary>  We develop a simple functional programming language aimed at manipulating
infinite, but first-order definable structures, such as the countably infinite
clique graph or the set of all intervals with rational endpoints. Internally,
such sets are represented by logical formulas that define them, and an external
satisfiability modulo theories (SMT) solver is regularly run by the interpreter
to check their basic properties.
  The language is implemented as a Haskell module.
</summary>
    <author>
      <name>Bartek Klin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Warsaw</arxiv:affiliation>
    </author>
    <author>
      <name>Michał Szynwelski</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Warsaw</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.207.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.207.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2016, arXiv:1604.00384</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 207, 2016, pp. 57-75</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1604.01185v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.01185v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1604.06245v4</id>
    <updated>2016-09-22T10:15:47Z</updated>
    <published>2016-04-21T10:24:17Z</published>
    <title>A Revision of the Mool Language</title>
    <summary>  We present here in a thorough analysis of the Mool language, covering not
only its implementation but also the formalisation (syntax, operational
semantics, and type system). The objective is to detect glitches in both the
implementation and in the formal definitions, proposing as well new features
and added expressiveness. To test our proposals we implemented the revision
developed in the Racket platform.
</summary>
    <author>
      <name>Cláudio Vasconcelos</name>
    </author>
    <author>
      <name>António Ravara</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">34 pages, 15 figures, 11 listings</arxiv:comment>
    <link href="http://arxiv.org/abs/1604.06245v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1604.06245v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.02022v1</id>
    <updated>2016-06-07T04:09:44Z</updated>
    <published>2016-06-07T04:09:44Z</published>
    <title>Programming Language Features for Refinement</title>
    <summary>  Algorithmic and data refinement are well studied topics that provide a
mathematically rigorous approach to gradually introducing details in the
implementation of software. Program refinements are performed in the context of
some programming language, but mainstream languages lack features for recording
the sequence of refinement steps in the program text. To experiment with the
combination of refinement, automated verification, and language design,
refinement features have been added to the verification-aware programming
language Dafny. This paper describes those features and reflects on some
initial usage thereof.
</summary>
    <author>
      <name>Jason Koenig</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Stanford University</arxiv:affiliation>
    </author>
    <author>
      <name>K. Rustan M. Leino</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Microsoft Research</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.209.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.209.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Refine'15, arXiv:1606.01344</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 209, 2016, pp. 87-106</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.02022v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.02022v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.05939v1</id>
    <updated>2016-06-20T01:09:07Z</updated>
    <published>2016-06-20T01:09:07Z</published>
    <title>Event-driven Adaptation in COP</title>
    <summary>  Context-Oriented Programming languages provide us with primitive constructs
to adapt program behaviour depending on the evolution of their operational
environment, namely the context. In previous work we proposed ML_CoDa, a
context-oriented language with two-components: a declarative constituent for
programming the context and a functional one for computing. This paper
describes an extension of ML_CoDa to deal with adaptation to unpredictable
context changes notified by asynchronous events.
</summary>
    <author>
      <name>Pierpaolo Degano</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica - Università di Pisa</arxiv:affiliation>
    </author>
    <author>
      <name>Gian-Luigi Ferrari</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica - Università di Pisa</arxiv:affiliation>
    </author>
    <author>
      <name>Letterio Galletta</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Dipartimento di Informatica - Università di Pisa</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.211.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.211.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2016, arXiv:1606.05403</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 211, 2016, pp. 37-45</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.05939v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.05939v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.05940v1</id>
    <updated>2016-06-20T01:09:16Z</updated>
    <published>2016-06-20T01:09:16Z</published>
    <title>From Events to Reactions: A Progress Report</title>
    <summary>  Syndicate is a new coordinated, concurrent programming language. It occupies
a novel point on the spectrum between the shared-everything paradigm of threads
and the shared-nothing approach of actors. Syndicate actors exchange messages
and share common knowledge via a carefully controlled database that clearly
scopes conversations. This approach clearly simplifies coordination of
concurrent activities. Experience in programming with Syndicate, however,
suggests a need to raise the level of linguistic abstraction. In addition to
writing event handlers and managing event subscriptions directly, the language
will have to support a reactive style of programming. This paper presents
event-oriented Syndicate programming and then describes a preliminary design
for augmenting it with new reactive programming constructs.
</summary>
    <author>
      <name>Tony Garnock-Jones</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Northeastern University, Boston, USA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.211.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.211.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2016, arXiv:1606.05403</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 211, 2016, pp. 46-55</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.05940v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.05940v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.06378v1</id>
    <updated>2016-06-21T00:45:41Z</updated>
    <published>2016-06-21T00:45:41Z</published>
    <title>First Class Call Stacks: Exploring Head Reduction</title>
    <summary>  Weak-head normalization is inconsistent with functional extensionality in the
call-by-name $\lambda$-calculus. We explore this problem from a new angle via
the conflict between extensionality and effects. Leveraging ideas from work on
the $\lambda$-calculus with control, we derive and justify alternative
operational semantics and a sequence of abstract machines for performing head
reduction. Head reduction avoids the problems with weak-head reduction and
extensionality, while our operational semantics and associated abstract
machines show us how to retain weak-head reduction's ease of implementation.
</summary>
    <author>
      <name>Philip Johnson-Freyd</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oregon</arxiv:affiliation>
    </author>
    <author>
      <name>Paul Downen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oregon</arxiv:affiliation>
    </author>
    <author>
      <name>Zena M. Ariola</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oregon</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.212.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.212.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings WoC 2015, arXiv:1606.05839</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 212, 2016, pp. 18-35</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1606.06378v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.06378v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.07687v1</id>
    <updated>2016-06-24T13:57:35Z</updated>
    <published>2016-06-24T13:57:35Z</published>
    <title>Enforcing Termination of Interprocedural Analysis</title>
    <summary>  Interprocedural analysis by means of partial tabulation of summary functions
may not terminate when the same procedure is analyzed for infinitely many
abstract calling contexts or when the abstract domain has infinite strictly
ascending chains. As a remedy, we present a novel local solver for general
abstract equation systems, be they monotonic or not, and prove that this solver
fails to terminate only when infinitely many variables are encountered. We
clarify in which sense the computed results are sound. Moreover, we show that
interprocedural analysis performed by this novel local solver, is guaranteed to
terminate for all non-recursive programs --- irrespective of whether the
complete lattice is infinite or has infinite strictly ascending or descending
chains.
</summary>
    <author>
      <name>Stefan Schulze Frielinghaus</name>
    </author>
    <author>
      <name>Helmut Seidl</name>
    </author>
    <author>
      <name>Ralf Vogler</name>
    </author>
    <link href="http://arxiv.org/abs/1606.07687v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.07687v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1606.08708v1</id>
    <updated>2016-06-25T14:15:34Z</updated>
    <published>2016-06-25T14:15:34Z</published>
    <title>Domain Specific Language for Modular Knitting Pattern Definitions: Purl</title>
    <summary>  Purl is a language to be used for modular definition and verification of
knitting patterns. The syntax is similar to the standard knitting pattern
notation provided by the Craft Yarn Council. Purl provides constructs not
available in the standard notation to allow reuse of segments of patterns. This
report describes the basics of knitting and hand-knitting patterns. A knitting
pattern language more terse than the standard notation is presented with the
implementation of a compiler to this standard.
</summary>
    <author>
      <name>Chelsea Battell</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">124 pages, undergraduate project</arxiv:comment>
    <link href="http://arxiv.org/abs/1606.08708v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1606.08708v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1612.00277v1</id>
    <updated>2016-12-01T14:44:20Z</updated>
    <published>2016-12-01T14:44:20Z</published>
    <title>Sparsity Preserving Algorithms for Octagons</title>
    <summary>  Known algorithms for manipulating octagons do not preserve their sparsity,
leading typically to quadratic or cubic time and space complexities even if no
relation among variables is known when they are all bounded. In this paper, we
present new algorithms, which use and return octagons represented as weakly
closed difference bound matrices, preserve the sparsity of their input and have
better performance in the case their inputs are sparse. We prove that these
algorithms are as precise as the known ones.
</summary>
    <author>
      <name>Jacques-Henri Jourdan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">MPI Software systems, GALLIUM</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Isabella Mastroeni. Numerical and symbolic abstract domains, Sep
  2016, Edinburgh, United Kingdom. Elsevier, Numerical and symbolic abstract
  domains, pp.14, 2016</arxiv:comment>
    <link href="http://arxiv.org/abs/1612.00277v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1612.00277v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.01192v7</id>
    <updated>2017-10-23T18:24:52Z</updated>
    <published>2017-03-03T14:53:18Z</published>
    <title>Tree Notation: an antifragile program notation</title>
    <summary>  This paper presents Tree Notation, a new simple, universal syntax. Language
designers can invent new programming languages, called Tree Languages, on top
of Tree Notation. Tree Languages have a number of advantages over traditional
programming languages.
  We include a Visual Abstract to succinctly display the problem and discovery.
Then we describe the problem--the BNF to abstract syntax tree (AST) parse
step--and introduce the novel solution we discovered: a new family of 2D
programming languages that are written directly as geometric trees.
</summary>
    <author>
      <name>Breck Yunits</name>
    </author>
    <link href="http://arxiv.org/abs/1703.01192v7" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.01192v7" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05186v2</id>
    <updated>2017-03-23T06:57:15Z</updated>
    <published>2017-03-15T14:42:26Z</published>
    <title>Verified type checker for Jolie programming language</title>
    <summary>  Jolie is a service-oriented programming language which comes with the formal
specification of its type system. However, there is no tool to ensure that
programs in Jolie are well-typed. In this paper we provide the results of
building a type checker for Jolie as a part of its syntax and semantics formal
model. We express the type checker as a program with dependent types in Agda
proof assistant which helps to ascertain that the type checker is correct.
</summary>
    <author>
      <name>Evgenii Akentev</name>
    </author>
    <author>
      <name>Alexander Tchitchigin</name>
    </author>
    <author>
      <name>Larisa Safina</name>
    </author>
    <author>
      <name>Manuel Mazzara</name>
    </author>
    <link href="http://arxiv.org/abs/1703.05186v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05186v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.05410v1</id>
    <updated>2017-03-15T22:44:07Z</updated>
    <published>2017-03-15T22:44:07Z</published>
    <title>Languages of Play: Towards semantic foundations for game interfaces</title>
    <summary>  Formal models of games help us account for and predict behavior, leading to
more robust and innovative designs. While the games research community has
proposed many formalisms for both the "game half" (game models, game
description languages) and the "human half" (player modeling) of a game
experience, little attention has been paid to the interface between the two,
particularly where it concerns the player expressing her intent toward the
game. We describe an analytical and computational toolbox based on programming
language theory to examine the phenomenon sitting between control schemes and
game rules, which we identify as a distinct player intent language for each
game.
</summary>
    <author>
      <name>Chris Martens</name>
    </author>
    <author>
      <name>Matthew A. Hammer</name>
    </author>
    <link href="http://arxiv.org/abs/1703.05410v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.05410v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1703.06577v1</id>
    <updated>2017-03-20T02:49:31Z</updated>
    <published>2017-03-20T02:49:31Z</published>
    <title>The Unheralded Value of the Multiway Rendezvous: Illustration with the
  Production Cell Benchmark</title>
    <summary>  The multiway rendezvous introduced in Theoretical CSP is a powerful paradigm
to achieve synchronization and communication among a group of (possibly more
than two) processes. We illustrate the advantages of this paradigm on the
production cell benchmark, a model of a real metal processing plant, for which
we propose a compositional software controller, which is written in LNT and
LOTOS, and makes intensive use of the multiway rendezvous.
</summary>
    <author>
      <name>Hubert Garavel</name>
    </author>
    <author>
      <name>Wendelin Serwe</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.244.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.244.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MARS 2017, arXiv:1703.05812</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 244, 2017, pp. 230-270</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1703.06577v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1703.06577v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1803.02473v1</id>
    <updated>2018-03-06T23:36:04Z</updated>
    <published>2018-03-06T23:36:04Z</published>
    <title>Efficient Mendler-Style Lambda-Encodings in Cedille</title>
    <summary>  It is common to model inductive datatypes as least fixed points of functors.
We show that within the Cedille type theory we can relax functoriality
constraints and generically derive an induction principle for Mendler-style
lambda-encoded inductive datatypes, which arise as least fixed points of
covariant schemes where the morphism lifting is defined only on identities.
Additionally, we implement a destructor for these lambda-encodings that runs in
constant-time. As a result, we can define lambda-encoded natural numbers with
an induction principle and a constant-time predecessor function so that the
normal form of a numeral requires only linear space. The paper also includes
several more advanced examples.
</summary>
    <author>
      <name>Denis Firsov</name>
    </author>
    <author>
      <name>Richard Blair</name>
    </author>
    <author>
      <name>Aaron Stump</name>
    </author>
    <link href="http://arxiv.org/abs/1803.02473v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1803.02473v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1803.02976v1</id>
    <updated>2018-03-08T05:56:53Z</updated>
    <published>2018-03-08T05:56:53Z</published>
    <title>Semantical Equivalence of the Control Flow Graph and the Program
  Dependence Graph</title>
    <summary>  The program dependence graph (PDG) represents data and control dependence
between statements in a program. This paper presents an operational semantics
of program dependence graphs. Since PDGs exclude artificial order of statements
that resides in sequential programs, executions of PDGs are not unique.
However, we identified a class of PDGs that have unique final states of
executions, called deterministic PDGs. We prove that the operational semantics
of control flow graphs is equivalent to that of deterministic PDGs. The class
of deterministic PDGs properly include PDGs obtained from well-structured
programs. Thus, our operational semantics of PDGs is more general than that of
PDGs for well-structured programs, which are already established in literature.
</summary>
    <author>
      <name>Sohei Ito</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">30 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1803.02976v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1803.02976v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1803.10383v1</id>
    <updated>2018-03-28T02:04:43Z</updated>
    <published>2018-03-28T02:04:43Z</published>
    <title>Vehicle Platooning Simulations with Functional Reactive Programming</title>
    <summary>  Functional languages have provided major benefits to the verification
community. Although features such as purity, a strong type system, and
computational abstractions can help guide programmers away from costly errors,
these can present challenges when used in a reactive system. Functional
Reactive Programming is a paradigm that allows users the benefits of functional
languages and an easy interface to a reactive environment. We present a tool
for building autonomous vehicle controllers in FRP using Haskell.
</summary>
    <author>
      <name>Bernd Finkbeiner</name>
    </author>
    <author>
      <name>Felix Klein</name>
    </author>
    <author>
      <name>Ruzica Piskac</name>
    </author>
    <author>
      <name>Mark Santolucito</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3055378.3055385</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3055378.3055385" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">SCAV@CPSWeek 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1803.10383v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1803.10383v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1803.11179v1</id>
    <updated>2018-03-29T17:51:18Z</updated>
    <published>2018-03-29T17:51:18Z</published>
    <title>Proof-of-Concept Examples of Performance-Transparent Programming Models</title>
    <summary>  Machine-specific optimizations command the machine to behave in a specific
way. As current programming models largely leave machine details unexposed,
they cannot accommodate direct encoding of such commands. In previous work we
have proposed the design of performance-transparent programming models to
facilitate this use-case; this report contains proof-of-concept examples of
such programming models. We demonstrate how programming model abstractions may
reveal the memory footprint, vector unit utilization and data reuse of an
application, with prediction accuracy ranging from 0 to 25 \%.
</summary>
    <author>
      <name>Benjamin Andreassen Bjørnseth</name>
    </author>
    <author>
      <name>Jan Christian Meyer</name>
    </author>
    <author>
      <name>Lasse Natvig</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Companion report to short-paper "Make Software Harder", to be
  presented at Computing Frontiers 2018</arxiv:comment>
    <link href="http://arxiv.org/abs/1803.11179v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1803.11179v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.00401v1</id>
    <updated>2018-05-01T15:33:39Z</updated>
    <published>2018-05-01T15:33:39Z</published>
    <title>Index-Stratified Types (Extended Version)</title>
    <summary>  We present Tores, a core language for encoding metatheoretic proofs. The
novel features we introduce are well-founded Mendler-style (co)recursion over
indexed data types and a form of recursion over objects in the index language
to build new types. The latter, which we call index-stratified types, are
analogue to the concept of large elimination in dependently typed languages.
These features combined allow us to encode sophisticated case studies such as
normalization for lambda calculi and normalization by evaluation. We prove the
soundness of Tores as a programming and proof language via the key theorems of
subject reduction and termination.
</summary>
    <author>
      <name>Rohan Jacob-Rao</name>
    </author>
    <author>
      <name>Brigitte Pientka</name>
    </author>
    <author>
      <name>David Thibodeau</name>
    </author>
    <link href="http://arxiv.org/abs/1805.00401v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.00401v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.03374v2</id>
    <updated>2018-06-11T15:02:03Z</updated>
    <published>2018-05-09T05:15:37Z</published>
    <title>A Proposal for Loop-Transformation Pragmas</title>
    <summary>  Pragmas for loop transformations, such as unrolling, are implemented in most
mainstream compilers. They are used by application programmers because of their
ease of use compared to directly modifying the source code of the relevant
loops. We propose additional pragmas for common loop transformations that go
far beyond the transformations today's compilers provide and should make most
source rewriting for the sake of loop optimization unnecessary. To encourage
compilers to implement these pragmas, and to avoid a diversity of incompatible
syntaxes, we would like to spark a discussion about an inclusion to the OpenMP
standard.
</summary>
    <author>
      <name>Michael Kruse</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Argonne National Laboratory</arxiv:affiliation>
    </author>
    <author>
      <name>Hal Finkel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Argonne National Laboratory</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-98521-3_3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-98521-3_3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IWOMP'18 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1805.03374v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.03374v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.03441v1</id>
    <updated>2018-05-09T10:04:28Z</updated>
    <published>2018-05-09T10:04:28Z</published>
    <title>Machine Learning in Compiler Optimisation</title>
    <summary>  In the last decade, machine learning based compilation has moved from an an
obscure research niche to a mainstream activity. In this article, we describe
the relationship between machine learning and compiler optimisation and
introduce the main concepts of features, models, training and deployment. We
then provide a comprehensive survey and provide a road map for the wide variety
of different research areas. We conclude with a discussion on open issues in
the area and potential research directions. This paper provides both an
accessible introduction to the fast moving area of machine learning based
compilation and a detailed bibliography of its main achievements.
</summary>
    <author>
      <name>Zheng Wang</name>
    </author>
    <author>
      <name>Michael O'Boyle</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted to be published at Proceedings of the IEEE</arxiv:comment>
    <link href="http://arxiv.org/abs/1805.03441v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.03441v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1805.11006v4</id>
    <updated>2018-12-31T02:08:57Z</updated>
    <published>2018-05-28T16:06:08Z</published>
    <title>Typed Embedding of a Relational Language in OCaml</title>
    <summary>  We present an implementation of the relational programming language
miniKanren as a set of combinators and syntax extensions for OCaml. The key
feature of our approach is polymorphic unification, which can be used to unify
data structures of arbitrary types. In addition we provide a useful generic
programming pattern to systematically develop relational specifications in a
typed manner, and address the problem of integration of relational subsystems
into functional applications.
</summary>
    <author>
      <name>Dmitrii Kosarev</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Saint Petersburg State University</arxiv:affiliation>
    </author>
    <author>
      <name>Dmitry Boulytchev</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Saint Petersburg State University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.285.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.285.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML/OCAML 2016, arXiv:1812.10891</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 285, 2018, pp. 1-22</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1805.11006v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1805.11006v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1806.01405v1</id>
    <updated>2018-06-04T21:49:33Z</updated>
    <published>2018-06-04T21:49:33Z</published>
    <title>On the Soundness of Coroutines with Snapshots</title>
    <summary>  Coroutines are a general control flow construct that can eliminate control
flow fragmentation inherent in event-driven programs, and are still missing in
many popular languages. Coroutines with snapshots are a first-class, type-safe,
stackful coroutine model, which unifies many variants of suspendable computing,
and is sufficiently general to express iterators, single-assignment variables,
async-await, actors, event streams, backtracking, symmetric coroutines and
continuations. In this paper, we develop a formal model called
$\lambda_{\rightsquigarrow}$ (lambda-squiggly) that captures the essence of
type-safe, stackful, delimited coroutines with snapshots. We prove the standard
progress and preservation safety properties. Finally, we show a formal
transformation from the $\lambda_{\rightsquigarrow}$ calculus to the
simply-typed lambda calculus with references.
</summary>
    <author>
      <name>Aleksandar Prokopec</name>
    </author>
    <author>
      <name>Fengyun Liu</name>
    </author>
    <link href="http://arxiv.org/abs/1806.01405v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1806.01405v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1806.03476v1</id>
    <updated>2018-06-09T13:43:01Z</updated>
    <published>2018-06-09T13:43:01Z</published>
    <title>Type variables in patterns</title>
    <summary>  For many years, GHC has implemented an extension to Haskell that allows type
variables to be bound in type signatures and patterns, and to scope over terms.
This extension was never properly specified. We rectify that oversight here.
With the formal specification in hand, the otherwise-labyrinthine path toward a
design for binding type variables in patterns becomes blindingly clear. We thus
extend ScopedTypeVariables to bind type variables explicitly, obviating the
Proxy workaround to the dustbin of history.
</summary>
    <author>
      <name>Richard A. Eisenberg</name>
    </author>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <author>
      <name>Simon Peyton Jones</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to Haskell'18</arxiv:comment>
    <link href="http://arxiv.org/abs/1806.03476v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1806.03476v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.00605v2</id>
    <updated>2020-07-13T22:05:14Z</updated>
    <published>2020-07-01T16:47:58Z</published>
    <title>Effects for Efficiency: Asymptotic Speedup with First-Class Control</title>
    <summary>  We study the fundamental efficiency of delimited control. Specifically, we
show that effect handlers enable an asymptotic improvement in runtime
complexity for a certain class of functions. We consider the generic count
problem using a pure PCF-like base language $\lambda_b$ and its extension with
effect handlers $\lambda_h$. We show that $\lambda_h$ admits an asymptotically
more efficient implementation of generic count than any $\lambda_b$
implementation. We also show that this efficiency gap remains when $\lambda_b$
is extended with mutable state. To our knowledge this result is the first of
its kind for control operators.
</summary>
    <author>
      <name>Daniel Hillerström</name>
    </author>
    <author>
      <name>Sam Lindley</name>
    </author>
    <author>
      <name>John Longley</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3408982</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3408982" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. ACM Program. Lang., Vol. 4, No. ICFP, Article 100, August
  2020</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2007.00605v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.00605v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.00695v1</id>
    <updated>2020-07-01T18:35:00Z</updated>
    <published>2020-07-01T18:35:00Z</published>
    <title>Experience Report: Smuggling a Little Bit of Coq Inside a CAD
  Development Context (Extended Abstract)</title>
    <summary>  While the use of formal verification techniques is well established in the
development of mission-critical software, it is still rare in the production of
most other kinds of software. We share our experience that a formal
verification tool such as Coq can be very useful and practical in the context
of off-the-shelf software development -- CAD in particular -- at least in some
occasions. The emphasis is on 3 main areas: factors that can enable the use of
Coq in an industrial context; some typical examples of tasks, where Coq can
offer an advantage; examples of issues to overcome - and some non-issues - when
integrating Coq in a standard development process.
</summary>
    <author>
      <name>Dimitur Nikolaev Krustev</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to Coq Workshop 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.00695v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.00695v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.03075v1</id>
    <updated>2020-07-06T21:26:15Z</updated>
    <published>2020-07-06T21:26:15Z</published>
    <title>A Term-Rewriting Semantics for Imperative Style Programming</title>
    <summary>  Term rewriting systems have a simple syntax and semantics and facilitate
proofs of correctness. However, they are not as popular in industry or academia
as imperative languages. We define a term rewriting based abstract programming
language with an imperative style and a precise semantics allowing programs to
be translatable into efficient imperative languages, to obtain proofs of
correctness together with efficient execution. This language is designed to
facilitate translations into correct programs in imperative languages with
assignment statements, iteration, recursion, arrays, pointers, and side
effects. It can also be used in place of a pseudo-programming language to
specify algorithms.
</summary>
    <author>
      <name>David Plaisted</name>
    </author>
    <author>
      <name>Lee Barnett</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This paper was submitted to FSCD 2020 on December 24, 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.03075v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.03075v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.05283v2</id>
    <updated>2021-01-22T10:02:59Z</updated>
    <published>2020-07-10T10:05:46Z</published>
    <title>Reverse AD at Higher Types: Pure, Principled and Denotationally Correct</title>
    <summary>  We show how to define forward- and reverse-mode automatic differentiation
source-code transformations or on a standard higher-order functional language.
The transformations generate purely functional code, and they are principled in
the sense that their definition arises from a categorical universal property.
We give a semantic proof of correctness of the transformations. In their most
elegant formulation, the transformations generate code with linear types.
However, we demonstrate how the transformations can be implemented in a
standard functional language without sacrificing correctness. To do so, we make
use of abstract data types to represent the required linear types, e.g. through
the use of a basic module system.
</summary>
    <author>
      <name>Matthijs Vákár</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. ESOP 2021</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2007.05283v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.05283v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.06760v2</id>
    <updated>2020-07-17T02:21:41Z</updated>
    <published>2020-07-14T01:39:36Z</published>
    <title>Synthesis in Uclid5</title>
    <summary>  We describe an integration of program synthesis into Uclid5, a formal
modelling and verification tool. To the best of our knowledge, the new version
of Uclid5 is the only tool that supports program synthesis with bounded model
checking, k-induction, sequential program verification, and hyperproperty
verification. We use the integration to generate 25 program synthesis
benchmarks with simple, known solutions that are out of reach of current
synthesis engines, and we release the benchmarks to the community.
</summary>
    <author>
      <name>Federico Mora</name>
    </author>
    <author>
      <name>Kevin Cheang</name>
    </author>
    <author>
      <name>Elizabeth Polgreen</name>
    </author>
    <author>
      <name>Sanjit A. Seshia</name>
    </author>
    <link href="http://arxiv.org/abs/2007.06760v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.06760v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.08638v3</id>
    <updated>2020-12-20T20:11:24Z</updated>
    <published>2020-07-16T21:06:07Z</published>
    <title>Probabilistic Programming Semantics for Name Generation</title>
    <summary>  We make a formal analogy between random sampling and fresh name generation.
We show that quasi-Borel spaces, a model for probabilistic programming, can
soundly interpret Stark's $\nu$-calculus, a calculus for name generation.
Moreover, we prove that this semantics is fully abstract up to first-order
types. This is surprising for an 'off-the-shelf' model, and requires a novel
analysis of probability distributions on function spaces. Our tools are diverse
and include descriptive set theory and normal forms for the $\nu$-calculus.
</summary>
    <author>
      <name>Marcin Sabok</name>
    </author>
    <author>
      <name>Sam Staton</name>
    </author>
    <author>
      <name>Dario Stein</name>
    </author>
    <author>
      <name>Michael Wolman</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">29 pages, 1 figure; to be published in POPL 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.08638v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.08638v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.09909v2</id>
    <updated>2020-07-22T08:23:10Z</updated>
    <published>2020-07-20T06:52:54Z</published>
    <title>Coinduction Plain and Simple</title>
    <summary>  Coinduction refers to both a technique for the definition of infinite
streams, so-called codata, and a technique for proving the equality of
coinductively specified codata. This article first reviews coinduction in
declarative programming. Second, it reviews and slightly extends the formalism
commonly used for specifying codata. Third, it generalizes the coinduction
proof principle, which has been originally specified for the equality predicate
only, to other predicates. This generalization makes the coinduction proof
principle more intuitive and stresses its closeness with structural induction.
The article finally suggests in its conclusion extensions of functional and
logic programming with limited and decidable forms of the generalized
coinduction proof principle.
</summary>
    <author>
      <name>François Bry</name>
    </author>
    <link href="http://arxiv.org/abs/2007.09909v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.09909v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.10809v1</id>
    <updated>2020-07-17T23:48:23Z</updated>
    <published>2020-07-17T23:48:23Z</published>
    <title>Software Transactional Memory with Interactions</title>
    <summary>  Software Transactional memory (STM) is an emerging abstraction for concurrent
programming alternative to lock-based synchronizations. Most STM models admit
only isolated transactions, which are not adequate in multithreaded programming
where transactions need to interact via shared data before committing. To
overcome this limitation, in this paper we present Open Transactional Memory
(OTM), a programming abstraction supporting safe, data-driven interactions
between composable memory transactions. This is achieved by relaxing isolation
between transactions, still ensuring atomicity. This model allows for
loosely-coupled interactions since transaction merging is driven only by
accesses to shared data, with no need to specify participants beforehand.
</summary>
    <author>
      <name>Marino Miculan</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1602.05365</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.10809v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.10809v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.12247v3</id>
    <updated>2021-06-19T10:41:02Z</updated>
    <published>2020-07-23T20:39:29Z</published>
    <title>On Solving Word Equations via Program Transformation</title>
    <summary>  The paper presents an experiment of solving word equations via specialization
of a configuration WE(R,E), where the program WE can be considered as an
interpreter testing whether a composition of substitutions R produces a
solution of a word equation E. Several variants of such interpreters, when
specialized using a basic unfold/fold strategy, are able to decide solvability
for a number of sets of the word equations with the overlapping variables.
</summary>
    <author>
      <name>Antonina Nepeivoda</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Another version of this work will be uploaded on arXiv by eptcs</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.12247v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.12247v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.12477v1</id>
    <updated>2020-05-18T08:12:39Z</updated>
    <published>2020-05-18T08:12:39Z</published>
    <title>An Object Oriented Approach For the Protection of Information Systems</title>
    <summary>  We provide a protection system making use of encapsulation, messages
communication, interface functions coming from an object oriented model
described in previous works. Each user represents himself to the system by the
mean of his "USER" object type. The recognition procedure is suitable to every
one's needs. Any user's objects and types are labeled with a personal
signature, exclusively provided and known by the system. Administrator's rights
are restricted to backup procedures. The system verify each messages access, it
is robust because partitioned, flexible, suitable and psychologically
acceptable.
</summary>
    <author>
      <name>Joël Colloc</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IDEES</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in French. INFORSID 1991 Paris Pantheon Sorbonne, 1991, Paris, France</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.12477v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.12477v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.15617v1</id>
    <updated>2020-07-30T17:31:31Z</updated>
    <published>2020-07-30T17:31:31Z</published>
    <title>A Core Calculus for Static Latency Tracking with Placement Types</title>
    <summary>  Developing efficient geo-distributed applications is challenging as
programmers can easily introduce computations that entail high latency
communication. We propose a language design which makes latency explicit and
extracts type-level bounds for a computation's runtime latency. We present our
initial steps with a core calculus that enables extracting provably correct
latency bounds and outline future work.
</summary>
    <author>
      <name>Tobias Reinhard</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 0 figures, accepted at Student Research Competition @ POPL
  2019</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.15617v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.15617v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.1; C.4; B.4.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2007.16171v2</id>
    <updated>2022-06-20T07:31:37Z</updated>
    <published>2020-07-31T16:47:05Z</published>
    <title>Reversible Debugging in Logic Programming</title>
    <summary>  Reversible debugging is becoming increasingly popular for locating the source
of errors. This technique proposes a more natural approach to debugging, where
one can explore a computation from the observable misbehaviour backwards to the
source of the error. In this work, we propose a reversible debugging scheme for
logic programs. For this purpose, we define an appropriate instrumented
semantics (a so-called Landauer embedding) that makes SLD resolution
reversible. An implementation of a reversible debugger for Prolog, rever, has
been developed and is publicly available.
</summary>
    <author>
      <name>Germán Vidal</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, to appear in "LNCS Honorary Volume for Manuel Hermenegildo"
  [AVERTIS 2019]</arxiv:comment>
    <link href="http://arxiv.org/abs/2007.16171v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2007.16171v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N17" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2009.01001v2</id>
    <updated>2020-09-04T10:29:28Z</updated>
    <published>2020-09-02T12:33:02Z</published>
    <title>Pre-Proceedings of the 28th International Workshop on Functional and
  Logic Programming (WFLP 2020)</title>
    <summary>  This volume constitutes the pre-proceedings of the 28th International
Workshop on Functional and Logic Programming (WFLP 2020), organized by the
University of Bologna, Italy, as part of Bologna Federated Conference on
Programming Languages 2020. The international Workshop on Functional and
(constraint) Logic Programming (WFLP) aims at bringing together researchers,
students, and practitioners interested in functional programming, logic
programming, and their integration. WFLP has a reputation for being a lively
and friendly forum, and it is open for presenting and discussing work in
progress, technical contributions, experience reports, experiments, reviews,
and system descriptions.
</summary>
    <author>
      <name>Michael Hanus</name>
    </author>
    <author>
      <name>Claudio Sacerdoti Coen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-Proceedings of WFLP 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2009.01001v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2009.01001v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2009.04437v3</id>
    <updated>2020-10-01T16:27:06Z</updated>
    <published>2020-09-09T17:32:38Z</published>
    <title>Ties between Parametrically Polymorphic Type Systems and Finite Control
  Automata</title>
    <summary>  We present a correspondence and bisimulation between variants of
parametrically polymorphic type systems and variants of finite control
automata, such as FSA, PDA, tree automata and Turing machine. Within this
correspondence we show that two recent celebrated results on automatic
generation of fluent API are optimal in certain senses, present new results on
the studied type systems, formulate open problems, and present potential
software engineering applications, other than fluent API generation, which may
benefit from judicious use of type theory.
</summary>
    <author>
      <name>Joseph Gil</name>
    </author>
    <author>
      <name>Ori Roth</name>
    </author>
    <link href="http://arxiv.org/abs/2009.04437v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2009.04437v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2009.06029v3</id>
    <updated>2024-02-22T05:51:59Z</updated>
    <published>2020-09-13T16:03:41Z</published>
    <title>Transition-Oriented Programming: Developing Provably Correct Systems</title>
    <summary>  Correctness is a necessary condition for systems to be effective in meeting
human demands, thus playing a critical role in system development. However,
correctness often manifests as a nebulous concept in practice, leading to
challenges in accurately creating specifications, effectively proving
correctness satisfiability, and efficiently implementing correct systems.
Motivated by tackling these challenges, this paper introduces
Transition-Oriented Programming (TOP), a programming paradigm to facilitate the
development of provably correct systems by intertwining correctness
specification, verification, and implementation within a unified theoretical
framework.
</summary>
    <author>
      <name>Yepeng Ding</name>
    </author>
    <link href="http://arxiv.org/abs/2009.06029v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2009.06029v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2009.10272v2</id>
    <updated>2020-10-18T20:23:13Z</updated>
    <published>2020-09-22T01:57:48Z</published>
    <title>Inductive Program Synthesis Over Noisy Data</title>
    <summary>  We present a new framework and associated synthesis algorithms for program
synthesis over noisy data, i.e., data that may contain incorrect/corrupted
input-output examples. This framework is based on an extension of finite tree
automata called {\em weighted finite tree automata}. We show how to apply this
framework to formulate and solve a variety of program synthesis problems over
noisy data. Results from our implemented system running on problems from the
SyGuS 2018 benchmark suite highlight its ability to successfully synthesize
programs in the face of noisy data sets, including the ability to synthesize a
correct program even when every input-output example in the data set is
corrupted.
</summary>
    <author>
      <name>Shivam Handa</name>
    </author>
    <author>
      <name>Martin Rinard</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3368089.3409732</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3368089.3409732" rel="related"/>
    <link href="http://arxiv.org/abs/2009.10272v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2009.10272v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.03309v1</id>
    <updated>2021-03-04T20:25:54Z</updated>
    <published>2021-03-04T20:25:54Z</published>
    <title>Translating declarative control elements to imperative using 'l-value
  redefinition graphs'</title>
    <summary>  We focus on control constructs that allow programmers define actions to be
performed when respective conditions are met without requiring the explicit
evaluation and testing of conditions as part of an imperative algorithm. Such
elements are commonly referred as declarative, not theoretically related to
declarative languages. We introduce declarative constructs in the C++ language,
presenting the translation method to standard C++. The innovative feature of
our method is the accommodation of l-values involving arbitrary pointer / array
expressions and objects, supporting immediate runtime evaluation upon content
update even if such l-values bind to variant storage locations at runtime. To
accomplish this we define 'l-value redefinition graphs', capturing storage
binding dependencies among variables, being the floor-plan of our code
generation and runtime management approach.
</summary>
    <author>
      <name>Anthony Savidis</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 13 figures, includes code</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.03309v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.03309v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.09518v2</id>
    <updated>2021-07-17T15:22:04Z</updated>
    <published>2021-03-17T09:03:18Z</published>
    <title>Sliceable Monolith: Monolith First, Microservices Later</title>
    <summary>  We propose Sliceable Monolith, a new methodology for developing microservice
architectures and perform their integration testing by leveraging most of the
simplicity of a monolith: a single codebase and a local execution environment
that simulates distribution. Then, a tool compiles a codebase for each
microservice and a cloud deployment configuration. The key enabler of our
approach is the technology-agnostic service definition language offered by
Jolie.
</summary>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <author>
      <name>Valentino Picotti</name>
    </author>
    <link href="http://arxiv.org/abs/2103.09518v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.09518v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.10269v1</id>
    <updated>2021-03-18T14:05:47Z</updated>
    <published>2021-03-18T14:05:47Z</published>
    <title>Zooid: a DSL for Certified Multiparty Computation</title>
    <summary>  We design and implement Zooid, a domain specific language for certified
multiparty communication, embedded in Coq and implemented atop our
mechanisation framework of asynchronous multiparty session types (the first of
its kind). Zooid provides a fully mechanised metatheory for the semantics of
global and local types, and a fully verified end-point process language that
faithfully reflects the type-level behaviours and thus inherits the global
types properties such as deadlock freedom, protocol compliance, and liveness
guarantees.
</summary>
    <author>
      <name>David Castro-Perez</name>
    </author>
    <author>
      <name>Francisco Ferreira</name>
    </author>
    <author>
      <name>Lorenzo Gheri</name>
    </author>
    <author>
      <name>Nobuko Yoshida</name>
    </author>
    <link href="http://arxiv.org/abs/2103.10269v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.10269v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.13390v1</id>
    <updated>2021-03-23T18:00:47Z</updated>
    <published>2021-03-23T18:00:47Z</published>
    <title>Row-Polymorphic Types for Strategic Rewriting</title>
    <summary>  We present a type system for strategy languages that express program
transformations as compositions of rewrite rules. Our row-polymorphic type
system assists compiler engineers to write correct strategies by statically
rejecting non meaningful compositions of rewrites that otherwise would fail
during rewriting at runtime. Furthermore, our type system enables reasoning
about how rewriting transforms the shape of the computational program. We
present a formalization of our language at its type system and demonstrate its
practical use for expressing compiler optimization strategies. Our type system
builds the foundation for many interesting future applications, including
verifying the correctness of program transformations and synthesizing program
transformations from specifications encoded as types.
</summary>
    <author>
      <name>Rongxiao Fu</name>
    </author>
    <author>
      <name>Xueying Qin</name>
    </author>
    <author>
      <name>Ornela Dardha</name>
    </author>
    <author>
      <name>Michel Steuwer</name>
    </author>
    <link href="http://arxiv.org/abs/2103.13390v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.13390v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.13921v1</id>
    <updated>2021-03-25T15:32:16Z</updated>
    <published>2021-03-25T15:32:16Z</published>
    <title>The Resh Programming Language for Multirobot Orchestration</title>
    <summary>  This paper describes Resh, a new, statically typed, interpreted programming
language and associated runtime for orchestrating multirobot systems. The main
features of Resh are: (1) It offloads much of the tedious work of programming
such systems away from the programmer and into the language runtime; (2) It is
based on a small set of temporal and locational operators; and (3) It is not
restricted to specific robot types or tasks. The Resh runtime consists of three
engines that collaborate to run a Resh program using the available robots in
their current environment. This paper describes both Resh and its runtime and
gives examples of its use.
</summary>
    <author>
      <name>Martin Carroll</name>
    </author>
    <author>
      <name>Kedar S. Namjoshi</name>
    </author>
    <author>
      <name>Itai Segall</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted for publication at ICRA'21</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.13921v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.13921v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.14481v1</id>
    <updated>2021-03-26T14:08:01Z</updated>
    <published>2021-03-26T14:08:01Z</published>
    <title>Deadlock-Free Session Types in Linear Haskell</title>
    <summary>  Priority Sesh is a library for session-typed communication in Linear Haskell
which offers strong compile-time correctness guarantees. Priority Sesh offers
two deadlock-free APIs for session-typed communication. The first guarantees
deadlock freedom by restricting the process structure to trees and forests. It
is simple and composeable, but rules out cyclic structures. The second
guarantees deadlock freedom via priorities, which allows the programmer to
safely use cyclic structures as well.
  Our library relies on Linear Haskell to guarantee linearity, which leads to
easy-to-write session types and highly idiomatic code, and lets us avoid the
complex encodings of linearity in the Haskell type system that made previous
libraries difficult to use.
</summary>
    <author>
      <name>Wen Kokke</name>
    </author>
    <author>
      <name>Ornela Dardha</name>
    </author>
    <link href="http://arxiv.org/abs/2103.14481v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.14481v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.14698v1</id>
    <updated>2021-03-02T03:36:58Z</updated>
    <published>2021-03-02T03:36:58Z</published>
    <title>Implementing G-Machine in HyperLMNtal</title>
    <summary>  Since language processing systems generally allocate/discard memory with
complex reference relationships, including circular and indirect references,
their implementation is often not trivial. Here, the allocated memory and the
references can be abstracted to the labeled vertices and edges of a graph. And
there exists a graph rewriting language, a programming language or a
calculation model that can handle graph intuitively, safely and efficiently.
Therefore, the implementation of a language processing system can be highly
expected as an application field of graph rewriting language. To show this, in
this research, we implemented G-machine, the virtual machine for lazy
evaluation, in hypergraph rewriting language, HyperLMNtal.
</summary>
    <author>
      <name>Jin Sano</name>
    </author>
    <link href="http://arxiv.org/abs/2103.14698v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.14698v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.15103v1</id>
    <updated>2021-03-28T10:21:23Z</updated>
    <published>2021-03-28T10:21:23Z</published>
    <title>Phism: Polyhedral High-Level Synthesis in MLIR</title>
    <summary>  Polyhedral optimisation, a methodology that views nested loops as polyhedra
and searches for their optimal transformation regarding specific objectives
(parallelism, locality, etc.), sounds promising for mitigating difficulties in
automatically optimising hardware designs described by high-level synthesis
(HLS), which are typically software programs with nested loops. Nevertheless,
existing polyhedral tools cannot meet the requirements from HLS developers for
platform-specific customisation and software/hardware co-optimisation. This
paper proposes $\phi_{sm}$ (phism), a polyhedral HLS framework built on MLIR,
to address these challenges through progressive lowering multi-level
intermediate representations (IRs) from polyhedra to HLS designs.
</summary>
    <author>
      <name>Ruizhe Zhao</name>
    </author>
    <author>
      <name>Jianyi Cheng</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Will be presented at LATTE'21</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.15103v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.15103v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2103.15408v4</id>
    <updated>2021-07-05T18:51:24Z</updated>
    <published>2021-03-29T08:13:30Z</published>
    <title>A simpler encoding of indexed types</title>
    <summary>  In functional programming languages, generalized algebraic data types (GADTs)
are very useful as the unnecessary pattern matching over them can be ruled out
by the failure of unification of type arguments. In dependent type systems,
this is usually called indexed types and it's particularly useful as the
identity type is a special case of it. However, pattern matching over indexed
types is very complicated as it requires term unification in general. We study
a simplified version of indexed types (called simpler indexed types) where we
explicitly specify the selection process of constructors, and we discuss its
expressiveness, limitations, and properties.
</summary>
    <author>
      <name>Tesla Zhang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, 8 figures, ICFP 2021 TyDe workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2103.15408v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2103.15408v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.01344v1</id>
    <updated>2021-05-04T07:44:16Z</updated>
    <published>2021-05-04T07:44:16Z</published>
    <title>Simple, Light, Yet Formally Verified, Global Common Subexpression
  Elimination and Loop-Invariant Code Motion</title>
    <summary>  We present an approach for implementing a formally certified loop-invariant
code motion optimization by composing an unrolling pass and a formally
certified yet efficient global subexpression elimination.This approach is
lightweight: each pass comes with a simple and independent proof of
correctness.Experiments show the approach significantly narrows the performance
gap between the CompCert certified compiler and state-of-the-art optimizing
compilers.Our static analysis employs an efficient yet verified hashed set
structure, resulting in fast compilation.
</summary>
    <author>
      <name>David Monniaux</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">VERIMAG - IMAG</arxiv:affiliation>
    </author>
    <author>
      <name>Cyril Six</name>
    </author>
    <link href="http://arxiv.org/abs/2105.01344v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.01344v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.02156v1</id>
    <updated>2021-05-05T16:10:06Z</updated>
    <published>2021-05-05T16:10:06Z</published>
    <title>Recursion and Sequentiality in Categories of Sheaves</title>
    <summary>  We present a fully abstract model of a call-by-value language with
higher-order functions, recursion and natural numbers, as an exponential ideal
in a topos. Our model is inspired by the fully abstract models of O'Hearn,
Riecke and Sandholm, and Marz and Streicher. In contrast with semantics based
on cpo's, we treat recursion as just one feature in a model built by combining
a choice of modular components.
</summary>
    <author>
      <name>Cristina Matache</name>
    </author>
    <author>
      <name>Sean Moss</name>
    </author>
    <author>
      <name>Sam Staton</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4230/LIPIcs.FSCD.2021.25</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4230/LIPIcs.FSCD.2021.25" rel="related"/>
    <link href="http://arxiv.org/abs/2105.02156v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.02156v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.02632v2</id>
    <updated>2021-05-07T01:43:31Z</updated>
    <published>2021-05-06T13:06:55Z</published>
    <title>Analytical Differential Calculus with Integration</title>
    <summary>  Differential lambda-calculus was first introduced by Thomas Ehrhard and
Laurent Regnier in 2003. Despite more than 15 years of history, little work has
been done on a differential calculus with integration. In this paper, we shall
propose a differential calculus with integration from programming point of
view. We show its good correspondence with mathematics, which is manifested by
how we construct these reduction rules and how we preserve important
mathematical theorems in our calculus. Moreover, we highlight applications of
the calculus in incremental computation, automatic differentiation, and
computation approximation.
</summary>
    <author>
      <name>Han Xu</name>
    </author>
    <author>
      <name>Zhenjiang Hu</name>
    </author>
    <link href="http://arxiv.org/abs/2105.02632v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.02632v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.04910v1</id>
    <updated>2021-05-11T09:55:30Z</updated>
    <published>2021-05-11T09:55:30Z</published>
    <title>Splitting recursion schemes into reversible and classical interacting
  threads</title>
    <summary>  Given a simple recursive function, we show how to extract from it a
reversible and an classical iterative part. Those parts can synchronously
cooperate under a Producer/Consumer pattern in order to implement the original
recursive function. The reversible producer is meant to run on reversible
hardware. We also discuss how to extend the extraction to a more general
compilation scheme.
</summary>
    <author>
      <name>Armando B. Matos</name>
    </author>
    <author>
      <name>Luca Paolini</name>
    </author>
    <author>
      <name>Luca Roversi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The first 10 pages will appear in the proceedings of 13th Conference
  on Reversible Computation. Appendix is for this authors version. arXiv admin
  note: substantial text overlap with arXiv:2102.09436</arxiv:comment>
    <link href="http://arxiv.org/abs/2105.04910v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.04910v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.09469v1</id>
    <updated>2021-05-20T02:33:56Z</updated>
    <published>2021-05-20T02:33:56Z</published>
    <title>Decomposing reverse-mode automatic differentiation</title>
    <summary>  We decompose reverse-mode automatic differentiation into (forward-mode)
linearization followed by transposition. Doing so isolates the essential
difference between forward- and reverse-mode AD, and simplifies their joint
implementation. In particular, once forward-mode AD rules are defined for every
primitive operation in a source language, only linear primitives require an
additional transposition rule in order to arrive at a complete reverse-mode AD
implementation. This is how reverse-mode AD is written in JAX and Dex.
</summary>
    <author>
      <name>Roy Frostig</name>
    </author>
    <author>
      <name>Matthew J. Johnson</name>
    </author>
    <author>
      <name>Dougal Maclaurin</name>
    </author>
    <author>
      <name>Adam Paszke</name>
    </author>
    <author>
      <name>Alexey Radul</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at the LAFI 2021 workshop at POPL, 17 January 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2105.09469v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.09469v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.11148v1</id>
    <updated>2021-05-24T08:28:09Z</updated>
    <published>2021-05-24T08:28:09Z</published>
    <title>CHESSIoT support of event-based modeling for the Internet of Things
  applications</title>
    <summary>  Internet of Things systems design and development suffers from heterogeneity
in different aspects. The component behaviors also change due to events being
internal or external and the system needs to take action subsequently. In this
paper, we demo the event-based modeling capabilities of the CHESSIoT tool on a
smart parking application. Different components was been decomposed with
functional and behavioral specifications following the component-based
approach. In the end, we have given a brief description of the future work.
</summary>
    <author>
      <name>Felicien Ihirwe</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2105.11148v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.11148v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.13411v1</id>
    <updated>2021-05-27T19:30:32Z</updated>
    <published>2021-05-27T19:30:32Z</published>
    <title>Model Repair Revamped: On the Automated Synthesis of Markov Chains</title>
    <summary>  This paper outlines two approaches|based on counterexample-guided abstraction
refinement (CEGAR) and counterexample-guided inductive synthesis (CEGIS),
respectively to the automated synthesis of finite-state probabilistic models
and programs. Our CEGAR approach iteratively partitions the design space
starting from an abstraction of this space and refines this by a light-weight
analysis of verification results. The CEGIS technique exploits critical
subsystems as counterexamples to prune all programs behaving incorrectly on
that input. We show the applicability of these synthesis techniques to
sketching of probabilistic programs, controller synthesis of POMDPs, and
software product lines.
</summary>
    <author>
      <name>Milan Ceska</name>
    </author>
    <author>
      <name>Christian Dehnert</name>
    </author>
    <author>
      <name>Nils Jansen</name>
    </author>
    <author>
      <name>Sebastian Junges</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-31514-6\_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-31514-6\_7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2105.13411v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.13411v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N30" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2105.13941v1</id>
    <updated>2021-05-28T16:03:45Z</updated>
    <published>2021-05-28T16:03:45Z</published>
    <title>Reflections on Termination of Linear Loops</title>
    <summary>  This paper shows how techniques for linear dynamical systems can be used to
reason about the behavior of general loops. We present two main results. First,
we show that every loop that can be expressed as a transition formula in linear
integer arithmetic has a best model as a deterministic affine transition
system. Second, we show that for any linear dynamical system $f$ with integer
eigenvalues and any integer arithmetic formula $G$, there is a linear integer
arithmetic formula that holds exactly for the states of $f$ for which $G$ is
eventually invariant. Combining the two, we develop a monotone conditional
termination analysis for general loops.
</summary>
    <author>
      <name>Shaowei Zhu</name>
    </author>
    <author>
      <name>Zachary Kincaid</name>
    </author>
    <link href="http://arxiv.org/abs/2105.13941v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2105.13941v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1509.04040v1</id>
    <updated>2015-09-14T11:37:06Z</updated>
    <published>2015-09-14T11:37:06Z</published>
    <title>Programs as proofs</title>
    <summary>  The Curry-Howard correspondence is about a relationship between types and
programs on the one hand and propositions and proofs on the other. The
implications for programming language design and program verification is an
active field of research.
  Transformer-like semantics of internal definitions that combine a defining
computation and an application will be presented. By specialisation for a given
defining computation one can derive inference rules for applications of defined
operations.
  With semantics of that kind for every operation, each application identifies
an axiom in a logic defined by the programming language, so a language can be
considered a theory.
</summary>
    <author>
      <name>Jørgen Steensgaard-Madsen</name>
    </author>
    <link href="http://arxiv.org/abs/1509.04040v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1509.04040v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.01520v3</id>
    <updated>2016-03-11T11:31:59Z</updated>
    <published>2016-03-04T16:13:24Z</published>
    <title>Optimized Polynomial Evaluation with Semantic Annotations</title>
    <summary>  In this paper we discuss how semantic annotations can be used to introduce
mathematical algorithmic information of the underlying imperative code to
enable compilers to produce code transformations that will enable better
performance. By using this approaches not only good performance is achieved,
but also better programmability, maintainability and portability across
different hardware architectures. To exemplify this we will use polynomial
equations of different degrees.
</summary>
    <author>
      <name>Daniel Rubio Bonilla</name>
    </author>
    <author>
      <name>Colin W. Glass</name>
    </author>
    <author>
      <name>Jan Kuper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of the Program Transformation for Programmability in
  Heterogeneous Architectures (PROHA) workshop, Barcelona, Spain, 12th March
  2016, 7 pages, LaTeX, 4 PNG figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.01520v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.01520v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="B.1.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1603.08648v3</id>
    <updated>2017-12-29T17:39:07Z</updated>
    <published>2016-03-29T05:35:34Z</published>
    <title>A Comparison of NOOP to Structural Domain-Theoretic Models of OOP</title>
    <summary>  Mainstream object-oriented programming languages such as Java, C#, C++ and
Scala are all almost entirely nominally-typed. NOOP is a recently developed
domain-theoretic model of OOP that was designed to include full nominal
information found in nominally-typed OOP. This paper compares NOOP to the most
widely known domain-theoretic models of OOP, namely, the models developed by
Cardelli and Cook, which were structurally-typed models. Leveraging the
development of NOOP, the comparison presented in this paper provides a clear
and precise mathematical account for the relation between nominal and
structural OO type systems.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1603.08648v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1603.08648v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; D.1.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.02033v1</id>
    <updated>2016-04-30T09:41:07Z</updated>
    <published>2016-04-30T09:41:07Z</published>
    <title>A Study on Features and Limitations of On-line C Compilers</title>
    <summary>  Compilers are used to run programs that are written in a range of designs
from text to executable formats. With the advent of the internet, studies
related to the development of cloud based compilers are being carried out.
There is a considerable increase of on-line compilers enabling on-line
compilation of user programs without any mandate to. This study is specific to
on-line C compilers to investigate the correctness, issues and limitations.
</summary>
    <author>
      <name>Ramkumar Lakshminarayanan</name>
    </author>
    <author>
      <name>Balaji Dhanasekaran</name>
    </author>
    <author>
      <name>Ben George Ephre</name>
    </author>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">International Journal of Computer Applications 0975 8887 Volume
  125 No.9, September 2015</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1605.02033v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.02033v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.02142v2</id>
    <updated>2016-05-14T01:24:06Z</updated>
    <published>2016-05-07T05:05:40Z</published>
    <title>Nominal LCF: A Language for Generic Proof</title>
    <summary>  The syntax and semantics of user-supplied hypothesis names in tactic
languages is a thorny problem, because the binding structure of a proof is a
function of the goal at which a tactic script is executed. We contribute a new
language to deal with the dynamic and interactive character of names in tactic
scripts called Nominal LCF, and endow it with a denotational semantics in
dI-domains. A large fragment of Nominal LCF has already been implemented and
used to great effect in the new RedPRL proof assistant.
</summary>
    <author>
      <name>Jonathan Sterling</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted to TFP 2016, the paper has been withdrawn by the author
  because he has found a serious flaw in the denotational semantics given in
  section 5</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.02142v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.02142v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.02935v1</id>
    <updated>2016-05-10T10:47:02Z</updated>
    <published>2016-05-10T10:47:02Z</published>
    <title>Flag-Based Big-Step Semantics</title>
    <summary>  Structural operational semantic specifications come in different styles:
small-step and big-step. A problem with the big-step style is that specifying
divergence and abrupt termination gives rise to annoying duplication. We
present a novel approach to representing divergence and abrupt termination in
big-step semantics using status flags. This avoids the duplication problem, and
uses fewer rules and premises for representing divergence than previous
approaches in the literature.
</summary>
    <author>
      <name>Casper Bach Poulsen</name>
    </author>
    <author>
      <name>Peter D. Mosses</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in The Journal of Logical and Algebraic Methods in
  Programming, Special Issue: 26th Nordic Workshop for Programming Theory, 2014</arxiv:comment>
    <link href="http://arxiv.org/abs/1605.02935v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.02935v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.03636v1</id>
    <updated>2016-05-11T23:01:53Z</updated>
    <published>2016-05-11T23:01:53Z</published>
    <title>Tighter Loop Bound Analysis (Technical report)</title>
    <summary>  We present a new algorithm for computing upper bounds on the number of
executions of each program instruction during any single program run. The upper
bounds are expressed as functions of program input values. The algorithm is
primarily designed to produce bounds that are relatively tight, i.e. not
unnecessarily blown up. The upper bounds for instructions allow us to infer
loop bounds, i.e.~upper bounds on the number of loop iterations. Experimental
results show that the algorithm implemented in a prototype tool Looperman often
produces tighter bounds than current tools for loop bound analysis.
</summary>
    <author>
      <name>Pavel Čadek</name>
    </author>
    <author>
      <name>Jan Strejček</name>
    </author>
    <author>
      <name>Marek Trtík</name>
    </author>
    <link href="http://arxiv.org/abs/1605.03636v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.03636v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.04477v2</id>
    <updated>2016-07-26T20:13:54Z</updated>
    <published>2016-05-14T22:34:59Z</published>
    <title>Bounded Model Checking for Probabilistic Programs</title>
    <summary>  In this paper we investigate the applicability of standard model checking
approaches to verifying properties in probabilistic programming. As the
operational model for a standard probabilistic program is a potentially
infinite parametric Markov decision process, no direct adaption of existing
techniques is possible. Therefore, we propose an on-the-fly approach where the
operational model is successively created and verified via a step-wise
execution of the program. This approach enables to take key features of many
probabilistic programs into account: nondeterminism and conditioning. We
discuss the restrictions and demonstrate the scalability on several benchmarks.
</summary>
    <author>
      <name>Nils Jansen</name>
    </author>
    <author>
      <name>Christian Dehnert</name>
    </author>
    <author>
      <name>Benjamin Lucien Kaminski</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <author>
      <name>Lukas Westhofen</name>
    </author>
    <link href="http://arxiv.org/abs/1605.04477v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.04477v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1605.06938v1</id>
    <updated>2016-05-23T08:51:36Z</updated>
    <published>2016-05-23T08:51:36Z</published>
    <title>No value restriction is needed for algebraic effects and handlers</title>
    <summary>  We present a straightforward, sound Hindley-Milner polymorphic type system
for algebraic effects and handlers in a call-by-value calculus, which allows
type variable generalisation of arbitrary computations, not just values. This
result is surprising. On the one hand, the soundness of unrestricted
call-by-value Hindley-Milner polymorphism is known to fail in the presence of
computational effects such as reference cells and continuations. On the other
hand, many programming examples can be recast to use effect handlers instead of
these effects. Analysing the expressive power of effect handlers with respect
to state effects, we claim handlers cannot express reference cells, and show
they can simulate dynamically scoped state.
</summary>
    <author>
      <name>Ohad Kammar</name>
    </author>
    <author>
      <name>Matija Pretnar</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0956796816000320.</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0956796816000320." rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Functional Programming, 27, 2017</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1605.06938v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1605.06938v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.01590v1</id>
    <updated>2016-07-06T12:27:45Z</updated>
    <published>2016-07-06T12:27:45Z</published>
    <title>Indexing dif/2</title>
    <summary>  Many Prolog programs are unnecessarily impure because of inadequate means to
express syntactic inequality. While the frequently provided built-in `dif/2` is
able to correctly describe expected answers, its direct use in programs often
leads to overly complex and inefficient definitions --- mainly due to the lack
of adequate indexing mechanisms. We propose to overcome these problems by using
a new predicate that subsumes both equality and inequality via reification.
Code complexity is reduced with a monotonic, higher-order if-then-else
construct based on `call/N`. For comparable correct uses of impure definitions,
our approach is as determinate and similarly efficient as its impure
counterparts.
</summary>
    <author>
      <name>Ulrich Neumerkel</name>
    </author>
    <author>
      <name>Stefan Kral</name>
    </author>
    <link href="http://arxiv.org/abs/1607.01590v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.01590v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.02226v1</id>
    <updated>2016-07-08T05:30:43Z</updated>
    <published>2016-07-08T05:30:43Z</published>
    <title>Renaming Global Variables in C Mechanically Proved Correct</title>
    <summary>  Most integrated development environments are shipped with refactoring tools.
However, their refactoring operations are often known to be unreliable. As a
consequence, developers have to test their code after applying an automatic
refactoring. In this article, we consider a refactoring operation (renaming of
global variables in C), and we prove that its core implementation preserves the
set of possible behaviors of transformed programs. That proof of correctness
relies on the operational semantics of C provided by CompCert C in Coq.
</summary>
    <author>
      <name>Julien Cohen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Université de Nantes</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.216.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.216.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT 2016, arXiv:1607.01835</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 216, 2016, pp. 50-64</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.02226v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.02226v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.02228v1</id>
    <updated>2016-07-08T05:31:02Z</updated>
    <published>2016-07-08T05:31:02Z</published>
    <title>Towards Trustworthy Refactoring in Erlang</title>
    <summary>  Tool-assisted refactoring transformations must be trustworthy if programmers
are to be confident in applying them on arbitrarily extensive and complex code
in order to improve style or efficiency. We propose a simple, high-level but
rigorous, notation for defining refactoring transformations in Erlang, and show
that this notation provides an extensible, verifiable and executable
specification language for refactoring. To demonstrate the applicability of our
approach, we show how to define and verify a number of example refactorings in
the system.
</summary>
    <author>
      <name>Dániel Horpácsi</name>
    </author>
    <author>
      <name>Judit Kőszegi</name>
    </author>
    <author>
      <name>Simon Thompson</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.216.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.216.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT 2016, arXiv:1607.01835</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 216, 2016, pp. 83-103</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.02228v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.02228v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.02230v1</id>
    <updated>2016-07-08T05:31:36Z</updated>
    <published>2016-07-08T05:31:36Z</published>
    <title>Turchin's Relation for Call-by-Name Computations: A Formal Approach</title>
    <summary>  Supercompilation is a program transformation technique that was first
described by V. F. Turchin in the 1970s. In supercompilation, Turchin's
relation as a similarity relation on call-stack configurations is used both for
call-by-value and call-by-name semantics to terminate unfolding of the program
being transformed. In this paper, we give a formal grammar model of
call-by-name stack behaviour. We classify the model in terms of the Chomsky
hierarchy and then formally prove that Turchin's relation can terminate all
computations generated by the model.
</summary>
    <author>
      <name>Antonina Nepeivoda</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.216.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.216.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT 2016, arXiv:1607.01835</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 216, 2016, pp. 137-159</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.02230v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.02230v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.02231v1</id>
    <updated>2016-07-08T05:35:59Z</updated>
    <published>2016-07-08T05:35:59Z</published>
    <title>Resiliency with Aggregate Computing: State of the Art and Roadmap</title>
    <summary>  One of the difficulties in developing collective adaptive systems is the
challenge of simultaneously engineering both the desired resilient behaviour of
the collective and the details of its implementation on individual devices.
Aggregate computing simplifies this problem by separating these aspects into
different layers of abstraction by means of a unifying notion of computational
field and a functional computational model. We review the state of the art in
aggregate computing, discuss the various resiliency properties it supports, and
develop a roadmap of foundational problems still needing to be addressed in the
continued development of this emerging discipline.
</summary>
    <author>
      <name>Mirko Viroli</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Bologna, Cesena, Italy</arxiv:affiliation>
    </author>
    <author>
      <name>Jacob Beal</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Raytheon BBN Technologies Cambridge, MA, USA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.217.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.217.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings FORECAST 2016, arXiv:1607.02001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 217, 2016, pp. 5-18</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.02231v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.02231v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.02902v1</id>
    <updated>2016-07-11T11:08:00Z</updated>
    <published>2016-07-11T11:08:00Z</published>
    <title>sk_p: a neural program corrector for MOOCs</title>
    <summary>  We present a novel technique for automatic program correction in MOOCs,
capable of fixing both syntactic and semantic errors without manual, problem
specific correction strategies. Given an incorrect student program, it
generates candidate programs from a distribution of likely corrections, and
checks each candidate for correctness against a test suite.
  The key observation is that in MOOCs many programs share similar code
fragments, and the seq2seq neural network model, used in the natural-language
processing task of machine translation, can be modified and trained to recover
these fragments.
  Experiment shows our scheme can correct 29% of all incorrect submissions and
out-performs state of the art approach which requires manual, problem specific
correction strategies.
</summary>
    <author>
      <name>Yewen Pu</name>
    </author>
    <author>
      <name>Karthik Narasimhan</name>
    </author>
    <author>
      <name>Armando Solar-Lezama</name>
    </author>
    <author>
      <name>Regina Barzilay</name>
    </author>
    <link href="http://arxiv.org/abs/1607.02902v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.02902v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1607.04461v1</id>
    <updated>2016-07-15T11:05:26Z</updated>
    <published>2016-07-15T11:05:26Z</published>
    <title>Horn Binary Serialization Analysis</title>
    <summary>  A bit layout is a sequence of fields of certain bit lengths that specifies
how to interpret a serial stream, e.g., the MP3 audio format. A layout with
variable length fields needs to include meta-information to help the parser
interpret unambiguously the rest of the stream; e.g. a field providing the
length of a following variable length field. If no such information is
available, then the layout is ambiguous. I present a linear-time algorithm to
determine whether a layout is ambiguous or not by modelling the behaviour of a
serial parser reading the stream as forward chaining reasoning on a collection
of Horn clauses.
</summary>
    <author>
      <name>Gabriele Paganelli</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.219.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.219.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings HCVS2016, arXiv:1607.04033</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 219, 2016, pp. 56-68</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1607.04461v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1607.04461v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.01228v1</id>
    <updated>2017-05-03T01:49:29Z</updated>
    <published>2017-05-03T01:49:29Z</published>
    <title>A Versatile, Sound Tool for Simplifying Definitions</title>
    <summary>  We present a tool, simplify-defun, that transforms the definition of a given
function into a simplified definition of a new function, providing a proof
checked by ACL2 that the old and new functions are equivalent. When appropriate
it also generates termination and guard proofs for the new function. We explain
how the tool is engineered so that these proofs will succeed. Examples
illustrate its utility, in particular for program transformation in synthesis
and verification.
</summary>
    <author>
      <name>Alessandro Coglio</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Kestrel Institute</arxiv:affiliation>
    </author>
    <author>
      <name>Matt Kaufmann</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Department of Computer Science, The University of Texas at Austin</arxiv:affiliation>
    </author>
    <author>
      <name>Eric W. Smith</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Kestrel Institute</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.249.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.249.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ACL2Workshop 2017, arXiv:1705.00766</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 249, 2017, pp. 61-77</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1705.01228v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.01228v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.04680v2</id>
    <updated>2017-05-19T22:00:25Z</updated>
    <published>2017-05-12T17:59:41Z</published>
    <title>Proof Mining with Dependent Types</title>
    <summary>  Several approaches exist to data-mining big corpora of formal proofs. Some of
these approaches are based on statistical machine learning, and some -- on
theory exploration. However, most are developed for either untyped or
simply-typed theorem provers. In this paper, we present a method that combines
statistical data mining and theory exploration in order to analyse and automate
proofs in dependently typed language of Coq.
</summary>
    <author>
      <name>Ekaterina Komendantskaya</name>
    </author>
    <author>
      <name>Jonathan Heras</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted at CICM'17, Edinburgh, 17-21 July 2017</arxiv:comment>
    <link href="http://arxiv.org/abs/1705.04680v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.04680v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1705.07678v1</id>
    <updated>2017-05-22T11:30:54Z</updated>
    <published>2017-05-22T11:30:54Z</published>
    <title>Imperative Functional Programs that Explain their Work</title>
    <summary>  Program slicing provides explanations that illustrate how program outputs
were produced from inputs. We build on an approach introduced in prior work by
Perera et al., where dynamic slicing was defined for pure higher-order
functional programs as a Galois connection between lattices of partial inputs
and partial outputs. We extend this approach to imperative functional programs
that combine higher-order programming with references and exceptions. We
present proofs of correctness and optimality of our approach and a
proof-of-concept implementation and experimental evaluation.
</summary>
    <author>
      <name>Wilmer Ricciotti</name>
    </author>
    <author>
      <name>Jan Stolarek</name>
    </author>
    <author>
      <name>Roly Perera</name>
    </author>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3110258</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3110258" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Full version of ICFP 2017 paper, with appendices</arxiv:comment>
    <link href="http://arxiv.org/abs/1705.07678v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1705.07678v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.09052v1</id>
    <updated>2017-12-25T10:31:12Z</updated>
    <published>2017-12-25T10:31:12Z</published>
    <title>PWCT: Visual Language for IoT and Cloud Computing Applications and
  Systems</title>
    <summary>  Developing IoT, Data Computing and Cloud Computing software requires
different programming skills and different programming languages. This cause a
problem for many companies and researchers that need to hires many programmers
to develop a complete solution. The problem is related directly to the
financial cost and the development time which are very important factors to
many research projects. In this paper we present and propose the PWCT visual
programming tool for developing IoT, Data Computing and Cloud Computing
Applications and Systems without writing textual code directly. Using PWCT
increase productivity and provide researchers with one visual programming tool
to develop different solutions.
</summary>
    <author>
      <name>Mahmoud S. Fayed</name>
    </author>
    <author>
      <name>Muhammad Al-Qurishi</name>
    </author>
    <author>
      <name>Atif Alamri</name>
    </author>
    <author>
      <name>Ahmad A. Al-Daraiseh</name>
    </author>
    <link href="http://arxiv.org/abs/1712.09052v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.09052v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1712.09958v2</id>
    <updated>2019-02-27T16:51:19Z</updated>
    <published>2017-12-28T18:07:46Z</published>
    <title>Object-Oriented Theorem Proving (OOTP): First Thoughts</title>
    <summary>  Automatic (i.e., computer-assisted) theorem proving (ATP) can come in many
flavors. This document presents early steps in our effort towards defining
object-oriented theorem proving (OOTP) as a new style of ATP.
  Traditional theorem proving (TTP) is the only well-known flavor of ATP so
far. OOTP is a generalization of TTP. While TTP is strongly based on functional
programming (FP), OOTP is strongly based on object-oriented programming (OOP)
instead. We believe OOTP is a style of theorem proving that is no less powerful
and no less natural than TTP and thus likely will be no less practically useful
than TTP.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1712.09958v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1712.09958v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.00787v1</id>
    <updated>2018-02-02T17:47:16Z</updated>
    <published>2018-02-02T17:47:16Z</published>
    <title>Zero-Cost Coercions for Program and Proof Reuse</title>
    <summary>  We introduce the notion of identity coercions between non-indexed and indexed
variants of inductive datatypes, such as lists and vectors. An identity
coercion translates one type to another such that the coercion function
definitionally reduces to the identity function. This allows us to reuse vector
programs to derive list programs (and vice versa), without any runtime cost.
This also allows us to reuse vector proofs to derive list proofs (and vice
versa), without the cost of equational reasoning proof obligations. Our work is
formalized in Cedille, a dependently typed programming language based on a
type-annotated Curry-style type the- ory with implicit (or, erased) products
(or, dependent functions), and relies crucially on erasure to introduce
definitional equalities between underlying untyped terms.
</summary>
    <author>
      <name>Larry Diehl</name>
    </author>
    <author>
      <name>Aaron Stump</name>
    </author>
    <link href="http://arxiv.org/abs/1802.00787v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.00787v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.02951v2</id>
    <updated>2018-11-21T16:12:53Z</updated>
    <published>2018-02-08T16:29:43Z</published>
    <title>A Separation Logic for Concurrent Randomized Programs</title>
    <summary>  We present Polaris, a concurrent separation logic with support for
probabilistic reasoning. As part of our logic, we extend the idea of coupling,
which underlies recent work on probabilistic relational logics, to the setting
of programs with both probabilistic and non-deterministic choice. To
demonstrate Polaris, we verify a variant of a randomized concurrent counter
algorithm and a two-level concurrent skip list. All of our results have been
mechanized in Coq.
</summary>
    <author>
      <name>Joseph Tassarotti</name>
    </author>
    <author>
      <name>Robert Harper</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3290377</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3290377" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">31 pages. Extended version of POPL 2019 paper</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. ACM Program. Lang. 3, POPL, Article 64 (January 2019)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1802.02951v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.02951v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.03998v1</id>
    <updated>2018-02-12T12:04:49Z</updated>
    <published>2018-02-12T12:04:49Z</published>
    <title>Erlang Code Evolution Control (Use Cases)</title>
    <summary>  The main goal of this work is to show how SecEr can be used in different
scenarios. Concretely, we demonstrate how a user can run SecEr to obtain
reports about the behaviour preservation between versions as well as how a user
can use SecEr to find the source of a discrepancy. The use cases presented are
three: two completely different versions of the same program, an improvement in
the performance of a function and a program where an error has been introduced.
A complete description of the technique and the tool is available at [1] and
[2].
</summary>
    <author>
      <name>David Insa</name>
    </author>
    <author>
      <name>Sergio Pérez</name>
    </author>
    <author>
      <name>Josep Silva</name>
    </author>
    <author>
      <name>Salvador Tamarit</name>
    </author>
    <link href="http://arxiv.org/abs/1802.03998v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.03998v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.04408v1</id>
    <updated>2018-02-13T00:29:31Z</updated>
    <published>2018-02-13T00:29:31Z</published>
    <title>REAS: Combining Numerical Optimization with SAT Solving</title>
    <summary>  In this paper, we present ReaS, a technique that combines numerical
optimization with SAT solving to synthesize unknowns in a program that involves
discrete and floating point computation. ReaS makes the program end-to-end
differentiable by smoothing any Boolean expression that introduces
discontinuity such as conditionals and relaxing the Boolean unknowns so that
numerical optimization can be performed. On top of this, ReaS uses a SAT solver
to help the numerical search overcome local solutions by incrementally fixing
values to the Boolean expressions. We evaluated the approach on 5 case studies
involving hybrid systems and show that ReaS can synthesize programs that could
not be solved by previous SMT approaches.
</summary>
    <author>
      <name>Jeevana Priya Inala</name>
    </author>
    <author>
      <name>Sicun Gao</name>
    </author>
    <author>
      <name>Soonho Kong</name>
    </author>
    <author>
      <name>Armando Solar-Lezama</name>
    </author>
    <link href="http://arxiv.org/abs/1802.04408v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.04408v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.06283v2</id>
    <updated>2018-05-13T21:58:17Z</updated>
    <published>2018-02-17T20:14:10Z</published>
    <title>Almost Sure Productivity</title>
    <summary>  We define Almost Sure Productivity (ASP), a probabilistic generalization of
the productivity condition for coinductively defined structures. Intuitively, a
probabilistic coinductive stream or tree is ASP if it produces infinitely many
outputs with probability 1. Formally, we define almost sure productivity using
a final coalgebra semantics of programs inspired from Kerstan and K\"onig.
Then, we introduce a core language for probabilistic streams and trees, and
provide two approaches to verify ASP: a sufficient syntactic criterion, and a
reduction to model-checking pCTL* formulas on probabilistic pushdown automata.
The reduction shows that ASP is decidable for our core language.
</summary>
    <author>
      <name>Alejandro Aguirre</name>
    </author>
    <author>
      <name>Gilles Barthe</name>
    </author>
    <author>
      <name>Justin Hsu</name>
    </author>
    <author>
      <name>Alexandra Silva</name>
    </author>
    <link href="http://arxiv.org/abs/1802.06283v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.06283v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.06651v1</id>
    <updated>2018-02-19T14:42:34Z</updated>
    <published>2018-02-19T14:42:34Z</published>
    <title>CalcuList: a Functional Language Extended with Imperative Features</title>
    <summary>  CalcuList (Calculator with List manipulation), is an educational language for
teaching functional programming extended with some imperative and side-effect
features, which are enabled under explicit request by the programmer. In
addition to strings and lists, the language natively supports json objects. The
language adopts a Python-like syntax and enables interactive computation
sessions with the user through a REPL (Read-Evaluate-Print-Loop) shell. The
object code produced by a compilation is a program that will be eventually
executed by the CalcuList Virtual Machine (CLVM).
</summary>
    <author>
      <name>Domenico Sacca'</name>
    </author>
    <author>
      <name>Angelo Furfaro</name>
    </author>
    <link href="http://arxiv.org/abs/1802.06651v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.06651v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1802.07284v1</id>
    <updated>2018-02-20T19:04:14Z</updated>
    <published>2018-02-20T19:04:14Z</published>
    <title>Logic Programming Applications: What Are the Abstractions and
  Implementations?</title>
    <summary>  This article presents an overview of applications of logic programming,
classifying them based on the abstractions and implementations of logic
languages that support the applications. The three key abstractions are join,
recursion, and constraint. Their essential implementations are for-loops, fixed
points, and backtracking, respectively. The corresponding kinds of applications
are database queries, inductive analysis, and combinatorial search,
respectively. We also discuss language extensions and programming paradigms,
summarize example application problems by application areas, and touch on
example systems that support variants of the abstractions with different
implementations.
</summary>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3191315.3191326</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3191315.3191326" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In M. Kifer and Y.A. Liu, editors, Declarative Logic Programming:
  Theory, Systems, and Applications, Chapter 10, pages 519-557, ACM and Morgan
  &amp; Claypool, 2018</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1802.07284v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1802.07284v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.01836v1</id>
    <updated>2018-04-05T13:21:10Z</updated>
    <published>2018-04-05T13:21:10Z</published>
    <title>Higher-Order Bounded Model Checking</title>
    <summary>  We present a Bounded Model Checking technique for higher-order programs. The
vehicle of our study is a higher-order calculus with general references. Our
technique is a symbolic state syntactical translation based on SMT solvers,
adapted to a setting where the values passed and stored during computation can
be functions of arbitrary order. We prove that our algorithm is sound, and
devise an optimisation based on points-to analysis to improve scalability. We
moreover provide a prototype implementation of the algorithm with experimental
results showcasing its performance.
</summary>
    <author>
      <name>Yu-Yang Lin</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <link href="http://arxiv.org/abs/1804.01836v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.01836v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.03460v1</id>
    <updated>2018-04-10T11:25:06Z</updated>
    <published>2018-04-10T11:25:06Z</published>
    <title>Factorisation systems for logical relations and monadic lifting in
  type-and-effect system semantics</title>
    <summary>  Type-and-effect systems incorporate information about the computational
effects, e.g., state mutation, probabilistic choice, or I/O, a program phrase
may invoke alongside its return value. A semantics for type-and-effect systems
involves a parameterised family of monads whose size is exponential in the
number of effects. We derive such refined semantics from a single monad over a
category, a choice of algebraic operations for this monad, and a suitable
factorisation system over this category. We relate the derived semantics to the
original semantics using fibrations for logical relations. Our proof uses a
folklore technique for lifting monads with operations.
</summary>
    <author>
      <name>Ohad Kammar</name>
    </author>
    <author>
      <name>Dylan McDermott</name>
    </author>
    <link href="http://arxiv.org/abs/1804.03460v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.03460v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.04052v1</id>
    <updated>2018-04-11T15:34:42Z</updated>
    <published>2018-04-11T15:34:42Z</published>
    <title>Constraint-Based Synthesis of Coupling Proofs</title>
    <summary>  Proof by coupling is a classical technique for proving properties about pairs
of randomized algorithms by carefully relating (or coupling) two probabilistic
executions. In this paper, we show how to automatically construct such proofs
for probabilistic programs. First, we present f-coupled postconditions, an
abstraction describing two correlated program executions. Second, we show how
properties of f-coupled postconditions can imply various probabilistic
properties of the original programs. Third, we demonstrate how to reduce the
proof-search problem to a purely logical synthesis problem of the form $\exists
f\ldotp \forall X\ldotp \phi$, making probabilistic reasoning unnecessary. We
develop a prototype implementation to automatically build coupling proofs for
probabilistic properties, including uniformity and independence of program
expressions.
</summary>
    <author>
      <name>Aws Albarghouthi</name>
    </author>
    <author>
      <name>Justin Hsu</name>
    </author>
    <link href="http://arxiv.org/abs/1804.04052v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.04052v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1804.07078v2</id>
    <updated>2019-01-21T13:42:46Z</updated>
    <published>2018-04-19T10:50:11Z</published>
    <title>Reducing asynchrony to synchronized rounds</title>
    <summary>  Synchronous computation models simplify the design and the verification of
fault-tolerant distributed systems. For efficiency reasons such systems are
designed and implemented using an asynchronous semantics. In this paper, we
bridge the gap between these two worlds. We introduce a (synchronous)
round-based computational model and we prove a reduction for a class of
asynchronous protocols to our new model. The reduction is based on properties
of the code that can be checked with sequential methods. We apply the reduction
to state machine replication systems, such as, Paxos, Zab, and Viewstamped
Replication.
</summary>
    <author>
      <name>Andrei Damien</name>
    </author>
    <author>
      <name>Cezara Dragoi</name>
    </author>
    <author>
      <name>Alexandru Militaru</name>
    </author>
    <author>
      <name>Josef Widder</name>
    </author>
    <link href="http://arxiv.org/abs/1804.07078v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1804.07078v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.00067v1</id>
    <updated>2018-06-29T20:59:55Z</updated>
    <published>2018-06-29T20:59:55Z</published>
    <title>Josephine: Using JavaScript to safely manage the lifetimes of Rust data</title>
    <summary>  This paper is about the interface between languages which use a garbage
collector and those which use fancy types for safe manual memory management.
Garbage collection is the traditional memory management scheme for functional
languages, whereas type systems are now used for memory safety in imperative
languages. We use existing techniques for linear capabilities to provide safe
access to copyable references, but the application to languages with a tracing
garbage collector, and to data with explicit lifetimes is new. This work is
related to mixed linear/non-linear programming, but the languages being mixed
are Rust and JavaScript.
</summary>
    <author>
      <name>Alan Jeffrey</name>
    </author>
    <link href="http://arxiv.org/abs/1807.00067v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.00067v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.00661v3</id>
    <updated>2019-02-18T14:47:21Z</updated>
    <published>2018-07-02T13:46:38Z</published>
    <title>Transient Typechecks are (Almost) Free</title>
    <summary>  Transient gradual typing imposes run-time type tests that typically cause a
linear slowdown in programs' performance. This performance impact discourages
the use of type annotations because adding types to a program makes the program
slower. A virtual machine can employ standard just-in-time optimizations to
reduce the overhead of transient checks to near zero. These optimizations can
give gradually-typed languages performance comparable to state-of-the-art
dynamic languages, so programmers can add types to their code without affecting
their programs' performance.
</summary>
    <author>
      <name>Richard Roberts</name>
    </author>
    <author>
      <name>Stefan Marr</name>
    </author>
    <author>
      <name>Michael Homer</name>
    </author>
    <author>
      <name>James Noble</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Draft</arxiv:comment>
    <link href="http://arxiv.org/abs/1807.00661v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.00661v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.04084v1</id>
    <updated>2018-07-11T11:39:07Z</updated>
    <published>2018-07-11T11:39:07Z</published>
    <title>Relating Idioms, Arrows and Monads from Monoidal Adjunctions</title>
    <summary>  We revisit once again the connection between three notions of computation:
monads, arrows and idioms (also called applicative functors). We employ
monoidal categories of finitary functors and profunctors on finite sets as
models of these notions of computation, and develop the connections between
them through adjunctions. As a result, we obtain a categorical version of
Lindley, Yallop and Wadler's characterisation of monads and idioms as arrows
satisfying an isomorphism.
</summary>
    <author>
      <name>Exequiel Rivas</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.275.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.275.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MSFP 2018, arXiv:1807.03732</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 275, 2018, pp. 18-33</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1807.04084v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.04084v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.08427v1</id>
    <updated>2018-07-23T04:47:48Z</updated>
    <published>2018-07-23T04:47:48Z</published>
    <title>Data Race Detection on Compressed Traces</title>
    <summary>  We consider the problem of detecting data races in program traces that have
been compressed using straight line programs (SLP), which are special
context-free grammars that generate exactly one string, namely the trace that
they represent. We consider two classical approaches to race detection ---
using the happens-before relation and the lockset discipline. We present
algorithms for both these methods that run in time that is linear in the size
of the compressed, SLP representation. Typical program executions almost always
exhibit patterns that lead to significant compression. Thus, our algorithms are
expected to result in large speedups when compared with analyzing the
uncompressed trace. Our experimental evaluation of these new algorithms on
standard benchmarks confirms this observation.
</summary>
    <author>
      <name>Dileep Kini</name>
    </author>
    <author>
      <name>Umang Mathur</name>
    </author>
    <author>
      <name>Mahesh Viswanathan</name>
    </author>
    <link href="http://arxiv.org/abs/1807.08427v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.08427v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1807.11792v2</id>
    <updated>2018-08-01T08:45:43Z</updated>
    <published>2018-07-31T12:46:13Z</published>
    <title>Computing Integer Sequences: Filtering vs Generation (Functional Pearl)</title>
    <summary>  As a report of a teaching experience, we analyse Haskell programs computing
two integer sequences: the Hamming sequence and the Ulam sequence. For both of
them, we investigate two strategies of computation: the first is based on
filtering out those natural numbers that do not belong to the sequence, whereas
the second is based on the direct generation of num- bers that belong to the
sequence. Advocating cross-fertilisation among ideas emerging when programming
in different programming paradigms, in the background, we sketch out some
considerations about corresponding C programs solving the same two problems.
</summary>
    <author>
      <name>Ivano Salvo</name>
    </author>
    <author>
      <name>Agnese Pacifico</name>
    </author>
    <link href="http://arxiv.org/abs/1807.11792v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1807.11792v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.01337v2</id>
    <updated>2020-01-07T08:45:23Z</updated>
    <published>2020-01-05T23:48:41Z</published>
    <title>A Diagrammatic Calculus for Algebraic Effects</title>
    <summary>  We introduce a new diagrammatic notation for representing the result of
(algebraic) effectful computations. Our notation explicitly separates the
effects produced during a computation from the possible values returned, this
way simplifying the extension of definitions and results on pure computations
to an effectful setting. Additionally, we show a number of algebraic and
order-theoretic laws on diagrams, this way laying the foundations for a
diagrammatic calculus of algebraic effects. We give a formal foundation for
such a calculus in terms of Lawvere theories and generic effects.
</summary>
    <author>
      <name>Ugo Dal Lago</name>
    </author>
    <author>
      <name>Francesco Gavazzo</name>
    </author>
    <link href="http://arxiv.org/abs/2001.01337v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.01337v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.02630v1</id>
    <updated>2020-01-07T13:07:22Z</updated>
    <published>2020-01-07T13:07:22Z</published>
    <title>Albert, an intermediate smart-contract language for the Tezos blockchain</title>
    <summary>  Tezos is a smart-contract blockchain. Tezos smart contracts are written in a
low-level stack-based language called Michelson. In this article we present
Albert, an intermediate language for Tezos smart contracts which abstracts
Michelson stacks as linearly typed records. We also describe its compiler to
Michelson, written in Coq, that targets Mi-Cho-Coq, a formal specification of
Michelson implemented in Coq.
</summary>
    <author>
      <name>Bruno Bernardo</name>
    </author>
    <author>
      <name>Raphaël Cauderlier</name>
    </author>
    <author>
      <name>Basile Pesin</name>
    </author>
    <author>
      <name>Julien Tesson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages. arXiv admin note: text overlap with arXiv:1909.08671</arxiv:comment>
    <link href="http://arxiv.org/abs/2001.02630v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.02630v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.05059v1</id>
    <updated>2020-01-14T22:03:48Z</updated>
    <published>2020-01-14T22:03:48Z</published>
    <title>Gillian: Compositional Symbolic Execution for All</title>
    <summary>  We present Gillian, a language-independent framework for the development of
compositional symbolic analysis tools. Gillian supports three flavours of
analysis: whole-program symbolic testing, full verification, and bi-abduction.
It comes with fully parametric meta-theoretical results and a modular
implementation, designed to minimise the instantiation effort required of the
user. We evaluate Gillian by instantiating it to JavaScript and C, and perform
its analyses on a set of data-structure libraries, obtaining results that
indicate that Gillian is robust enough to reason about real-world programming
languages.
</summary>
    <author>
      <name>José Fragoso Santos</name>
    </author>
    <author>
      <name>Petar Maksimović</name>
    </author>
    <author>
      <name>Sacha-Élie Ayoun</name>
    </author>
    <author>
      <name>Philippa Gardner</name>
    </author>
    <link href="http://arxiv.org/abs/2001.05059v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.05059v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.06943v1</id>
    <updated>2020-01-20T02:18:04Z</updated>
    <published>2020-01-20T02:18:04Z</published>
    <title>Probabilistic Output Analyses for Deterministic Programs --- Reusing
  Existing Non-probabilistic Analyses</title>
    <summary>  We consider reusing established non-probabilistic output analyses (either
forward or backwards) that yield over-approximations of a program's pre-image
or image relation, e.g., interval analyses. We assume a probability measure
over the program input and present two techniques (one for forward and one for
backward analyses) that both derive upper and lower probability bounds for the
output events. We demonstrate the most involved technique, namely the forward
technique, for two examples and compare their results to a cutting-edge
probabilistic output analysis.
</summary>
    <author>
      <name>Maja Hanne Kirkeby</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Science, Roskilde University, Denmark</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.312.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.312.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings QAPL 2019, arXiv:2001.06163</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 312, 2020, pp. 43-57</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2001.06943v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.06943v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.08133v1</id>
    <updated>2020-01-22T16:31:45Z</updated>
    <published>2020-01-22T16:31:45Z</published>
    <title>Drawing Prolog Search Trees: A Manual for Teachers and Students of Logic
  Programming</title>
    <summary>  Programming in Prolog is hard for programmers that are used to procedural
coding. In this manual the method of drawing search trees is introduced with
the aim to get a better understanding of how Prolog works. After giving a first
example of a Prolog database, query and search tree, the art of drawing search
trees is systematically introduced giving guidelines for queries with
variables, conjunction, disjunction, and negation. Further examples are
provided by giving the complete search trees that are shown in Learn Prolog
Now!
</summary>
    <author>
      <name>Johan Bos</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages, 8 listings, 7 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2001.08133v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.08133v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2001.10594v2</id>
    <updated>2020-04-29T15:33:59Z</updated>
    <published>2020-01-28T21:21:44Z</published>
    <title>Simplifying Casts and Coercions</title>
    <summary>  This paper introduces norm_cast, a toolbox of tactics for the Lean proof
assistant designed to manipulate expressions containing coercions and casts.
These expressions can be frustrating for beginning and expert users alike; the
presence of coercions can cause seemingly identical expressions to fail to
unify and rewrites to fail. The norm_cast tactics aim to make reasoning with
such expressions as transparent as possible. They are used extensively to
eliminate boilerplate arguments in the Lean mathematical library and in
external developments.
</summary>
    <author>
      <name>Robert Y. Lewis</name>
    </author>
    <author>
      <name>Paul-Nicolas Madelaine</name>
    </author>
    <link href="http://arxiv.org/abs/2001.10594v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2001.10594v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2003.01422v2</id>
    <updated>2020-04-04T21:01:01Z</updated>
    <published>2020-03-03T10:16:52Z</published>
    <title>The Prolog Debugger and Declarative Programming. Examples</title>
    <summary>  This paper contains examples for a companion paper "The Prolog Debugger and
Declarative Programming", which discusses (in)adequacy of the Prolog debugger
for declarative programming.
  Logic programming is a declarative programming paradigm. Programming language
Prolog makes logic programming possible, at least to a substantial extent.
However the Prolog debugger works solely in terms of the operational semantics.
So it is incompatible with declarative programming. The companion paper tries
to find methods of using it from the declarative point of view. Here we provide
examples of applying them.
</summary>
    <author>
      <name>Włodzimierz Drabent</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 pages, 8 figures (an example added to the previous version + a few
  corrections)</arxiv:comment>
    <link href="http://arxiv.org/abs/2003.01422v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2003.01422v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N17 (Primary) 68N30 (Secondary)" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; D.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2003.03449v1</id>
    <updated>2020-03-06T21:31:21Z</updated>
    <published>2020-03-06T21:31:21Z</published>
    <title>Code Obfuscation for the C/C++ Language</title>
    <summary>  Obfuscation is the action of making something unintelligible. In software
development, this action can be applied to source code or binary applications.
The aim of this dissertation was to implement a tool for the obfuscation of C
and C++ source code. The motivation was to allow proprietary code to be
distributed to third-parties without risking a recreation of the intellectual
property within it. While many obfuscators exist, they seldom focus on software
that is distributed in source code form. This dissertation presents the
challenges and successes that arose during the development of a C and C++
source code obfuscator using the Nim programming language.
</summary>
    <author>
      <name>Dominik Picheta</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Document also available in https://picheta.me/c_cpp_obfuscator.pdf</arxiv:comment>
    <link href="http://arxiv.org/abs/2003.03449v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2003.03449v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2003.05836v1</id>
    <updated>2020-03-12T15:08:31Z</updated>
    <published>2020-03-12T15:08:31Z</published>
    <title>Control-flow Flattening Preserves the Constant-Time Policy (Extended
  Version)</title>
    <summary>  Obfuscating compilers protect a software by obscuring its meaning and
impeding the reconstruction of its original source code. The typical concern
when defining such compilers is their robustness against reverse engineering
and the performance of the produced code. Little work has been done in studying
whether the security properties of a program are preserved under obfuscation.
In this paper we start addressing this problem: we consider control-flow
flattening, a popular obfuscation technique used in industrial compilers, and a
specific security policy, namely constant-time. We prove that this obfuscation
preserves the policy, i.e., that every program satisfying the policy still does
after the transformation.
</summary>
    <author>
      <name>Matteo Busi</name>
    </author>
    <author>
      <name>Pierpaolo Degano</name>
    </author>
    <author>
      <name>Letterio Galletta</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of ITASEC20 camera ready paper</arxiv:comment>
    <link href="http://arxiv.org/abs/2003.05836v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2003.05836v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.01322v1</id>
    <updated>2020-04-03T01:25:32Z</updated>
    <published>2020-04-03T01:25:32Z</published>
    <title>Duality of Session Types: The Final Cut</title>
    <summary>  Duality is a central concept in the theory of session types. Since a flaw was
found in the original definition of duality for recursive types, several other
definitions have been published. As their connection is not obvious, we compare
the competing definitions, discuss tradeoffs, and prove some equivalences. Some
of the results are mechanized in Agda.
</summary>
    <author>
      <name>Simon J. Gay</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">School of Computing Science, University of Glasgow, UK</arxiv:affiliation>
    </author>
    <author>
      <name>Peter Thiemann</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Institut für Informatik, University of Freiburg, Germany</arxiv:affiliation>
    </author>
    <author>
      <name>Vasco T. Vasconcelos</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Faculdade de Ciências, University of Lisbon, Portugal</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.314.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.314.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2020, arXiv:2004.01062</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 314, 2020, pp. 23-33</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2004.01322v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.01322v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.01323v1</id>
    <updated>2020-04-03T01:25:46Z</updated>
    <published>2020-04-03T01:25:46Z</published>
    <title>Bounded verification of message-passing concurrency in Go using Promela
  and Spin</title>
    <summary>  This paper describes a static verification framework for the message-passing
fragment of the Go programming language. Our framework extracts models that
over-approximate the message-passing behaviour of a program. These models, or
behavioural types, are encoded in Promela, hence can be efficiently verified
with Spin. We improve on previous works by verifying programs that include
communication-related parameters that are unknown at compile-time, i.e.,
programs that spawn a parameterised number of threads or that create channels
with a parameterised capacity. These programs are checked via a bounded
verification approach with bounds provided by the user.
</summary>
    <author>
      <name>Nicolas Dilley</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Kent</arxiv:affiliation>
    </author>
    <author>
      <name>Julien Lange</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Kent</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.314.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.314.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2020, arXiv:2004.01062</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 314, 2020, pp. 34-45</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2004.01323v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.01323v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.01324v1</id>
    <updated>2020-04-03T01:26:04Z</updated>
    <published>2020-04-03T01:26:04Z</published>
    <title>Mixed Sessions: the Other Side of the Tape</title>
    <summary>  The original paper on Mixed Sessions introduce the side A of the tape: there
is an encoding of classical sessions into mixed sessions. Here we present side
B: there is a translation of (a subset of) mixed sessions into classical
session types. We prove that the translation is a minimal encoding, according
to the criteria put forward by Kouzapas, P\'erez, and Yoshida.
</summary>
    <author>
      <name>Filipe Casal</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciências, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <author>
      <name>Andreia Mordido</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciências, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <author>
      <name>Vasco T. Vasconcelos</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciências, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.314.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.314.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2020, arXiv:2004.01062</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 314, 2020, pp. 46-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2004.01324v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.01324v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.01325v1</id>
    <updated>2020-04-03T01:26:22Z</updated>
    <published>2020-04-03T01:26:22Z</published>
    <title>Fluent Session Programming in C#</title>
    <summary>  We propose SessionC#, a lightweight session typed library for safe
concurrent/distributed programming. The key features are (1) the improved
fluent interface which enables writing communication in chained method calls,
by exploiting C#'s out variables, and (2) amalgamation of session delegation
with async/await, which materialises session cancellation in a limited form,
which we call session intervention. We show the effectiveness of our proposal
via a Bitcoin miner application.
</summary>
    <author>
      <name>Shunsuke Kimura</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Gifu University, Japan</arxiv:affiliation>
    </author>
    <author>
      <name>Keigo Imai</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Gifu University, Japan</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.314.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.314.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2020, arXiv:2004.01062</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 314, 2020, pp. 61-75</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2004.01325v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.01325v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.03557v1</id>
    <updated>2020-04-07T17:32:21Z</updated>
    <published>2020-04-07T17:32:21Z</published>
    <title>A categorical approach to secure compilation</title>
    <summary>  We introduce a novel approach to secure compilation based on maps of
distributive laws. We demonstrate through four examples that the coherence
criterion for maps of distributive laws can potentially be a viable alternative
for compiler security instead of full abstraction, which is the preservation
and reflection of contextual equivalence. To that end, we also make use of the
well-behavedness properties of distributive laws to construct a categorical
argument for the contextual connotations of bisimilarity.
</summary>
    <author>
      <name>Stelios Tsampas</name>
    </author>
    <author>
      <name>Andreas Nuyts</name>
    </author>
    <author>
      <name>Dominique Devriese</name>
    </author>
    <author>
      <name>Frank Piessens</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted in Coalgebraic Methods in Computer Science, ver. 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2004.03557v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.03557v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.03673v2</id>
    <updated>2020-05-26T11:47:21Z</updated>
    <published>2020-04-07T19:52:20Z</published>
    <title>Maintaining a Library of Formal Mathematics</title>
    <summary>  The Lean mathematical library mathlib is developed by a community of users
with very different backgrounds and levels of experience. To lower the barrier
of entry for contributors and to lessen the burden of reviewing contributions,
we have developed a number of tools for the library which check proof
developments for subtle mistakes in the code and generate documentation suited
for our varied audience.
</summary>
    <author>
      <name>Floris van Doorn</name>
    </author>
    <author>
      <name>Gabriel Ebner</name>
    </author>
    <author>
      <name>Robert Y. Lewis</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-53518-6_16</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-53518-6_16" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Proceedings of CICM 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2004.03673v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.03673v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.HO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.09843v1</id>
    <updated>2020-04-21T09:20:46Z</updated>
    <published>2020-04-21T09:20:46Z</published>
    <title>Egel -- Graph Rewriting with a Twist</title>
    <summary>  Egel is an untyped eager combinator toy language. Its primary purpose is to
showcase an abstract graph-rewriting semantics allowing a robust memory-safe
construction in C++. Though graph rewriters are normally implemented by
elaborate machines, this can mostly be avoided with a change in the
representation of term graphs. With an informal inductive argument, that
representation is shown to always form directed acyclic graphs. Moreover, this
graph semantics can trivially be extended to allow exception handling and cheap
concurrency. Egel, the interpreter, exploits this semantics with a
straight-forward mapping from combinators to reference-counted C++ objects.
</summary>
    <author>
      <name>M. C. A.</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Marco</arxiv:affiliation>
    </author>
    <author>
      <name> Devillers</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2004.09843v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.09843v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; F.1; I.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.11787v2</id>
    <updated>2020-04-28T06:20:39Z</updated>
    <published>2020-04-24T15:03:42Z</published>
    <title>Algebra-based Loop Synthesis</title>
    <summary>  We present an algorithm for synthesizing program loops satisfying a given
polynomial loop invariant. The class of loops we consider can be modeled by a
system of algebraic recurrence equations with constant coefficients. We turn
the task of loop synthesis into a polynomial constraint problem by precisely
characterizing the set of all loops satisfying the given invariant. We prove
soundness of our approach, as well as its completeness with respect to an a
priori fixed upper bound on the number of program variables. Our work has
applications towards program verification, as well as generating number
sequences from algebraic relations. We implemented our work in the Absynth tool
and report on our initial experiments with loop synthesis.
</summary>
    <author>
      <name>Andreas Humenberger</name>
    </author>
    <author>
      <name>Laura Kovács</name>
    </author>
    <link href="http://arxiv.org/abs/2004.11787v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.11787v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.13301v1</id>
    <updated>2020-04-28T05:06:24Z</updated>
    <published>2020-04-28T05:06:24Z</published>
    <title>Learned Garbage Collection</title>
    <summary>  Several programming languages use garbage collectors (GCs) to automatically
manage memory for the programmer. Such collectors must decide when to look for
unreachable objects to free, which can have a large performance impact on some
applications. In this preliminary work, we propose a design for a learned
garbage collector that autonomously learns over time when to perform
collections. By using reinforcement learning, our design can incorporate
user-defined reward functions, allowing an autonomous garbage collector to
learn to optimize the exact metric the user desires (e.g., request latency or
queries per second). We conduct an initial experimental study on a prototype,
demonstrating that an approach based on tabular Q learning may be promising.
</summary>
    <author>
      <name>Lujing Cen</name>
    </author>
    <author>
      <name>Ryan Marcus</name>
    </author>
    <author>
      <name>Hongzi Mao</name>
    </author>
    <author>
      <name>Justin Gottschlich</name>
    </author>
    <author>
      <name>Mohammad Alizadeh</name>
    </author>
    <author>
      <name>Tim Kraska</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3394450.3397469</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3394450.3397469" rel="related"/>
    <link href="http://arxiv.org/abs/2004.13301v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.13301v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2004.14735v1</id>
    <updated>2020-04-30T12:50:47Z</updated>
    <published>2020-04-30T12:50:47Z</published>
    <title>Proceedings Eighth Workshop on Mathematically Structured Functional
  Programming</title>
    <summary>  This volume contains the proceedings of the Eighth Workshop on Mathematically
Structured Functional Programming (MSFP 2020). The meeting was originally
scheduled to take place in Dublin, Ireland on the 25th of April as a satellite
event of the European Joint Conferences on Theory &amp; Practice of Software (ETAPS
2020).
  Due to the COVID-19 pandemic, ETAPS 2020, and consequently MSFP 2020, has
been postponed to a date yet to be determined.
  The MSFP workshop highlights applications of mathematical structures to
programming applications. We promote the use of category theory, type theory,
and formal language semantics to the development of simple and reasonable
programs. This year's papers cover a variety of topics ranging from array
programming to dependent types to effects.
</summary>
    <author>
      <name>Max S. New</name>
    </author>
    <author>
      <name>Sam Lindley</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.317</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.317" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 317, 2020</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2004.14735v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2004.14735v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.01018v2</id>
    <updated>2020-09-16T22:35:02Z</updated>
    <published>2020-05-03T08:25:11Z</published>
    <title>Certified Semantics for Relational Programming</title>
    <summary>  We present a formal study of semantics for the relational programming
language miniKanren. First, we formulate a denotational semantics which
corresponds to the minimal Herbrand model for definite logic programs. Second,
we present operational semantics which models interleaving, the distinctive
feature of miniKanren implementation, and prove its soundness and completeness
w.r.t. the denotational semantics. Our development is supported by a Coq
specification, from which a reference interpreter can be extracted. We also
derive from our main result a certified semantics (and a reference interpreter)
for SLD resolution with cut and prove its soundness.
</summary>
    <author>
      <name>Dmitry Rozplokhas</name>
    </author>
    <author>
      <name>Andrey Vyatkin</name>
    </author>
    <author>
      <name>Dmitry Boulytchev</name>
    </author>
    <link href="http://arxiv.org/abs/2005.01018v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.01018v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.02247v3</id>
    <updated>2021-12-30T08:39:17Z</updated>
    <published>2020-05-05T14:46:34Z</published>
    <title>A Linear Algebra Approach to Linear Metatheory</title>
    <summary>  Linear typed $\lambda$-calculi are more delicate than their simply typed
siblings when it comes to metatheoretic results like preservation of typing
under renaming and substitution. Tracking the usage of variables in contexts
places more constraints on how variables may be renamed or substituted. We
present a methodology based on linear algebra over semirings, extending
McBride's kits and traversals approach for the metatheory of syntax with
binding to linear usage-annotated terms. Our approach is readily formalisable,
and we have done so in Agda.
</summary>
    <author>
      <name>James Wood</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Strathclyde</arxiv:affiliation>
    </author>
    <author>
      <name>Robert Atkey</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Strathclyde</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.353.10</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.353.10" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings Linearity&amp;TLLA 2020, arXiv:2112.14305</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 353, 2021, pp. 195-212</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2005.02247v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.02247v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.04722v3</id>
    <updated>2024-02-22T21:58:36Z</updated>
    <published>2020-05-10T17:29:15Z</published>
    <title>Dynamic IFC Theorems for Free!</title>
    <summary>  We show that noninterference and transparency, the key soundness theorems for
dynamic IFC libraries, can be obtained "for free", as direct consequences of
the more general parametricity theorem of type abstraction. This allows us to
give very short soundness proofs for dynamic IFC libraries such as faceted
values and LIO. Our proofs stay short even when fully mechanized for Agda
implementations of the libraries in terms of type abstraction.
</summary>
    <author>
      <name>Maximilian Algehed</name>
    </author>
    <author>
      <name>Jean-Philippe Bernardy</name>
    </author>
    <author>
      <name>Catalin Hritcu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">CSF 2021 final version</arxiv:comment>
    <link href="http://arxiv.org/abs/2005.04722v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.04722v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.08396v2</id>
    <updated>2020-12-12T18:31:19Z</updated>
    <published>2020-05-17T23:31:23Z</published>
    <title>A tutorial introduction to quantum circuit programming in dependently
  typed Proto-Quipper</title>
    <summary>  We introduce dependently typed Proto-Quipper, or Proto-Quipper-D for short,
an experimental quantum circuit programming language with linear dependent
types. We give several examples to illustrate how linear dependent types can
help in the construction of correct quantum circuits. Specifically, we show how
dependent types enable programming families of circuits, and how dependent
types solve the problem of type-safe uncomputation of garbage qubits. We also
discuss other language features along the way.
</summary>
    <author>
      <name>Peng Fu</name>
    </author>
    <author>
      <name>Kohei Kishida</name>
    </author>
    <author>
      <name>Neil J. Ross</name>
    </author>
    <author>
      <name>Peter Selinger</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-52482-1_9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-52482-1_9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Added a section on related work and a paragraph explaining qubit
  initialization and termination</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">LNCS 12227:153-168 (2020)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2005.08396v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.08396v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.09013v1</id>
    <updated>2020-05-18T18:22:13Z</updated>
    <published>2020-05-18T18:22:13Z</published>
    <title>Weakest Preexpectation Semantics for Bayesian Inference</title>
    <summary>  We present a semantics of a probabilistic while-language with soft
conditioning and continuous distributions which handles programs diverging with
positive probability. To this end, we extend the probabilistic guarded command
language (pGCL) with draws from continuous distributions and a score operator.
The main contribution is an extension of the standard weakest preexpectation
semantics to support these constructs. As a sanity check of our semantics, we
define an alternative trace-based semantics of the language, and show that the
two semantics are equivalent. Various examples illustrate the applicability of
the semantics.
</summary>
    <author>
      <name>Marcin Szymczak</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <link href="http://arxiv.org/abs/2005.09013v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.09013v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.11644v3</id>
    <updated>2020-05-28T20:41:06Z</updated>
    <published>2020-05-24T03:09:08Z</published>
    <title>miniKanren as a Tool for Symbolic Computation in Python</title>
    <summary>  In this article, we give a brief overview of the current state and future
potential of symbolic computation within the Python statistical modeling and
machine learning community. We detail the use of miniKanren as an underlying
framework for term rewriting and symbolic mathematics, as well as its ability
to orchestrate the use of existing Python libraries. We also discuss the
relevance and potential of relational programming for implementing more robust,
portable, domain-specific "math-level" optimizations--with a slight focus on
Bayesian modeling. Finally, we describe the work going forward and raise some
questions regarding potential cross-overs between statistical modeling and
programming language theory.
</summary>
    <author>
      <name>Brandon T. Willard</name>
    </author>
    <link href="http://arxiv.org/abs/2005.11644v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.11644v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.11710v4</id>
    <updated>2020-10-19T17:04:10Z</updated>
    <published>2020-05-24T10:31:39Z</published>
    <title>Featherweight Go</title>
    <summary>  We describe a design for generics in Go inspired by previous work on
Featherweight Java by Igarashi, Pierce, and Wadler. Whereas subtyping in Java
is nominal, in Go it is structural, and whereas generics in Java are defined
via erasure, in Go we use monomorphisation. Although monomorphisation is widely
used, we are one of the first to formalise it. Our design also supports a
solution to The Expression Problem.
</summary>
    <author>
      <name>Robert Griesemer</name>
    </author>
    <author>
      <name>Raymond Hu</name>
    </author>
    <author>
      <name>Wen Kokke</name>
    </author>
    <author>
      <name>Julien Lange</name>
    </author>
    <author>
      <name>Ian Lance Taylor</name>
    </author>
    <author>
      <name>Bernardo Toninho</name>
    </author>
    <author>
      <name>Philip Wadler</name>
    </author>
    <author>
      <name>Nobuko Yoshida</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Full version</arxiv:comment>
    <link href="http://arxiv.org/abs/2005.11710v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.11710v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2005.11839v1</id>
    <updated>2020-05-24T20:49:13Z</updated>
    <published>2020-05-24T20:49:13Z</published>
    <title>Tezla, an Intermediate Representation for Static Analysis of Michelson
  Smart Contracts</title>
    <summary>  This paper introduces Tezla, an intermediate representation of Michelson
smart contracts that eases the design of static smart contract analysers. This
intermediate representation uses a store and preserves the semantics, ow and
resource usage of the original smart contract. This enables properties like gas
consumption to be statically verified. We provide an automated decompiler of
Michelson smart contracts to Tezla. In order to support our claim about the
adequacy of Tezla, we develop a static analyser that takes advantage of the
Tezla representation of Michelson smart contracts to prove simple but
non-trivial properties.
</summary>
    <author>
      <name>João Santos Reis</name>
    </author>
    <author>
      <name>Paul Crocker</name>
    </author>
    <author>
      <name>Simão Melo de Sousa</name>
    </author>
    <link href="http://arxiv.org/abs/2005.11839v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2005.11839v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.02626v2</id>
    <updated>2023-01-26T21:00:29Z</updated>
    <published>2020-11-05T02:43:50Z</published>
    <title>HDPython: A High Level Python Based Object-Oriented HDL Framework</title>
    <summary>  We present a High-Level Python-based Hardware Description Language
(HDPython), It uses Python as its source language and converts it to standard
VHDL. Compared to other approaches of building converters from a high-level
programming language into a hardware description language, this new approach
aims to maintain an object-oriented paradigm throughout the entire process.
Instead of removing all the high-level features from Python to make it into an
HDL, this approach goes the opposite way. It tries to show how certain features
from a high-level language can be implemented in an HDL, providing the
corresponding benefits of high-level programming for the user.
</summary>
    <author>
      <name>R. Peschke</name>
    </author>
    <author>
      <name>K. Nishimura</name>
    </author>
    <author>
      <name>G. Varner</name>
    </author>
    <link href="http://arxiv.org/abs/2011.02626v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.02626v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.03536v1</id>
    <updated>2020-11-05T20:26:36Z</updated>
    <published>2020-11-05T20:26:36Z</published>
    <title>Fast XML/HTML for Haskell: XML TypeLift</title>
    <summary>  The paper presents and compares a range of parsers with and without data
mapping for conversion between XML and Haskell. The best performing parser
competes favorably with the fastest tools available in other languages and is,
thus, suitable for use in large-scale data analysis. The best performing parser
also allows software developers of intermediate-level Haskell programming
skills to start processing large numbers of XML documents soon after finding
the relevant XML Schema from a simple internet search, without the need for
specialist prior knowledge or skills. We hope that this unique combination of
parser performance and usability will provide a new standard for XML mapping to
high-level languages.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <author>
      <name>Dmitry Krylov</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5281/zenodo.3929549</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5281/zenodo.3929549" rel="related"/>
    <link href="http://arxiv.org/abs/2011.03536v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.03536v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.IR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.03537v2</id>
    <updated>2021-01-12T17:06:04Z</updated>
    <published>2020-11-05T20:31:13Z</published>
    <title>Less Arbitrary waiting time</title>
    <summary>  Property testing is the cheapest and most precise way of building up a test
suite for your program. Especially if the datatypes enjoy nice mathematical
laws. But it is also the easiest way to make it run for an unreasonably long
time. We prove connection between deeply recursive data structures, and
epidemic growth rate, and show how to fix the problem, and make Arbitrary
instances run in linear time with respect to assumed test size.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <link href="http://arxiv.org/abs/2011.03537v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.03537v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.03538v1</id>
    <updated>2020-11-05T20:38:57Z</updated>
    <published>2020-11-05T20:38:57Z</published>
    <title>Infer XPath</title>
    <summary>  We propose reformulation of discovery of data structure within a web page as
relations between sets of document nodes. We start by reformulating web page
analysis as finding expressions in extension of XPath. Then we propose to
automatically discover these XPath expressions with InferXPath meta-language.
Our goal is to automate laborious process of conversion of manually created web
pages that serve as software documentations, wikis, and reference documents,
and speed up their conversion into tabular data that can be directly fed into
data pipeline.
</summary>
    <author>
      <name>Michał J. Gajda</name>
    </author>
    <author>
      <name>Hai Nguyen Quang</name>
    </author>
    <author>
      <name>Do Ngoc Khanh</name>
    </author>
    <author>
      <name>Vuong Hai Thanh</name>
    </author>
    <link href="http://arxiv.org/abs/2011.03538v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.03538v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.06094v1</id>
    <updated>2020-11-11T22:04:34Z</updated>
    <published>2020-11-11T22:04:34Z</published>
    <title>Guiding user annotations for units-of-measure verification</title>
    <summary>  This extended abstract reports on previous work of the CamFort project in
which we developed an external units-of-measure type system for Fortran code,
targeted at scientists. Our approach can guide the programmer in adding
specifications (type annotations) to existing code, with the aim of easing
adoption on legacy code. Pertinent to the topics of the HATRA workshop, we
discuss the human-aspects of the tool here. CamFort is open-source and freely
available online.
</summary>
    <author>
      <name>Dominic Orchard</name>
    </author>
    <author>
      <name>Mistral Contrastin</name>
    </author>
    <author>
      <name>Matthew Danish</name>
    </author>
    <author>
      <name>Andrew Rice</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at HATRA 2020 (Workshop on Human Aspects of Types and
  Reasoning Assistants) colocated with SPLASH 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2011.06094v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.06094v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.07565v1</id>
    <updated>2020-11-15T15:58:46Z</updated>
    <published>2020-11-15T15:58:46Z</published>
    <title>User-Centered Programming Language Design: A Course-Based Case Study</title>
    <summary>  Recently, user-centered methods have been proposed to improve the design of
programming languages. In order to explore what benefits these methods might
have for novice programming language designers, we taught a collection of
user-centered programming language design methods to a group of eight students.
We observed that natural programming and usability studies helped the students
refine their language designs and identify opportunities for improvement, even
in the short duration of a course project.
</summary>
    <author>
      <name>Michael Coblenz</name>
    </author>
    <author>
      <name>Ariel Davis</name>
    </author>
    <author>
      <name>Megan Hofmann</name>
    </author>
    <author>
      <name>Vivian Huang</name>
    </author>
    <author>
      <name>Siyue Jin</name>
    </author>
    <author>
      <name>Max Krieger</name>
    </author>
    <author>
      <name>Kyle Liang</name>
    </author>
    <author>
      <name>Brian Wei</name>
    </author>
    <author>
      <name>Mengchen Sam Yong</name>
    </author>
    <author>
      <name>Jonathan Aldrich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages. Presented at HATRA 2020
  (https://2020.splashcon.org/home/hatra-2020)</arxiv:comment>
    <link href="http://arxiv.org/abs/2011.07565v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.07565v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2; D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2011.08881v1</id>
    <updated>2020-11-17T19:11:00Z</updated>
    <published>2020-11-17T19:11:00Z</published>
    <title>Learning functional programs with function invention and reuse</title>
    <summary>  Inductive programming (IP) is a field whose main goal is synthesising
programs that respect a set of examples, given some form of background
knowledge. This paper is concerned with a subfield of IP, inductive functional
programming (IFP). We explore the idea of generating modular functional
programs, and how those allow for function reuse, with the aim to reduce the
size of the programs. We introduce two algorithms that attempt to solve the
problem and explore type based pruning techniques in the context of modular
programs. By experimenting with the implementation of one of those algorithms,
we show reuse is important (if not crucial) for a variety of problems and
distinguished two broad classes of programs that will generally benefit from
function reuse.
</summary>
    <author>
      <name>Andrei Diaconu</name>
    </author>
    <link href="http://arxiv.org/abs/2011.08881v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2011.08881v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.00145v3</id>
    <updated>2022-04-15T09:34:34Z</updated>
    <published>2022-02-28T23:50:54Z</published>
    <title>Getting There and Back Again</title>
    <summary>  "There and Back Again" (TABA) is a programming pattern where the recursive
calls traverse one data structure and the subsequent returns traverse another.
This article presents new TABA examples, refines existing ones, and formalizes
both their control flow and their data flow using the Coq Proof Assistant. Each
formalization mechanizes a pen-and-paper proof, thus making it easier to "get"
TABA. In addition, this article identifies and illustrates a tail-recursive
variant of TABA, There and Forth Again (TAFA) that does not come back but goes
forth instead with more tail calls.
</summary>
    <author>
      <name>Olivier Danvy</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">69 pages (final version with complete acknowledgments)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Fundamenta Informaticae, Volume 185, Issue 2 (May 6, 2022) fi:9159</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2203.00145v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.00145v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.04422v1</id>
    <updated>2022-03-08T21:56:31Z</updated>
    <published>2022-03-08T21:56:31Z</published>
    <title>ProbTA: A sound and complete proof rule for probabilistic verification</title>
    <summary>  We propose a sound and complete proof rule ProbTA for quantitative analysis
of violation probability of probabilistic programs. Our approach extends the
technique of trace abstraction with probability in the control-flow randomness
style, in contrast to previous work of combining trace abstraction and
probabilisitic verification which adopts the data randomness style. In our
method, a program specification is proved or disproved by decomposing the
program into different modules of traces. Precise quantitative analysis is
enabled by novel models proposed to bridge program verification and probability
theory. Based on the proof rule, we propose a new automated algorithm via CEGAR
involving multiple technical issues unprecedented in non-probabilistic trace
abstraction and data randomness-based approach.
</summary>
    <author>
      <name>Guanyan Li</name>
    </author>
    <author>
      <name>Zhilei Han</name>
    </author>
    <author>
      <name>Fei He</name>
    </author>
    <link href="http://arxiv.org/abs/2203.04422v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.04422v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.07601v2</id>
    <updated>2022-12-09T04:59:17Z</updated>
    <published>2022-03-15T02:17:49Z</published>
    <title>Automatic HFL(Z) Validity Checking for Program Verification</title>
    <summary>  We propose an automated method for checking the validity of a formula of
HFL(Z), a higher-order logic with fixpoint operators and integers. Combined
with Kobayashi et al.'s reduction from higher-order program verification to
HFL(Z) validity checking, our method yields a fully automated, uniform
verification method for arbitrary temporal properties of higher-order
functional programs expressible in the modal mu-calculus, including
termination, non-termination, fair termination, fair non-termination, and also
branching-time properties. We have implemented our method and obtained
promising experimental results.
</summary>
    <author>
      <name>Naoki Kobayashi</name>
    </author>
    <author>
      <name>Kento Tanahashi</name>
    </author>
    <author>
      <name>Ryosuke Sato</name>
    </author>
    <author>
      <name>Takeshi Tsukada</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">A long version of the paper published in Proceedings of POPL 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2203.07601v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.07601v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.12142v1</id>
    <updated>2022-03-23T02:18:23Z</updated>
    <published>2022-03-23T02:18:23Z</published>
    <title>Proceedings of the 13th International Workshop on Programming Language
  Approaches to Concurrency and Communication-cEntric Software</title>
    <summary>  The increasingly concurrent and parallel landscape of hardware and software
infrastructures demands the exploration and understanding of a wide variety of
foundational and practical ideas. The International Workshop on Programming
Language Approaches to Concurrency and Communication-cEntric Software (PLACES)
is dedicated to work in this area. The workshop offers a forum for researchers
from different fields to exchange new ideas about these challenges to modern
and future programming, where concurrency and distribution are the norm rather
than a marginal concern. The topic is central and combines well with the main
conferences of ETAPS, in particular with ESOP.
</summary>
    <author>
      <name>Marco Carbone</name>
    </author>
    <author>
      <name>Rumyana Neykova</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.356</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.356" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 356, 2022</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2203.12142v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.12142v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2203.16211v1</id>
    <updated>2022-03-30T11:20:50Z</updated>
    <published>2022-03-30T11:20:50Z</published>
    <title>Lay-it-out: Interactive Design of Layout-Sensitive Grammars</title>
    <summary>  Layout-sensitive grammars have been adopted in many modern programming
languages. However, tool support for this kind of grammars still remains
limited and immature. In this paper, we present Lay-it-out, an interactive
framework for layout-sensitive grammar design. Beginning with a user-defined
ambiguous grammar, our framework refines it by synthesizing layout constraints
through user interaction. For ease of interaction, a shortest nonempty
ambiguous sentence (if exists) is automatically generated by our bounded
ambiguity checker via SMT solving. The soundness and completeness of our SMT
encoding are mechanized in the Coq proof assistant. Case studies on real
grammars, including a full grammar, demonstrate the practicality and
scalability of our approach.
</summary>
    <author>
      <name>Fengmin Zhu</name>
    </author>
    <author>
      <name>Jiangyi Liu</name>
    </author>
    <author>
      <name>Fei He</name>
    </author>
    <link href="http://arxiv.org/abs/2203.16211v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2203.16211v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.0757v3</id>
    <updated>2015-05-19T16:17:07Z</updated>
    <published>2014-09-02T15:29:23Z</published>
    <title>Approaches to Interpreter Composition</title>
    <summary>  In this paper, we compose six different Python and Prolog VMs into 4 pairwise
compositions: one using C interpreters; one running on the JVM; one using
meta-tracing interpreters; and one using a C interpreter and a meta-tracing
interpreter. We show that programs that cross the language barrier frequently
execute faster in a meta-tracing composition, and that meta-tracing imposes a
significantly lower overhead on composed programs relative to mono-language
programs.
</summary>
    <author>
      <name>Edd Barrett</name>
    </author>
    <author>
      <name>Carl Friedrich Bolz</name>
    </author>
    <author>
      <name>Laurence Tratt</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.cl.2015.03.001</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.cl.2015.03.001" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">33 pages, 1 figure, 9 tables</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Computer Languages, Systems and Structures (COMLAN). Volume 44C,
  December 2015, Pages 199-217</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1409.0757v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.0757v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.2089v1</id>
    <updated>2014-09-07T06:42:09Z</updated>
    <published>2014-09-07T06:42:09Z</published>
    <title>Perfrewrite -- Program Complexity Analysis via Source Code
  Instrumentation</title>
    <summary>  Most program profiling methods output the execution time of one specific
program execution, but not its computational complexity class in terms of the
big-O notation. Perfrewrite is a tool based on LLVM's Clang compiler to rewrite
a program such that it tracks semantic information while the program executes
and uses it to guess memory usage, communication and computational complexity.
While source code instrumentation is a standard technique for profiling, using
it for deriving formulas is an uncommon approach.
</summary>
    <author>
      <name>Michael Kruse</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LRI, INRIA Saclay - Ile de France</arxiv:affiliation>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ACACES 2012 summer school (2012)</arxiv:comment>
    <link href="http://arxiv.org/abs/1409.2089v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.2089v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.2764v1</id>
    <updated>2014-09-09T14:56:12Z</updated>
    <published>2014-09-09T14:56:12Z</published>
    <title>Innocent Strategies are Sheaves over Plays---Deterministic,
  Non-deterministic and Probabilistic Innocence</title>
    <summary>  Although the HO/N games are fully abstract for PCF, the traditional notion of
innocence (which underpins these games) is not satisfactory for such language
features as non-determinism and probabilistic branching, in that there are
stateless terms that are not innocent. Based on a category of P-visible plays
with a notion of embedding as morphisms, we propose a natural generalisation by
viewing innocent strategies as sheaves over (a site of) plays, echoing a slogan
of Hirschowitz and Pous. Our approach gives rise to fully complete game models
in each of the three cases of deterministic, nondeterministic and probabilistic
branching. To our knowledge, in the second and third cases, ours are the first
such factorisation-free constructions.
</summary>
    <author>
      <name>Takeshi Tsukada</name>
    </author>
    <author>
      <name>C. -H. Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/1409.2764v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.2764v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1409.7841v1</id>
    <updated>2014-09-27T21:05:38Z</updated>
    <published>2014-09-27T21:05:38Z</published>
    <title>Abstracting an operational semantics to finite automata</title>
    <summary>  There is an apparent similarity between the descriptions of small-step
operational semantics of imperative programs and the semantics of finite
automata, so defining an abstraction mapping from semantics to automata and
proving a simulation property seems to be easy. This paper aims at identifying
the reasons why simple proofs break, among them artifacts in the semantics that
lead to stuttering steps in the simulation. We then present a semantics based
on the zipper data structure, with a direct interpretation of evaluation as
navigation in the syntax tree. The abstraction function is then defined by
equivalence class construction.
</summary>
    <author>
      <name>Nadezhda Baklanova</name>
    </author>
    <author>
      <name>Wilmer Ricciotti</name>
    </author>
    <author>
      <name>Jan-Georg Smaus</name>
    </author>
    <author>
      <name>Martin Strecker</name>
    </author>
    <link href="http://arxiv.org/abs/1409.7841v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1409.7841v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.00925v1</id>
    <updated>2015-10-04T11:23:12Z</updated>
    <published>2015-10-04T11:23:12Z</published>
    <title>The Essence of JavaScript</title>
    <summary>  We reduce JavaScript to a core calculus structured as a small-step
operational semantics. We present several peculiarities of the language and
show that our calculus models them. We explicate the desugaring process that
turns JavaScript programs into ones in the core. We demonstrate faithfulness to
JavaScript using real-world test suites. Finally, we illustrate utility by
defining a security property, implementing it as a type system on the core, and
extending it to the full language.
</summary>
    <author>
      <name>Arjun Guha</name>
    </author>
    <author>
      <name>Claudiu Saftoiu</name>
    </author>
    <author>
      <name>Shriram Krishnamurthi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-642-14107-2_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-642-14107-2_7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">European Conference on Object-Oriented Programming (ECOOP) 2010</arxiv:comment>
    <link href="http://arxiv.org/abs/1510.00925v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.00925v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.01752v2</id>
    <updated>2015-12-20T15:33:51Z</updated>
    <published>2015-10-06T20:37:11Z</published>
    <title>Type Reconstruction for the Linear π-Calculus with Composite Regular
  Types</title>
    <summary>  We extend the linear {\pi}-calculus with composite regular types in such a
way that data containing linear values can be shared among several processes,
if there is no overlapping access to such values. We describe a type
reconstruction algorithm for the extended type system and discuss some
practical aspects of its implementation.
</summary>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universitá di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.2168/LMCS-11(4:13)2015</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.2168/LMCS-11(4:13)2015" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">45 pages</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Logical Methods in Computer Science, Volume 11, Issue 4 (December
  22, 2015) lmcs:1614</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1510.01752v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.01752v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1510.03929v4</id>
    <updated>2016-04-13T15:13:53Z</updated>
    <published>2015-10-13T23:35:13Z</published>
    <title>Type-Based Analysis for Session Inference</title>
    <summary>  We propose a type-based analysis to infer the session protocols of channels
in an ML-like concurrent functional language. Combining and extending
well-known techniques, we develop a type-checking system that separates the
underlying ML type system from the typing of sessions. Without using linearity,
our system guarantees communication safety and partial lock freedom. It also
supports provably complete session inference for finite sessions with no
programmer annotations. We exhibit the usefulness of our system with
interesting examples, including one which is not typable in substructural type
systems.
</summary>
    <author>
      <name>Carlo Spaccasassi</name>
    </author>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <link href="http://arxiv.org/abs/1510.03929v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1510.03929v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.02281v1</id>
    <updated>2017-02-08T04:29:39Z</updated>
    <published>2017-02-08T04:29:39Z</published>
    <title>GADTs and Exhaustiveness: Looking for the Impossible</title>
    <summary>  Sound exhaustiveness checking of pattern-matching is an essential feature of
functional programming languages, and OCaml supports it for GADTs. However this
check is incomplete, in that it may fail to detect that a pattern can match no
concrete value. In this paper we show that this problem is actually
undecidable, but that we can strengthen the exhaustiveness and redundancy
checks so that they cover more practical cases. The new algorithm relies on a
clever modification of type inference for patterns.
</summary>
    <author>
      <name>Jacques Garrigue</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Nagoya University Graduate School of Mathematics</arxiv:affiliation>
    </author>
    <author>
      <name>Jacques Le Normand</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.241.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.241.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML/OCaml 2015, arXiv:1702.01872</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 241, 2017, pp. 23-35</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1702.02281v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.02281v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.04908v2</id>
    <updated>2017-04-19T13:26:43Z</updated>
    <published>2017-02-16T10:12:00Z</published>
    <title>A monad for full ground reference cells</title>
    <summary>  We present a denotational account of dynamic allocation of potentially cyclic
memory cells using a monad on a functor category. We identify the collection of
heaps as an object in a different functor category equipped with a monad for
adding hiding/encapsulation capabilities to the heaps. We derive a monad for
full ground references supporting effect masking by applying a state monad
transformer to the encapsulation monad. To evaluate the monad, we present a
denotational semantics for a call-by-value calculus with full ground
references, and validate associated code transformations.
</summary>
    <author>
      <name>Ohad Kammar</name>
    </author>
    <author>
      <name>Paul B. Levy</name>
    </author>
    <author>
      <name>Sean K. Moss</name>
    </author>
    <author>
      <name>Sam Staton</name>
    </author>
    <link href="http://arxiv.org/abs/1702.04908v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.04908v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.05437v2</id>
    <updated>2017-03-07T03:21:07Z</updated>
    <published>2017-02-17T17:02:29Z</published>
    <title>Quantifying Program Bias</title>
    <summary>  With the range and sensitivity of algorithmic decisions expanding at a
break-neck speed, it is imperative that we aggressively investigate whether
programs are biased. We propose a novel probabilistic program analysis
technique and apply it to quantifying bias in decision-making programs.
Specifically, we (i) present a sound and complete automated verification
technique for proving quantitative properties of probabilistic programs; (ii)
show that certain notions of bias, recently proposed in the fairness
literature, can be phrased as quantitative correctness properties; and (iii)
present FairSquare, the first verification tool for quantifying program bias,
and evaluate it on a range of decision-making programs.
</summary>
    <author>
      <name>Aws Albarghouthi</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <author>
      <name>Samuel Drews</name>
    </author>
    <author>
      <name>Aditya Nori</name>
    </author>
    <link href="http://arxiv.org/abs/1702.05437v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.05437v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.05463v1</id>
    <updated>2017-02-17T18:08:43Z</updated>
    <published>2017-02-17T18:08:43Z</published>
    <title>A Performance Analysis of Simple Runtime System for Actor Programming in
  C++</title>
    <summary>  In this paper, we propose the Templet -- a runtime system for actor
programming of high performance computing in C++. We provide a compact source
code of the runtime system, which uses standard library of C++11 only. We
demonstrate how it differs from the classic implementations of the actor model.
The practical significance of the Templet was examined by comparative study on
the performance of three applications: the reference code in C++, managed by
the OpenMP; the actor code in C++, managed by the Templet; the actor code in
Java, managed by the Akka. As a test problem we used a numerical algorithm for
solving the heat equation.
</summary>
    <author>
      <name>Sergey Vostokin</name>
    </author>
    <author>
      <name>Ekaterina Skoryupina</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1702.05463v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.05463v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1702.07753v1</id>
    <updated>2017-02-24T20:45:52Z</updated>
    <published>2017-02-24T20:45:52Z</published>
    <title>Practical Magick with C, PDL, and PDL::PP -- a guide to compiled add-ons
  for PDL</title>
    <summary>  This guide is intended to knit together, and extend, the existing PP and C
documentation on PDL internals. It draws heavily from prior work by the authors
of the code. Special thanks go to Christian Soeller, and Tuomas Lukka, who
together with Glazebrook conceived and implemented PDL and PP; and to Chris
Marshall, who has led the PDL development team through several groundbreaking
releases and to new levels of usability.
</summary>
    <author>
      <name>C. E. DeForest</name>
    </author>
    <author>
      <name>K. Glazebrook</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">42 pages, 1 figure, overview of the PDL::PP description language for
  vectorized calculation</arxiv:comment>
    <link href="http://arxiv.org/abs/1702.07753v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1702.07753v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.02051v1</id>
    <updated>2019-05-06T13:56:46Z</updated>
    <published>2019-05-06T13:56:46Z</published>
    <title>Language-integrated provenance by trace analysis</title>
    <summary>  Language-integrated provenance builds on language-integrated query techniques
to make provenance information explaining query results readily available to
programmers. In previous work we have explored language-integrated approaches
to provenance in Links and Haskell. However, implementing a new form of
provenance in a language-integrated way is still a major challenge. We propose
a self-tracing transformation and trace analysis features that, together with
existing techniques for type-directed generic programming, make it possible to
define different forms of provenance as user code. We present our design as an
extension to a core language for Links called LinksT, give examples showing its
capabilities, and outline its metatheory and key correctness properties.
</summary>
    <author>
      <name>Stefan Fehrenbach</name>
    </author>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3315507.3330198</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3315507.3330198" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">DBPL 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1905.02051v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.02051v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.06543v1</id>
    <updated>2019-05-16T06:11:17Z</updated>
    <published>2019-05-16T06:11:17Z</published>
    <title>Extending OCaml's 'open'</title>
    <summary>  We propose a harmonious extension of OCaml's 'open' construct.
  OCaml's existing construct 'open M' imports the names exported by the module
'M' into the current scope. At present 'M' is required to be the path to a
module. We propose extending 'open' to instead accept an arbitrary module
expression, making it possible to succinctly address a number of existing
scope-related difficulties that arise when writing OCaml programs.
</summary>
    <author>
      <name>Runhang Li</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Twitter, Inc</arxiv:affiliation>
    </author>
    <author>
      <name>Jeremy Yallop</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.294.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.294.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML 2017, arXiv:1905.05909</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 294, 2019, pp. 1-14</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1905.06543v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.06543v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2, D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.06546v1</id>
    <updated>2019-05-16T06:12:14Z</updated>
    <published>2019-05-16T06:12:14Z</published>
    <title>First-Class Subtypes</title>
    <summary>  First class type equalities, in the form of generalized algebraic data types
(GADTs), are commonly found in functional programs. However, first-class
representations of other relations between types, such as subtyping, are not
yet directly supported in most functional programming languages.
  We present several encodings of first-class subtypes using existing features
of the OCaml language (made more convenient by the proposed modular implicits
extension), show that any such encodings are interconvertible, and illustrate
the utility of the encodings with several examples.
</summary>
    <author>
      <name>Jeremy Yallop</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <author>
      <name>Stephen Dolan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Cambridge</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.294.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.294.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ML 2017, arXiv:1905.05909</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 294, 2019, pp. 74-85</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1905.06546v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.06546v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.07639v2</id>
    <updated>2019-08-02T21:19:47Z</updated>
    <published>2019-05-18T20:14:10Z</published>
    <title>Developing secure Bitcoin contracts with BitML</title>
    <summary>  We present a toolchain for developing and verifying smart contracts that can
be executed on Bitcoin. The toolchain is based on BitML, a recent
domain-specific language for smart contracts with a computationally sound
embedding into Bitcoin. Our toolchain automatically verifies relevant
properties of contracts, among which liquidity, ensuring that funds do not
remain frozen within a contract forever. A compiler is provided to translate
BitML contracts into sets of standard Bitcoin transactions: executing a
contract corresponds to appending these transactions to the blockchain. We
assess our toolchain through a benchmark of representative contracts.
</summary>
    <author>
      <name>Nicola Atzei</name>
    </author>
    <author>
      <name>Massimo Bartoletti</name>
    </author>
    <author>
      <name>Stefano Lande</name>
    </author>
    <author>
      <name>Nobuko Yoshida</name>
    </author>
    <author>
      <name>Roberto Zunino</name>
    </author>
    <link href="http://arxiv.org/abs/1905.07639v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.07639v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.08364v1</id>
    <updated>2019-05-20T22:10:47Z</updated>
    <published>2019-05-20T22:10:47Z</published>
    <title>Efficient Synthesis with Probabilistic Constraints</title>
    <summary>  We consider the problem of synthesizing a program given a probabilistic
specification of its desired behavior. Specifically, we study the recent
paradigm of distribution-guided inductive synthesis (DIGITS), which iteratively
calls a synthesizer on finite sample sets from a given distribution. We make
theoretical and algorithmic contributions: (i) We prove the surprising result
that DIGITS only requires a polynomial number of synthesizer calls in the size
of the sample set, despite its ostensibly exponential behavior. (ii) We present
a property-directed version of DIGITS that further reduces the number of
synthesizer calls, drastically improving synthesis performance on a range of
benchmarks.
</summary>
    <author>
      <name>Samuel Drews</name>
    </author>
    <author>
      <name>Aws Albarghouthi</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <link href="http://arxiv.org/abs/1905.08364v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.08364v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.09242v1</id>
    <updated>2019-05-22T17:01:28Z</updated>
    <published>2019-05-22T17:01:28Z</published>
    <title>Reductions for Automated Hypersafety Verification</title>
    <summary>  We propose an automated verification technique for hypersafety properties,
which express sets of valid interrelations between multiple finite runs of a
program. The key observation is that constructing a proof for a small
representative set of the runs of the product program (i.e. the product of the
several copies of the program by itself), called a reduction, is sufficient to
formally prove the hypersafety property about the program. We propose an
algorithm based on a counterexample-guided refinement loop that simultaneously
searches for a reduction and a proof of the correctness for the reduction. We
demonstrate that our tool Weaver is very effective in verifying a diverse array
of hypersafety properties for a diverse class of input programs.
</summary>
    <author>
      <name>Azadeh Farzan</name>
    </author>
    <author>
      <name>Anthony Vandikas</name>
    </author>
    <link href="http://arxiv.org/abs/1905.09242v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.09242v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1905.13706v1</id>
    <updated>2019-05-31T16:35:23Z</updated>
    <published>2019-05-31T16:35:23Z</published>
    <title>A Role for Dependent Types in Haskell (Extended version)</title>
    <summary>  Modern Haskell supports zero-cost coercions, a mechanism where types that
share the same run-time representation may be freely converted between. To make
sure such conversions are safe and desirable, this feature relies on a
mechanism of roles to prohibit invalid coercions. In this work, we show how to
integrate roles with dependent type systems and prove, using the Coq proof
assistant, that the resulting system is sound. We have designed this work as a
foundation for the addition of dependent types to the Glasgow Haskell Compiler,
but we also expect that it will be of use to designers of other
dependently-typed languages who might want to adopt Haskell's safe coercions
feature.
</summary>
    <author>
      <name>Stephanie Weirich</name>
    </author>
    <author>
      <name>Pritam Choudhury</name>
    </author>
    <author>
      <name>Antoine Voizard</name>
    </author>
    <author>
      <name>Richard A. Eisenberg</name>
    </author>
    <link href="http://arxiv.org/abs/1905.13706v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1905.13706v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.01324v1</id>
    <updated>2019-08-04T12:18:50Z</updated>
    <published>2019-08-04T12:18:50Z</published>
    <title>CREST: Hardware Formal Verification with ANSI-C Reference Specifications</title>
    <summary>  This paper presents CREST, a prototype front-end tool intended as an add-on
to commercial EDA formal verifcation environments. CREST is an adaptation of
the CBMC bounded model checker for C, an academic tool widely used in industry
for software analysis and property verification. It leverages the capabilities
of CBMC to process hardware datapath specifications written in arbitrary
ANSI-C, without limiting restrictions to a synthesizable subset. We briefly
sketch the architecture of our tool and show its use in a range of verification
case studies.
</summary>
    <author>
      <name>Andreas Tiemeyer</name>
    </author>
    <author>
      <name>Tom Melham</name>
    </author>
    <author>
      <name>Daniel Kroening</name>
    </author>
    <author>
      <name>John O'Leary</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1908.01324v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.01324v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.02940v1</id>
    <updated>2019-08-08T05:52:36Z</updated>
    <published>2019-08-08T05:52:36Z</published>
    <title>Intrinsically-Typed Mechanized Semantics for Session Types</title>
    <summary>  Session types have emerged as a powerful paradigm for structuring
communication-based programs. They guarantee type soundness and session
fidelity for concurrent programs with sophisticated communication protocols. As
type soundness proofs for languages with session types are tedious and
technically involved, it is rare to see mechanized soundness proofs for these
systems.
  We present an executable intrinsically typed small-step semantics for a
realistic functional session type calculus. The calculus includes linearity,
recursion, and recursive sessions with subtyping. Asynchronous communication is
modeled with an encoding.
  The semantics is implemented in Agda as an intrinsically typed, interruptible
CEK machine. This implementation proves type preservation and a particular
notion of progress by construction.
</summary>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appears in PPDP 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1908.02940v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.02940v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.05839v2</id>
    <updated>2020-11-14T18:26:29Z</updated>
    <published>2019-08-16T04:22:23Z</published>
    <title>Bidirectional Typing</title>
    <summary>  Bidirectional typing combines two modes of typing: type checking, which
checks that a program satisfies a known type, and type synthesis, which
determines a type from the program. Using checking enables bidirectional typing
to support features for which inference is undecidable; using synthesis enables
bidirectional typing to avoid the large annotation burden of explicitly typed
languages. In addition, bidirectional typing improves error locality. We
highlight the design principles that underlie bidirectional type systems,
survey the development of bidirectional typing from the prehistoric period
before Pierce and Turner's local type inference to the present day, and provide
guidance for future investigations.
</summary>
    <author>
      <name>Jana Dunfield</name>
    </author>
    <author>
      <name>Neel Krishnaswami</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3450952</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3450952" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">37 pages; submitted to ACM Computing Surveys</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">ACM Computing Surveys 54(5) (2021)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1908.05839v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.05839v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.05845v1</id>
    <updated>2019-08-16T04:50:29Z</updated>
    <published>2019-08-16T04:50:29Z</published>
    <title>Memory-Efficient Object-Oriented Programming on GPUs</title>
    <summary>  Object-oriented programming is often regarded as too inefficient for
high-performance computing (HPC), despite the fact that many important HPC
problems have an inherent object structure. Our goal is to bring efficient,
object-oriented programming to massively parallel SIMD architectures,
especially GPUs.
  In this thesis, we develop various techniques for optimizing object-oriented
GPU code. Most notably, we identify the object-oriented Single-Method
Multiple-Objects (SMMO) programming model. We first develop an embedded C++
Structure of Arrays (SOA) data layout DSL for SMMO applications. We then design
a lock-free, dynamic memory allocator that stores allocations in SOA layout.
Finally, we show how to further optimize the memory access of SMMO applications
with memory defragmentation.
</summary>
    <author>
      <name>Matthias Springer</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Ph.D. Thesis</arxiv:comment>
    <link href="http://arxiv.org/abs/1908.05845v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.05845v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.4; D.1.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.06478v1</id>
    <updated>2019-08-14T01:57:59Z</updated>
    <published>2019-08-14T01:57:59Z</published>
    <title>Type-Based Resource Analysis on Haskell</title>
    <summary>  We propose an amortized analysis that approximates the resource usage of a
Haskell expression. Using the plugin API of GHC, we convert the Haskell code
into a simplified representation called GHC Core. We then apply a type-based
system which derives linear upper bounds on the resource usage. This setup
allows us to analyze actual Haskell code, whereas previous implementations of
similar analyses do not support any commonly used lazy functional programming
languages.
</summary>
    <author>
      <name>Franz Siglmüller</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Ludwig Maximilian University of Munich</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.298.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.298.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings DICE-FOPARA 2019, arXiv:1908.04478</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 298, 2019, pp. 47-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1908.06478v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.06478v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.10926v1</id>
    <updated>2019-08-28T19:48:10Z</updated>
    <published>2019-08-28T19:48:10Z</published>
    <title>Performance Analysis of Zippers</title>
    <summary>  A zipper is a powerful technique of representing a purely functional data
structure in a way that allows fast access to a specific element. It is often
used in cases where the imperative data structures would use a mutable pointer.
However, the efficiency of zippers as a replacement for mutable pointers is not
sufficiently explored. We attempt to address this issue by comparing the
performance of zippers and mutable pointers in two common scenarios and three
different languages: C++, C#, and Haskell.
</summary>
    <author>
      <name>Vít Šefl</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of DECLARE 19 proceedings, 15 pages, 9 listings, 6 figures,
  source files available at https://github.com/vituscze/performance-zippers</arxiv:comment>
    <link href="http://arxiv.org/abs/1908.10926v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.10926v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1908.11101v1</id>
    <updated>2019-08-29T08:47:52Z</updated>
    <published>2019-08-29T08:47:52Z</published>
    <title>ICurry</title>
    <summary>  FlatCurry is a well-established intermediate representation of Curry programs
used in compilers that translate Curry code into Prolog and Haskell code. Some
FlatCurry constructs have no direct translation into imperative code. These
constructs must be each handled differently when translating Curry code into C,
C++ and Python code. We introduce a new representation of Curry programs,
called ICurry, and derive a translation from all FlatCurry constructs into
ICurry. We present the syntax of ICurry and the translation from FlatCurry to
ICurry. We present a model of functional logic computations as graph rewriting,
show how this model can be implemented in a low-level imperative language, and
describe the translation from ICurry to this model.
</summary>
    <author>
      <name>Sergio Antoy</name>
    </author>
    <author>
      <name>Michael Hanus</name>
    </author>
    <author>
      <name>Andy Jost</name>
    </author>
    <author>
      <name>Steven Libby</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of DECLARE 19 proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/1908.11101v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1908.11101v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.01842v1</id>
    <updated>2020-02-05T16:06:40Z</updated>
    <published>2020-02-05T16:06:40Z</published>
    <title>Patterns for Name Analysis and Type Analysis with JastAdd</title>
    <summary>  In the last two decades, tools have been implemented to more formally specify
the semantic analysis phase of a compiler instead of relying on handwritten
code. In this paper, we introduce patterns and a method to translate a formal
definition of a language's type system into a specification for JastAdd, which
is one of the aforementioned tools based on Reference Attribute Grammars. This
methodological approach will help language designers and compiler engineers to
more systematically use such tools for semantic analysis. As an example, we use
a simple, yet complete imperative language and provide an outlook on how the
method can be extended to cover further language constructs or even type
inference.
</summary>
    <author>
      <name>Uwe Meyer</name>
    </author>
    <author>
      <name>Björn Pfarr</name>
    </author>
    <link href="http://arxiv.org/abs/2002.01842v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.01842v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.01960v3</id>
    <updated>2020-05-10T19:51:23Z</updated>
    <published>2020-02-05T19:14:31Z</published>
    <title>A Domain Semantics for Higher-Order Recursive Processes</title>
    <summary>  The polarized SILL programming language uniformly integrates functional
programming and session-typed message-passing concurrency. It supports general
recursion, asynchronous and synchronous communication, and higher-order
programs that communicate channels and processes. We give polarized SILL a
domain-theoretic semantics---the first denotational semantics for a language
with this combination of features. Session types in polarized SILL denote pairs
of domains of unidirectional communications. Processes denote continuous
functions between these domains, and process composition is interpreted by a
trace operator. We illustrate our semantics by validating expected program
equivalences.
</summary>
    <author>
      <name>Ryan Kavanagh</name>
    </author>
    <link href="http://arxiv.org/abs/2002.01960v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.01960v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.02171v1</id>
    <updated>2020-02-06T09:39:43Z</updated>
    <published>2020-02-06T09:39:43Z</published>
    <title>PaSe: An Extensible and Inspectable DSL for Micro-Animations</title>
    <summary>  This paper presents PaSe, an extensible and inspectable DSL embedded in
Haskell for expressing micro-animations. The philosophy of PaSe is to compose
animations based on sequential and parallel composition of smaller animations.
This differs from other animation libraries that focus more on sequential
composition and have only limited forms of parallel composition. To provide
similar flexibility as other animation libraries, PaSe features extensibility
of operations and inspectability of animations. We present the features of PaSe
with a to-do list application, discuss the PaSe implementation, and argue that
the callback style of extensibility is detrimental for correctly combining PaSe
features. We contrast with the GreenSock Animation Platform, a
professional-grade and widely used JavaScript animation library, to illustrate
this point.
</summary>
    <author>
      <name>Ruben P. Pieters</name>
    </author>
    <author>
      <name>Tom Schrijvers</name>
    </author>
    <link href="http://arxiv.org/abs/2002.02171v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.02171v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.06178v1</id>
    <updated>2020-02-14T18:56:12Z</updated>
    <published>2020-02-14T18:56:12Z</published>
    <title>Programming Paradigms, Turing Completeness and Computational Thinking</title>
    <summary>  The notion of programming paradigms, with associated programming languages
and methodologies, is a well established tenet of Computer Science pedagogy,
enshrined in international curricula. However, this notion sits ill with Kuhn's
classic conceptualisation of a scientific paradigm as a dominant world view,
which supersedes its predecessors through superior explanatory power.
Furthermore, it is not at all clear how programming paradigms are to be
characterised and differentiated. Indeed, on closer inspection, apparently
disparate programming paradigms are very strongly connected. Rather, they
should be viewed as different traditions of a unitary Computer Science paradigm
of Turing complete computation complemented by Computational Thinking.
</summary>
    <author>
      <name>Greg Michaelson</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Heriot-Watt University, United Kingdom</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.22152/programming-journal.org/2020/4/4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.22152/programming-journal.org/2020/4/4" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">The Art, Science, and Engineering of Programming, 2020, Vol. 4,
  Issue 3, Article 4</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2002.06178v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.06178v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.08241v1</id>
    <updated>2020-02-19T15:38:03Z</updated>
    <published>2020-02-19T15:38:03Z</published>
    <title>A Differential-form Pullback Programming Language for Higher-order
  Reverse-mode Automatic Differentiation</title>
    <summary>  Building on the observation that reverse-mode automatic differentiation (AD)
-- a generalisation of backpropagation -- can naturally be expressed as
pullbacks of differential 1-forms, we design a simple higher-order programming
language with a first-class differential operator, and present a reduction
strategy which exactly simulates reverse-mode AD. We justify our reduction
strategy by interpreting our language in any differential $\lambda$-category
that satisfies the Hahn-Banach Separation Theorem, and show that the reduction
strategy precisely captures reverse-mode AD in a truly higher-order setting.
</summary>
    <author>
      <name>Carol Mak</name>
    </author>
    <author>
      <name>Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/2002.08241v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.08241v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.09002v2</id>
    <updated>2020-06-11T06:31:16Z</updated>
    <published>2020-02-20T20:28:08Z</published>
    <title>RustHorn: CHC-based Verification for Rust Programs (full version)</title>
    <summary>  Reduction to the satisfiability problem for constrained Horn clauses (CHCs)
is a widely studied approach to automated program verification. The current
CHC-based methods for pointer-manipulating programs, however, are not very
scalable. This paper proposes a novel translation of pointer-manipulating Rust
programs into CHCs, which clears away pointers and memories by leveraging
ownership. We formalize the translation for a simplified core of Rust and prove
its correctness. We have implemented a prototype verifier for a subset of Rust
and confirmed the effectiveness of our method.
</summary>
    <author>
      <name>Yusuke Matsushita</name>
    </author>
    <author>
      <name>Takeshi Tsukada</name>
    </author>
    <author>
      <name>Naoki Kobayashi</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-44914-8_18</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-44914-8_18" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Full version of the same-titled paper in ESOP2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2002.09002v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.09002v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.09115v1</id>
    <updated>2020-02-21T03:53:15Z</updated>
    <published>2020-02-21T03:53:15Z</published>
    <title>Symbolic Execution Game Semantics</title>
    <summary>  We present a framework for symbolically executing and model checking
higher-order programs with external (open) methods. We focus on the
client-library paradigm and in particular we aim to check libraries with
respect to any definable client. We combine traditional symbolic execution
techniques with operational game semantics to build a symbolic execution
semantics that captures arbitrary external behaviour. We prove the symbolic
semantics to be sound and complete. This yields a bounded technique by imposing
bounds on the depth of recursion and callbacks. We provide an implementation of
our technique in the K framework and showcase its performance on a custom
benchmark based on higher-order coding errors such as reentrancy bugs.
</summary>
    <author>
      <name>Yu-Yang Lin</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">41 pages, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2002.09115v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.09115v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2002.10213v2</id>
    <updated>2022-11-23T13:43:05Z</updated>
    <published>2020-02-24T12:58:25Z</published>
    <title>Superoptimization of WebAssembly Bytecode</title>
    <summary>  Motivated by the fast adoption of WebAssembly, we propose the first
functional pipeline to support the superoptimization of WebAssembly bytecode.
Our pipeline works over LLVM and Souper. We evaluate our superoptimization
pipeline with 12 programs from the Rosetta code project. Our pipeline improves
the code section size of 8 out of 12 programs. We discuss the challenges faced
in superoptimization of WebAssembly with two case studies.
</summary>
    <author>
      <name>Javier Cabrera-Arteaga</name>
    </author>
    <author>
      <name>Shrinish Donde</name>
    </author>
    <author>
      <name>Jian Gu</name>
    </author>
    <author>
      <name>Orestis Floros</name>
    </author>
    <author>
      <name>Lucas Satabin</name>
    </author>
    <author>
      <name>Benoit Baudry</name>
    </author>
    <author>
      <name>Martin Monperrus</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3397537.3397567</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3397537.3397567" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages, 3 figures. Proceedings of MoreVMs: Workshop on Modern
  Language Runtimes, Ecosystems, and VMs (2020)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of MoreVMs: Workshop on Modern Language Runtimes,
  Ecosystems, and VMs (2020)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2002.10213v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2002.10213v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.04633v2</id>
    <updated>2024-11-02T10:46:42Z</updated>
    <published>2020-10-09T15:25:33Z</published>
    <title>C for a tiny system</title>
    <summary>  We have implemented support for Padauk microcontrollers, tiny 8-Bit devices
with 60 B to 256 B of RAM, in the Small Device C Compiler (SDCC), showing that
the use of (mostly) standard C to program such minimal devices is feasible. We
report on our experience and on the difficulties in supporting the hardware
multithreading present on some of these devices. To make the devices a better
target for C, we propose various enhancements of the architecture, and
empirically evaluated their impact on code size.
</summary>
    <author>
      <name>Philipp Klaus Krause</name>
    </author>
    <author>
      <name>Nicolas Lesser</name>
    </author>
    <link href="http://arxiv.org/abs/2010.04633v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.04633v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; C.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.04800v2</id>
    <updated>2020-11-23T16:10:08Z</updated>
    <published>2020-10-09T20:47:29Z</published>
    <title>Psamathe: A DSL with Flows for Safe Blockchain Assets</title>
    <summary>  Blockchains host smart contracts for crowdfunding, tokens, and many other
purposes. Vulnerabilities in contracts are often discovered, leading to the
loss of large quantities of money. Psamathe is a new language we are designing
around a new flow abstraction, reducing asset bugs and making contracts more
concise than in existing languages. We present an overview of Psamathe,
including a partial formalization. We also discuss several example contracts in
Psamathe, and compare the Psamathe examples to the same contracts written in
Solidity.
</summary>
    <author>
      <name>Reed Oei</name>
    </author>
    <author>
      <name>Michael Coblenz</name>
    </author>
    <author>
      <name>Jonathan Aldrich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Working draft</arxiv:comment>
    <link href="http://arxiv.org/abs/2010.04800v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.04800v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.07763v1</id>
    <updated>2020-10-15T14:05:27Z</updated>
    <published>2020-10-15T14:05:27Z</published>
    <title>Refinement Types: A Tutorial</title>
    <summary>  Refinement types enrich a language's type system with logical predicates that
circumscribe the set of values described by the type, thereby providing
software developers a tunable knob with which to inform the type system about
what invariants and correctness properties should be checked on their code. In
this article, we distill the ideas developed in the substantial literature on
refinement types into a unified tutorial that explains the key ingredients of
modern refinement type systems. In particular, we show how to implement a
refinement type checker via a progression of languages that incrementally add
features to the language or type system.
</summary>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <author>
      <name>Niki Vazou</name>
    </author>
    <link href="http://arxiv.org/abs/2010.07763v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.07763v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.08439v1</id>
    <updated>2020-10-16T15:12:13Z</updated>
    <published>2020-10-16T15:12:13Z</published>
    <title>Really Embedding Domain-Specific Languages into C++</title>
    <summary>  Domain-specific languages (DSLs) are both pervasive and powerful, but remain
difficult to integrate into large projects. As a result, while DSLs can bring
distinct advantages in performance, reliability, and maintainability, their use
often involves trading off other good software-engineering practices. In this
paper, we describe an extension to the Clang C++ compiler to support syntax
plugins, and we demonstrate how this mechanism allows making use of DSLs inside
of a C++ code base without needing to separate the DSL source code from the
surrounding C++ code.
</summary>
    <author>
      <name>Hal Finkel</name>
    </author>
    <author>
      <name>Alexander McCaskey</name>
    </author>
    <author>
      <name>Tobi Popoola</name>
    </author>
    <author>
      <name>Dmitry Lyakh</name>
    </author>
    <author>
      <name>Johannes Doerfert</name>
    </author>
    <link href="http://arxiv.org/abs/2010.08439v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.08439v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.10503v1</id>
    <updated>2020-10-20T17:55:36Z</updated>
    <published>2020-10-20T17:55:36Z</published>
    <title>Evaluation of Logic Programs with Built-Ins and Aggregation: A Calculus
  for Bag Relations</title>
    <summary>  We present a scheme for translating logic programs, which may use aggregation
and arithmetic, into algebraic expressions that denote bag relations over
ground terms of the Herbrand universe. To evaluate queries against these
relations, we develop an operational semantics based on term rewriting of the
algebraic expressions. This approach can exploit arithmetic identities and
recovers a range of useful strategies, including lazy strategies that defer
work until it becomes possible or necessary.
</summary>
    <author>
      <name>Matthew Francis-Landau</name>
    </author>
    <author>
      <name>Tim Vieira</name>
    </author>
    <author>
      <name>Jason Eisner</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">An earlier version of this paper appeared at WRLA 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2010.10503v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.10503v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.12071v1</id>
    <updated>2020-10-22T21:17:04Z</updated>
    <published>2020-10-22T21:17:04Z</published>
    <title>Translating Recursive Probabilistic Programs to Factor Graph Grammars</title>
    <summary>  It is natural for probabilistic programs to use conditionals to express
alternative substructures in models, and loops (recursion) to express repeated
substructures in models. Thus, probabilistic programs with conditionals and
recursion motivate ongoing interest in efficient and general inference. A
factor graph grammar (FGG) generates a set of factor graphs that do not all
need to be enumerated in order to perform inference. We provide a
semantics-preserving translation from first-order probabilistic programs with
conditionals and recursion to FGGs.
</summary>
    <author>
      <name>David Chiang</name>
    </author>
    <author>
      <name>Chung-chieh Shan</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract of presentation at PROBPROG 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2010.12071v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.12071v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.12695v1</id>
    <updated>2020-10-23T22:42:54Z</updated>
    <published>2020-10-23T22:42:54Z</published>
    <title>Adding Interactive Visual Syntax to Textual Code</title>
    <summary>  Many programming problems call for turning geometrical thoughts into code:
tables, hierarchical structures, nests of objects, trees, forests, graphs, and
so on. Linear text does not do justice to such thoughts. But, it has been the
dominant programming medium for the past and will remain so for the foreseeable
future.
  This paper proposes a novel mechanism for conveniently extending textual
programming languages with problem-specific visual syntax. It argues the
necessity of this language feature, demonstrates the feasibility with a robust
prototype, and sketches a design plan for adapting the idea to other languages.
</summary>
    <author>
      <name>Leif Andersen</name>
    </author>
    <author>
      <name>Michael Ballantyne</name>
    </author>
    <author>
      <name>Matthias Felleisen</name>
    </author>
    <link href="http://arxiv.org/abs/2010.12695v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.12695v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2010.14133v1</id>
    <updated>2020-10-27T08:49:19Z</updated>
    <published>2020-10-27T08:49:19Z</published>
    <title>Extended abstract: Type oriented programming for task based parallelism</title>
    <summary>  Writing parallel codes is difficult and exhibits a fundamental trade-off
between abstraction and performance. The high level language abstractions
designed to simplify the complexities of parallelism make certain assumptions
that impacts performance and scalability. On the other hand lower level
languages, providing many opportunities for optimisation, require in-depth
knowledge and the programmer to consider tricky details of parallelism. An
approach is required which can bridge the gap and provide both the ease of
programming and opportunities for control and optimisation. By optionally
decorating their codes with additional type information, programmers can either
direct the compiler to make certain decisions or rely on sensible default
choices.
</summary>
    <author>
      <name>Nick Brown</name>
    </author>
    <author>
      <name>Ludovic Capelli</name>
    </author>
    <author>
      <name>J. Mark Bull</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended abstract in 2017 workshop on Type-Driven Development</arxiv:comment>
    <link href="http://arxiv.org/abs/2010.14133v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2010.14133v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2104.03678v1</id>
    <updated>2021-04-08T10:46:28Z</updated>
    <published>2021-04-08T10:46:28Z</published>
    <title>A Proposal for an Interactive Shell Based on a Typed Lambda Calculus</title>
    <summary>  This paper presents Favalon, a functional programming language built on the
premise of a lambda calculus for use as an interactive shell replacement.
Favalon seamlessly integrates with typed versions of existing libraries and
commands using type inference, flexible runtime type metadata, and the same
techniques employed by shells to link commands together. Much of Favalon's
syntax is customizable via user-defined functions, allowing it to be extended
by anyone who is familiar with a command-line shell. Furthermore, Favalon's
type inference engine can be separated from its runtime library and easily
repurposed for other applications.
</summary>
    <author>
      <name>Kouji Matsui</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">26 pages, 6 figures, It has been presented at Information Processing
  Society of Japan Programming Study Group-132nd Programming Study Group</arxiv:comment>
    <link href="http://arxiv.org/abs/2104.03678v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2104.03678v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.4.9" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2104.08366v1</id>
    <updated>2021-04-16T20:59:42Z</updated>
    <published>2021-04-16T20:59:42Z</published>
    <title>A Gradual Type System for Elixir</title>
    <summary>  Elixir is a functional programming language with dynamic typing. We propose a
gradual type system that makes it possible to perform type-checking on a
significant fragment of the language. An important feature of the type system
is that it does not require any syntactic change to Elixir. Type information is
provided by means of function signatures which are declared in terms of Elixir
typespec directives. The proposed type system is based on subtyping and is
backward compatible, as it allows the presence of untyped code fragments. We
have implemented a prototype of the type-checker in Elixir itself.
</summary>
    <author>
      <name>Mauricio Cassola</name>
    </author>
    <author>
      <name>Agustín Talagorria</name>
    </author>
    <author>
      <name>Alberto Pardo</name>
    </author>
    <author>
      <name>Marcos Viera</name>
    </author>
    <link href="http://arxiv.org/abs/2104.08366v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2104.08366v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2106.12973v1</id>
    <updated>2021-06-24T12:47:23Z</updated>
    <published>2021-06-24T12:47:23Z</published>
    <title>Making Tezos smart contracts more reliable with Coq</title>
    <summary>  Tezos is a smart-contract blockchain. Tezos smart contracts are written in a
low-level stack-based language called Michelson. This article gives an overview
of efforts using the Coq proof assistant to have stronger guarantees on
Michelson smart contracts: the Mi-Cho-Coq framework, a Coq library defining
formal semantics of Michelson, as well as an interpreter, a simple optimiser
and a weakest-precondition calculus to reason about Michelson smart contracts;
Albert, an intermediate language that abstracts Michelson stacks with a
compiler written in Coq that targets Mi-Cho-Coq.
</summary>
    <author>
      <name>Bruno Bernardo</name>
    </author>
    <author>
      <name>Raphaël Cauderlier</name>
    </author>
    <author>
      <name>Guillaume Claret</name>
    </author>
    <author>
      <name>Arvid Jakobsson</name>
    </author>
    <author>
      <name>Basile Pesin</name>
    </author>
    <author>
      <name>Julien Tesson</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-61467-6_5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-61467-6_5" rel="related"/>
    <link href="http://arxiv.org/abs/2106.12973v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2106.12973v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2106.14586v3</id>
    <updated>2021-09-21T11:00:50Z</updated>
    <published>2021-06-28T11:48:01Z</published>
    <title>A Dictionary-Passing Translation of Featherweight Go</title>
    <summary>  The Go programming language is an increasingly popular language but some of
its features lack a formal investigation. This article explains Go's resolution
mechanism for overloaded methods and its support for structural subtyping by
means of translation from Featherweight Go to a simple target language. The
translation employs a form of dictionary passing known from type classes in
Haskell and preserves the dynamic behavior of Featherweight Go programs.
</summary>
    <author>
      <name>Martin Sulzmann</name>
    </author>
    <author>
      <name>Stefan Wehr</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">omit ref to online version</arxiv:comment>
    <link href="http://arxiv.org/abs/2106.14586v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2106.14586v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2106.14938v2</id>
    <updated>2021-07-05T14:31:19Z</updated>
    <published>2021-06-28T18:39:16Z</published>
    <title>Seeking Stability by being Lazy and Shallow</title>
    <summary>  Designing a language feature often requires a choice between several,
similarly expressive possibilities. Given that user studies are generally
impractical, we propose using stability as a way of making such decisions.
Stability is a measure of whether the meaning of a program alters under small,
seemingly innocuous changes in the code. Directly motivated by a need to pin
down a feature in GHC/Haskell, we apply this notion of stability to analyse
four approaches to the instantiation of polymorphic types, concluding that the
most stable approach is lazy (instantiate a polytype only when absolutely
necessary) and shallow (instantiate only top-level type variables, not
variables that appear after explicit arguments).
</summary>
    <author>
      <name>Gert-Jan Bottu</name>
    </author>
    <author>
      <name>Richard A. Eisenberg</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Haskell Symposium 21</arxiv:comment>
    <link href="http://arxiv.org/abs/2106.14938v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2106.14938v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.02769v2</id>
    <updated>2021-11-08T16:34:17Z</updated>
    <published>2021-10-06T13:47:48Z</published>
    <title>Visibility Reasoning for Concurrent Snapshot Algorithms</title>
    <summary>  Visibility relations have been proposed by Henzinger et al. as an abstraction
for proving linearizability of concurrent algorithms that obtains modular and
reusable proofs. This is in contrast to the customary approach based on
exhibiting the algorithm's linearization points. In this paper we apply
visibility relations to develop modular proofs for three elegant concurrent
snapshot algorithms of Jayanti. The proofs are divided by signatures into
components of increasing level of abstraction; the components at higher
abstraction levels are shared, i.e., they apply to all three algorithms
simultaneously. Importantly, the interface properties mathematically capture
Jayanti's original intuitions that have previously been given only informally.
</summary>
    <author>
      <name>Joakim Öhman</name>
    </author>
    <author>
      <name>Aleksandar Nanevski</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3498694</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3498694" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">45 pages, 12 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2110.02769v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.02769v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.03806v2</id>
    <updated>2021-10-24T15:28:45Z</updated>
    <published>2021-10-07T21:43:54Z</published>
    <title>Toward a Theory of Programming Language and Reasoning Assistant Design:
  Minimizing Cognitive Load</title>
    <summary>  Current approaches to making programming languages and reasoning assistants
more effective for people focus on leveraging feedback from users and on
evaluating the success of particular techniques. These approaches, although
helpful, may not result in systems that are as usable as possible, and may not
lead to general design principles. This paper advocates for leveraging theories
from cognitive science, focusing on cognitive load theory, to design more
effective programming languages and reasoning assistants. Development of these
theories may enable designers to create more effective programming languages
and reasoning assistants at lower cost.
</summary>
    <author>
      <name>Michael Coblenz</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">8 pages. In HATRA 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2110.03806v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.03806v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0; D.2.1; D.2.3; D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.05390v1</id>
    <updated>2021-10-11T16:30:04Z</updated>
    <published>2021-10-11T16:30:04Z</published>
    <title>Synthesizing Machine Learning Programs with PAC Guarantees via
  Statistical Sketching</title>
    <summary>  We study the problem of synthesizing programs that include machine learning
components such as deep neural networks (DNNs). We focus on statistical
properties, which are properties expected to hold with high probability --
e.g., that an image classification model correctly identifies people in images
with high probability. We propose novel algorithms for sketching and
synthesizing such programs by leveraging ideas from statistical learning theory
to provide statistical soundness guarantees. We evaluate our approach on
synthesizing list processing programs that include DNN components used to
process image inputs, as well as case studies on image classification and on
precision medicine. Our results demonstrate that our approach can be used to
synthesize programs with probabilistic guarantees.
</summary>
    <author>
      <name>Osbert Bastani</name>
    </author>
    <link href="http://arxiv.org/abs/2110.05390v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.05390v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.06107v1</id>
    <updated>2021-10-12T15:54:35Z</updated>
    <published>2021-10-12T15:54:35Z</published>
    <title>Generic Level Polymorphic N-ary Functions</title>
    <summary>  Agda's standard library struggles in various places with n-ary functions and
relations. It introduces congruence and substitution operators for functions of
arities one and two, and provides users with convenient combinators for
manipulating indexed families of arity exactly one.
  After a careful analysis of the kinds of problems the unifier can easily
solve, we design a unifier-friendly representation of n-ary functions. This
allows us to write generic programs acting on n-ary functions which
automatically reconstruct the representation of their inputs' types by
unification. In particular, we can define fully level polymorphic n-ary
versions of congruence, substitution and the combinators for indexed families,
all requiring minimal user input.
</summary>
    <author>
      <name>Guillaume Allais</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3331554</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3331554" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Draft of the Tyde19 paper</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">TyDe 2019: Proceedings of the 4th ACM SIGPLAN International
  Workshop on Type-Driven Development (Pages 14-26)</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2110.06107v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.06107v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.07493v1</id>
    <updated>2021-10-14T16:09:11Z</updated>
    <published>2021-10-14T16:09:11Z</published>
    <title>Parallel Algebraic Effect Handlers</title>
    <summary>  Algebraic effects and handlers support composable and structured control-flow
abstraction. However, existing designs of algebraic effects often require
effects to be executed sequentially. This paper studies parallel algebraic
effect handlers. In particular, we formalize {\lambda}p, an untyped lambda
calculus which models two key features, effect handlers and parallelizable
computations, the latter of which takes the form of a for expression as
inspired by the Dex programming language. We present various interesting
examples expressible in our calculus, and provide a Haskell implementation. We
hope this paper provides a basis for future designs and implementations of
parallel algebraic effect handlers.
</summary>
    <author>
      <name>Ningning Xie</name>
    </author>
    <author>
      <name>Daniel D. Johnson</name>
    </author>
    <author>
      <name>Dougal Maclaurin</name>
    </author>
    <author>
      <name>Adam Paszke</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Short paper submitted to the ACM SIGPLAN Workshop on Partial
  Evaluation and Program Manipulation (PEPM) 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2110.07493v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.07493v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2110.08983v1</id>
    <updated>2021-10-18T02:25:54Z</updated>
    <published>2021-10-18T02:25:54Z</published>
    <title>An Empirical Study of Protocols in Smart Contracts</title>
    <summary>  Smart contracts are programs that are executed on a blockhain. They have been
used for applications in voting, decentralized finance, and supply chain
management. However, vulnerabilities in smart contracts have been abused by
hackers, leading to financial losses. Understanding state machine protocols in
smart contracts has been identified as important to catching common bugs,
improving documentation, and optimizing smart contracts. We analyze Solidity
smart contracts deployed on the Ethereum blockchain and study the prevalence of
protocols and protocol-based bugs, as well as opportunities for gas
optimizations.
</summary>
    <author>
      <name>Timothy Mou</name>
    </author>
    <author>
      <name>Michael Coblenz</name>
    </author>
    <author>
      <name>Jonathan Aldrich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages. In HATRA 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2110.08983v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2110.08983v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2201.09448v1</id>
    <updated>2022-01-24T04:27:35Z</updated>
    <published>2022-01-24T04:27:35Z</published>
    <title>Cobol2Vec: Learning Representations of Cobol code</title>
    <summary>  There has been a steadily growing interest in development of novel methods to
learn a representation of a given input data and subsequently using them for
several downstream tasks. The field of natural language processing has seen a
significant improvement in different tasks by incorporating pre-trained
embeddings into their pipelines. Recently, these methods have been applied to
programming languages with a view to improve developer productivity. In this
paper, we present an unsupervised learning approach to encode old mainframe
languages into a fixed dimensional vector space. We use COBOL as our motivating
example and create a corpus and demonstrate the efficacy of our approach in a
code-retrieval task on our corpus.
</summary>
    <author>
      <name>Ankit Kulshrestha</name>
    </author>
    <author>
      <name>Vishwas Lele</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Initial draft</arxiv:comment>
    <link href="http://arxiv.org/abs/2201.09448v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2201.09448v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2201.11040v2</id>
    <updated>2022-02-02T14:59:20Z</updated>
    <published>2022-01-26T16:28:05Z</published>
    <title>A Dependent Dependency Calculus (Extended Version)</title>
    <summary>  Over twenty years ago, Abadi et al. established the Dependency Core Calculus
(DCC) as a general purpose framework for analyzing dependency in typed
programming languages. Since then, dependency analysis has shown many practical
benefits to language design: its results can help users and compilers enforce
security constraints, eliminate dead code, among other applications. In this
work, we present a Dependent Dependency Calculus (DDC), which extends this
general idea to the setting of a dependently-typed language. We use this
calculus to track both run-time and compile-time irrelevance, enabling faster
type-checking and program execution.
</summary>
    <author>
      <name>Pritam Choudhury</name>
    </author>
    <author>
      <name>Harley Eades III</name>
    </author>
    <author>
      <name>Stephanie Weirich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of paper published in ESOP 2022, 2-7 April 2022,
  Munich, Germany</arxiv:comment>
    <link href="http://arxiv.org/abs/2201.11040v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2201.11040v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2202.04305v1</id>
    <updated>2022-02-09T06:44:04Z</updated>
    <published>2022-02-09T06:44:04Z</published>
    <title>Compiler Support for Sparse Tensor Computations in MLIR</title>
    <summary>  Sparse tensors arise in problems in science, engineering, machine learning,
and data analytics. Programs that operate on such tensors can exploit sparsity
to reduce storage requirements and computational time. Developing and
maintaining sparse software by hand, however, is a complex and error-prone
task. Therefore, we propose treating sparsity as a property of tensors, not a
tedious implementation task, and letting a sparse compiler generate sparse code
automatically from a sparsity-agnostic definition of the computation. This
paper discusses integrating this idea into MLIR.
</summary>
    <author>
      <name>Aart J. C. Bik</name>
    </author>
    <author>
      <name>Penporn Koanantakool</name>
    </author>
    <author>
      <name>Tatiana Shpeisman</name>
    </author>
    <author>
      <name>Nicolas Vasilache</name>
    </author>
    <author>
      <name>Bixia Zheng</name>
    </author>
    <author>
      <name>Fredrik Kjolstad</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3544559</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3544559" rel="related"/>
    <link href="http://arxiv.org/abs/2202.04305v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2202.04305v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2202.06868v1</id>
    <updated>2022-02-14T16:54:58Z</updated>
    <published>2022-02-14T16:54:58Z</published>
    <title>Enhancing expressivity of checked corecursive streams (extended version)</title>
    <summary>  We propose a novel approach to stream definition and manipulation. Our
solution is based on two key ideas. Regular corecursion, which avoids non
termination by detecting cyclic calls, is enhanced, by allowing in equations
defining streams other operators besides the stream constructor. In this way,
some non-regular streams are definable. Furthermore, execution includes a
runtime check to ensure that the stream generated by a function call is
well-defined, in the sense that access to an arbitrary index always succeeds.
We extend the technique beyond the simple stream operators considered in
previous work, notably by adding an interleaving combinator which has a
non-trivial recursion scheme.
</summary>
    <author>
      <name>Davide Ancona</name>
    </author>
    <author>
      <name>Pietro Barbieri</name>
    </author>
    <author>
      <name>Elena Zucca</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages. arXiv admin note: substantial text overlap with
  arXiv:2108.00281</arxiv:comment>
    <link href="http://arxiv.org/abs/2202.06868v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2202.06868v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2202.08511v2</id>
    <updated>2022-03-04T07:05:43Z</updated>
    <published>2022-02-17T08:35:16Z</published>
    <title>Scheduling Complexity of Interleaving Search</title>
    <summary>  miniKanren is a lightweight embedded language for logic and relational
programming. Many of its useful features come from a distinctive search
strategy, called interleaving search. However, with interleaving search
conventional ways of reasoning about the complexity and performance of logical
programs become irrelevant. We identify an important key component --
scheduling -- which makes the reasoning for miniKanren so different, and
present a semi-automatic technique to estimate the scheduling impact via
symbolic execution for a reasonably wide class of programs.
</summary>
    <author>
      <name>Dmitry Rozplokhas</name>
    </author>
    <author>
      <name>Dmitry Boulytchev</name>
    </author>
    <link href="http://arxiv.org/abs/2202.08511v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2202.08511v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.6328v1</id>
    <updated>2013-02-26T06:48:39Z</updated>
    <published>2013-02-26T06:48:39Z</published>
    <title>Variant-Frequency Semantics for Green Futures</title>
    <summary>  This paper describes an operational semantics for futures, with the primary
target on energy efficiency. The work in progress is built around an insight
that different threads can coordinate by running at different "paces," so that
the time for synchronization and the resulting wasteful energy consumption can
be reduced. We exploit several inherent characteristics of futures to determine
how the paces of involving threads can be coordinated. The semantics is
inspired by recent advances in computer architectures, where the frequencies of
CPU cores can be adjusted dynamically. The work is a first-step toward a
direction where variant frequencies are directly modeled as an essential
semantic feature in concurrent programming languages.
</summary>
    <author>
      <name>Yu David Liu</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">SUNY Binghamton</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.109.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.109.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2012, arXiv:1302.5798</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 109, 2013, pp. 1-6</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1302.6328v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.6328v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1302.6333v1</id>
    <updated>2013-02-26T06:49:18Z</updated>
    <published>2013-02-26T06:49:18Z</published>
    <title>Modularizing and Specifying Protocols among Threads</title>
    <summary>  We identify three problems with current techniques for implementing protocols
among threads, which complicate and impair the scalability of multicore
software development: implementing synchronization, implementing coordination,
and modularizing protocols. To mend these deficiencies, we argue for the use of
domain-specific languages (DSL) based on existing models of concurrency. To
demonstrate the feasibility of this proposal, we explain how to use the model
of concurrency Reo as a high-level protocol DSL, which offers appropriate
abstractions and a natural separation of protocols and computations. We
describe a Reo-to-Java compiler and illustrate its use through examples.
</summary>
    <author>
      <name>Sung-Shik T. Q. Jongmans</name>
    </author>
    <author>
      <name>Farhad Arbab</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.109.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.109.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2012, arXiv:1302.5798</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 109, 2013, pp. 34-45</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1302.6333v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1302.6333v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.1870v1</id>
    <updated>2013-06-08T02:22:42Z</updated>
    <published>2013-06-08T02:22:42Z</published>
    <title>The Cyan Language</title>
    <summary>  This is the manual of Cyan, a prototype-based object-oriented language. Cyan
supports static typing, single inheritance, mixin objects (similar to mixin
classes with mixin inheritance), generic prototypes, and Java-like interfaces.
The language has several innovations: a completely object-oriented exception
system, statically-typed closures, a kind of graphical metaobjects called
codegs, optional dynamic typing, user-defined literal objects (an innovative
way of creating objects), context objects (a generalization of closures), and
grammar methods and message sends (which makes it easy to define Domain
Specific Languages).
</summary>
    <author>
      <name>José de Oliveira Guimarães</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">248 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.1870v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.1870v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.1901v1</id>
    <updated>2013-06-08T10:10:05Z</updated>
    <published>2013-06-08T10:10:05Z</published>
    <title>Eventual Linear Ranking Functions</title>
    <summary>  Program termination is a hot research topic in program analysis. The last few
years have witnessed the development of termination analyzers for programming
languages such as C and Java with remarkable precision and performance. These
systems are largely based on techniques and tools coming from the field of
declarative constraint programming. In this paper, we first recall an algorithm
based on Farkas' Lemma for discovering linear ranking functions proving
termination of a certain class of loops. Then we propose an extension of this
method for showing the existence of eventual linear ranking functions, i.e.,
linear functions that become ranking functions after a finite unrolling of the
loop. We show correctness and completeness of this algorithm.
</summary>
    <author>
      <name>Roberto Bagnara</name>
    </author>
    <author>
      <name>Fred Mesnard</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2505879.2505884</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2505879.2505884" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.1901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.1901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.2267v1</id>
    <updated>2013-06-06T13:07:30Z</updated>
    <published>2013-06-06T13:07:30Z</published>
    <title>Let's Annotate to Let Our Code Run in Parallel</title>
    <summary>  This paper presents an approach that exploits Java annotations to provide
meta information needed to automatically transform plain Java programs into
parallel code that can be run on multicore workstation. Programmers just need
to decorate the methods that will eventually be executed in parallel with
standard Java annotations. Annotations are automatically processed at
launch-time and parallel byte code is derived. Once in execution the program
automatically retrieves the information about the executing platform and
evaluates the information specified inside the annotations to transform the
byte-code into a semantically equivalent multithreaded version, depending on
the target architecture features. The results returned by the annotated
methods, when invoked, are futures with a wait-by-necessity semantics.
</summary>
    <author>
      <name>Patrizio Dazzi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages, 1 figure</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.2267v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.2267v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.2291v1</id>
    <updated>2013-06-10T19:12:57Z</updated>
    <published>2013-06-10T19:12:57Z</published>
    <title>Optimal multi-binding unification for sharing and linearity analysis</title>
    <summary>  In the analysis of logic programs, abstract domains for detecting sharing
properties are widely used. Recently the new domain $\Linp$ has been introduced
to generalize both sharing and linearity information. This domain is endowed
with an optimal abstract operator for single-binding unification. The authors
claim that the repeated application of this operator is also optimal for
multi-binding unification. This is the proof of such a claim.
</summary>
    <author>
      <name>Gianluca Amato</name>
    </author>
    <author>
      <name>Francesca Scozzari</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068413000070</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068413000070" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in Theory and Practice of Logic Programming (TPLP)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming, 14, pp 379-400, 2014</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1306.2291v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.2291v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.5061v1</id>
    <updated>2013-06-21T06:53:04Z</updated>
    <published>2013-06-21T06:53:04Z</published>
    <title>Towards Tree Automata-based Success Types</title>
    <summary>  Error detection facilities for dynamic languages are often based on unit
testing. Thus, the advantage of rapid prototyping and flexibility must be
weighed against cumbersome and time consuming test suite development. Lindahl
and Sagonas' success typings provide a means of static must-fail detection in
Erlang. Due to the constraint-based nature of the approach, some errors
involving nested tuples and recursion cannot be detected.
  We propose an approach that uses an extension of model checking for
pattern-matching recursion schemes with context-aware ranked tree automata to
provide improved success typings for a constructor-based first-order prototype
language.
</summary>
    <author>
      <name>Robert Jakob</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Abstract presented at HOPA 2013</arxiv:comment>
    <link href="http://arxiv.org/abs/1306.5061v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.5061v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.6029v4</id>
    <updated>2014-06-22T20:43:48Z</updated>
    <published>2013-06-25T16:49:16Z</published>
    <title>AstraKahn: A Coordination Language for Streaming Networks</title>
    <summary>  This is a preliminary version of the language report. It contains key
definitions, specifications and some examples, but lacks completeness. The full
document will include Chapter 3 (Data and Instrumentation Layer) and will
comprise an appendix giving the complete syntax and some whole program
examples. The purpose of the present document is to fix the concepts and major
features of the language and to enable the production of the definition
document that is required for implementation.
</summary>
    <author>
      <name>Alex Shafarenko</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/s10601-020-09309-y</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/s10601-020-09309-y" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">34 pages. Constraints (2020)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In: Constraints. 25, p. 21-159 5 Aug 2020</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1306.6029v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.6029v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1306.6856v1</id>
    <updated>2013-06-28T14:38:13Z</updated>
    <published>2013-06-28T14:38:13Z</published>
    <title>Linear Dependent Types for Domain Specific Program Analysis (Extended
  Abstract)</title>
    <summary>  In this tutorial I will present how a combination of linear and dependent
type can be useful to describe different properties about higher order
programs. Linear types have been proved particularly useful to express
properties of functions; dependent types are useful to describe the behavior of
the program in terms of its control flow. This two ideas fits together well
when one is interested in analyze properties of functions depending on the
control flow of the program. I will present these ideas with example taken by
complexity analysis and sensitivity analysis. I will conclude the tutorial by
arguing about the generality of this approach.
</summary>
    <author>
      <name>Marco Gaboardi</name>
    </author>
    <link href="http://arxiv.org/abs/1306.6856v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1306.6856v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1401.5391v1</id>
    <updated>2014-01-21T17:23:45Z</updated>
    <published>2014-01-21T17:23:45Z</published>
    <title>The semantic marriage of monads and effects</title>
    <summary>  Wadler and Thiemann unified type-and-effect systems with monadic semantics
via a syntactic correspondence and soundness results with respect to an
operational semantics. They conjecture that a general, "coherent" denotational
semantics can be given to unify effect systems with a monadic-style semantics.
We provide such a semantics based on the novel structure of an indexed monad,
which we introduce. We redefine the semantics of Moggi's computational
lambda-calculus in terms of (strong) indexed monads which gives a one-to-one
correspondence between indices of the denotations and the effect annotations of
traditional effect systems. Dually, this approach yields indexed comonads which
gives a unified semantics and effect system to contextual notions of effect
(called coeffects), which we have previously described.
</summary>
    <author>
      <name>Dominic Orchard</name>
    </author>
    <author>
      <name>Tomas Petricek</name>
    </author>
    <author>
      <name>Alan Mycroft</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">extended abstract</arxiv:comment>
    <link href="http://arxiv.org/abs/1401.5391v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1401.5391v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.3735v1</id>
    <updated>2014-10-14T15:34:39Z</updated>
    <published>2014-10-14T15:34:39Z</published>
    <title>The Foundational Cryptography Framework</title>
    <summary>  We present the Foundational Cryptography Framework (FCF) for developing and
checking complete proofs of security for cryptographic schemes within a proof
assistant. This is a general-purpose framework that is capable of modeling and
reasoning about a wide range of cryptographic schemes, security definitions,
and assumptions. Security is proven in the computational model, and the proof
provides concrete bounds as well as asymptotic conclusions. FCF provides a
language for probabilistic programs, a theory that is used to reason about
programs, and a library of tactics and definitions that are useful in proofs
about cryptography. The framework is designed to leverage fully the existing
theory and capabilities of the Coq proof assistant in order to reduce the
effort required to develop proofs.
</summary>
    <author>
      <name>Adam Petcher</name>
    </author>
    <author>
      <name>Greg Morrisett</name>
    </author>
    <link href="http://arxiv.org/abs/1410.3735v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.3735v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.3772v1</id>
    <updated>2014-10-12T15:16:55Z</updated>
    <published>2014-10-12T15:16:55Z</published>
    <title>Optimizing the For loop: Comparison of For loop and micro For loop</title>
    <summary>  Looping is one of the fundamental logical instructions used for repeating a
block of code. It is used in programs across all programming languages.
Traditionally, in languages like C, the for loop is used extensively for
repeated execution of a block of code, due to its ease for use and simplified
representation. This paper proposes a new way of representing the for loop to
improve its runtime efficiency and compares the experimental statistics with
the traditional for loop representation. It is found that for small number of
iterations, the difference in computational time may not be considerable. But
given any large number of iterations, the difference is noticeable.
</summary>
    <author>
      <name>Rishabh Jain</name>
    </author>
    <author>
      <name>Sakshi Gupta</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 2 figures, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/1410.3772v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.3772v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68-02" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.6449v2</id>
    <updated>2014-11-06T19:27:27Z</updated>
    <published>2014-10-23T18:42:57Z</published>
    <title>Parallel Prefix Polymorphism Permits Parallelization, Presentation &amp;
  Proof</title>
    <summary>  Polymorphism in programming languages enables code reuse. Here, we show that
polymorphism has broad applicability far beyond computations for technical
computing: parallelism in distributed computing, presentation of visualizations
of runtime data flow, and proofs for formal verification of correctness. The
ability to reuse a single codebase for all these purposes provides new ways to
understand and verify parallel programs.
</summary>
    <author>
      <name>Jiahao Chen</name>
    </author>
    <author>
      <name>Alan Edelman</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 3 figures. Proceedings of HPTCDL, the 1st Workshop on High
  Performance Technical Computing in Dynamic Languages, November 17, 2014, New
  Orleans, Louisiana, USA. Supporting Information available at
  http://jiahao.github.io/parallel-prefix</arxiv:comment>
    <link href="http://arxiv.org/abs/1410.6449v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.6449v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.2; G.1.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1410.7467v1</id>
    <updated>2014-10-28T00:40:55Z</updated>
    <published>2014-10-28T00:40:55Z</published>
    <title>Toward Sequentializing Overparallelized Protocol Code</title>
    <summary>  In our ongoing work, we use constraint automata to compile protocol
specifications expressed as Reo connectors into efficient executable code,
e.g., in C. We have by now studied this automata based compilation approach
rather well, and have devised effective solutions to some of its problems.
Because our approach is based on constraint automata, the approach, its
problems, and our solutions are in fact useful and relevant well beyond the
specific case of compiling Reo. In this short paper, we identify and analyze
two such rather unexpected problems.
</summary>
    <author>
      <name>Sung-Shik T. Q. Jongmans</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CWI</arxiv:affiliation>
    </author>
    <author>
      <name>Farhad Arbab</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CWI</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.166.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.166.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2014, arXiv:1410.7013</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 166, 2014, pp. 38-44</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1410.7467v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1410.7467v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.04908v1</id>
    <updated>2015-03-17T03:58:44Z</updated>
    <published>2015-03-17T03:58:44Z</published>
    <title>Liquid Intersection Types</title>
    <summary>  We present a new type system combining refinement types and the
expressiveness of intersection type discipline. The use of such features makes
it possible to derive more precise types than in the original refinement
system. We have been able to prove several interesting properties for our
system (including subject reduction) and developed an inference algorithm,
which we proved to be sound.
</summary>
    <author>
      <name>Mário Pereira</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <author>
      <name>Sandra Alves</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <author>
      <name>Mário Florido</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Porto, Department of Computer Science &amp; LIACC</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.177.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.177.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ITRS 2014, arXiv:1503.04377</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 177, 2015, pp. 24-42</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1503.04908v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.04908v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1503.09097v1</id>
    <updated>2015-03-31T15:49:55Z</updated>
    <published>2015-03-31T15:49:55Z</published>
    <title>Open Transactions on Shared Memory</title>
    <summary>  Transactional memory has arisen as a good way for solving many of the issues
of lock-based programming. However, most implementations admit isolated
transactions only, which are not adequate when we have to coordinate
communicating processes. To this end, in this paper we present OCTM, an
Haskell-like language with open transactions over shared transactional memory:
processes can join transactions at runtime just by accessing to shared
variables. Thus a transaction can co-operate with the environment through
shared variables, but if it is rolled-back, also all its effects on the
environment are retracted. For proving the expressive power of TCCS we give an
implementation of TCCS, a CCS-like calculus with open transactions.
</summary>
    <author>
      <name>Marino Miculan</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <author>
      <name>Andrea Toneguzzo</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-319-19282-6_14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-319-19282-6_14" rel="related"/>
    <link href="http://arxiv.org/abs/1503.09097v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1503.09097v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.00928v1</id>
    <updated>2015-11-03T14:40:57Z</updated>
    <published>2015-11-03T14:40:57Z</published>
    <title>Visualising interactive inferences with IDPD3</title>
    <summary>  A large part of the use of knowledge base systems is the interpretation of
the output by the end-users and the interaction with these users. Even during
the development process visualisations can be a great help to the developer. We
created IDPD3 as a library to visualise models of logic theories. IDPD3 is a
new version of $ID^{P}_{Draw}$ and adds support for visualised interactive
simulations.
</summary>
    <author>
      <name>Ruben Lapauw</name>
    </author>
    <author>
      <name>Ingmar Dasseville</name>
    </author>
    <author>
      <name>Marc Denecker</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">International Workshop on User-Oriented Logic Programming (IULP
  2015), co-located with the 31st International Conference on Logic Programming
  (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic
  Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz,
  pages 67-81, August 2015</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.00928v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.00928v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.01838v1</id>
    <updated>2015-11-05T18:05:10Z</updated>
    <published>2015-11-05T18:05:10Z</published>
    <title>The Complexity of Interaction (Long Version)</title>
    <summary>  In this paper, we analyze the complexity of functional programs written in
the interaction-net computation model, an asynchronous, parallel and confluent
model that generalizes linear-logic proof nets. Employing user-defined sized
and scheduled types, we certify concrete time, space and space-time complexity
bounds for both sequential and parallel reductions of interaction-net programs
by suitably assigning complexity potentials to typed nodes. The relevance of
this approach is illustrated on archetypal programming examples. The provided
analysis is precise, compositional and is, in theory, not restricted to
particular complexity classes.
</summary>
    <author>
      <name>Stéphane Gimenez</name>
    </author>
    <author>
      <name>Georg Moser</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/2837614.2837646</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/2837614.2837646" rel="related"/>
    <link href="http://arxiv.org/abs/1511.01838v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.01838v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.02415v1</id>
    <updated>2015-11-08T00:25:07Z</updated>
    <published>2015-11-08T00:25:07Z</published>
    <title>Anonymous On-line Communication Between Program Analyses</title>
    <summary>  We propose a light-weight client-server model of communication between
program analyses. Clients are individual analyses and the server mediates their
communication. A client cannot see properties of any other and the
communication is anonymous. There is no central algorithm standing above
clients which would tell them when to communicate what information. Clients
communicate with others spontaneously, according to their actual personal
needs. The model is based on our observation that a piece of information
provided to an analysis at a right place may (substantially) improve its
result. We evaluated the proposed communication model for all possible
combinations of three clients on more than 400 benchmarks and the results show
that the communication model performs well in practice.
</summary>
    <author>
      <name>Marek Trtik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Regular paper, 20 pages. arXiv admin note: text overlap with
  arXiv:1504.07862</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.02415v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.02415v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.02629v1</id>
    <updated>2015-11-09T10:51:06Z</updated>
    <published>2015-11-09T10:51:06Z</published>
    <title>Normalisation by Traversals</title>
    <summary>  We present a novel method of computing the beta-normal eta-long form of a
simply-typed lambda-term by constructing traversals over a variant abstract
syntax tree of the term. In contrast to beta-reduction, which changes the term
by substitution, this method of normalisation by traversals leaves the original
term intact. We prove the correctness of the normalisation procedure by game
semantics. As an application, we establish a path-traversal correspondence
theorem which is the basis of a key decidability result in higher-order model
checking.
</summary>
    <author>
      <name>C. -H. Luke Ong</name>
    </author>
    <link href="http://arxiv.org/abs/1511.02629v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.02629v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.1; I.2.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.03406v1</id>
    <updated>2015-11-11T07:44:04Z</updated>
    <published>2015-11-11T07:44:04Z</published>
    <title>Implementing a Small Parsing Virtual Machine on Embedded Systems</title>
    <summary>  PEGs are a formal grammar foundation for describing syntax, and are not hard
to generate parsers with a plain recursive decent parsing. However, the large
amount of C-stack consumption in the recursive parsing is not acceptable
especially in resource-restricted embedded systems. Alternatively, we have
attempted the machine virtualization approach to PEG-based parsing. MiniNez,
our implemented virtual machine, is presented in this paper with several
downsizing techniques, including instruction specialization, inline expansion
and static flow analysis. As a result, the MiniNez machine achieves both a very
small footprint and competitive performance to generated C parsers. We have
demonstrated the experimental results by comparing on two major embedded
platforms: Cortex-A7 and Intel Atom processor.
</summary>
    <author>
      <name>Shun Honda</name>
    </author>
    <author>
      <name>Kimio Kuramitsu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">An earlier draft for future submission</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.03406v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.03406v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1511.05104v1</id>
    <updated>2015-11-16T19:48:48Z</updated>
    <published>2015-11-16T19:48:48Z</published>
    <title>Time complexity of concurrent programs</title>
    <summary>  We study the problem of automatically computing the time complexity of
concurrent object-oriented programs. To determine this complexity we use
intermediate abstract descriptions that record relevant information for the
time analysis (cost of statements, creations of objects, and concurrent
operations), called behavioural types. Then, we define a translation function
that takes behavioural types and makes the parallelism explicit into so-called
cost equations, which are fed to an automatic off-the-shelf solver for
obtaining the time complexity.
</summary>
    <author>
      <name>Elena Giachino</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Einar Broch Johnsen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Cosimo Laneve</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">DISI, FOCUS</arxiv:affiliation>
    </author>
    <author>
      <name>Ka I Pun</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">FACS 2015, Oct 2015, Niter\'oi, Rio de Janeiro, Brazil</arxiv:comment>
    <link href="http://arxiv.org/abs/1511.05104v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1511.05104v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.00831v3</id>
    <updated>2018-11-02T17:51:57Z</updated>
    <published>2016-10-04T03:10:55Z</published>
    <title>Notes on Pure Dataflow Matrix Machines: Programming with
  Self-referential Matrix Transformations</title>
    <summary>  Dataflow matrix machines are self-referential generalized recurrent neural
nets. The self-referential mechanism is provided via a stream of matrices
defining the connectivity and weights of the network in question. A natural
question is: what should play the role of untyped lambda-calculus for this
programming architecture? The proposed answer is a discipline of programming
with only one kind of streams, namely the streams of appropriately shaped
matrices. This yields Pure Dataflow Matrix Machines which are networks of
transformers of streams of matrices capable of defining a pure dataflow matrix
machine.
</summary>
    <author>
      <name>Michael Bukatin</name>
    </author>
    <author>
      <name>Steve Matthews</name>
    </author>
    <author>
      <name>Andrey Radul</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages (v3 - update page 7)</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.00831v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.00831v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.01213v3</id>
    <updated>2016-11-08T15:58:09Z</updated>
    <published>2016-10-04T21:37:45Z</published>
    <title>Deciding equivalence with sums and the empty type</title>
    <summary>  The logical technique of focusing can be applied to the $\lambda$-calculus;
in a simple type system with atomic types and negative type formers (functions,
products, the unit type), its normal forms coincide with $\beta\eta$-normal
forms. Introducing a saturation phase gives a notion of quasi-normal forms in
presence of positive types (sum types and the empty type). This rich structure
let us prove the decidability of $\beta\eta$-equivalence in presence of the
empty type, the fact that it coincides with contextual equivalence, and a
finite model property.
</summary>
    <author>
      <name>Gabriel Scherer</name>
    </author>
    <link href="http://arxiv.org/abs/1610.01213v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.01213v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03F03, 68N18" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.3; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.02327v1</id>
    <updated>2016-10-07T15:35:30Z</updated>
    <published>2016-10-07T15:35:30Z</published>
    <title>Causally consistent dynamic slicing</title>
    <summary>  We offer a lattice-theoretic account of dynamic slicing for {\pi}-calculus,
building on prior work in the sequential setting. For any run of a concurrent
program, we exhibit a Galois connection relating forward slices of the start
configuration to backward slices of the end configuration. We prove that, up to
lattice isomorphism, the same Galois connection arises for any causally
equivalent execution, allowing an efficient concurrent implementation of
slicing via a standard interleaving semantics. Our approach has been formalised
in the dependently-typed language Agda.
</summary>
    <author>
      <name>Roly Perera</name>
    </author>
    <author>
      <name>Deepak Garg</name>
    </author>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">in Proceedings of 27th International Conference on Concurrency Theory
  (CONCUR 2016)</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.02327v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.02327v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.02952v2</id>
    <updated>2017-10-31T13:38:13Z</updated>
    <published>2016-10-10T15:10:01Z</published>
    <title>Incrementally Closing Octagons</title>
    <summary>  The octagon abstract domain is a widely used numeric abstract domain
expressing relational information between variables whilst being both
computationally efficient and simple to implement. Each element of the domain
is a system of constraints where each constraint takes the restricted form $\pm
x_i \pm x_j \leq d$. A key family of operations for the octagon domain are
closure algorithms, which check satisfiability and provide a normal form for
octagonal constraint systems. We present new quadratic incremental algorithms
for closure, strong closure and integer closure and proofs of their
correctness. We highlight the benefits and measure the performance of these new
algorithms.
</summary>
    <author>
      <name>Aziem Chawdhary</name>
    </author>
    <author>
      <name>Ed Robbins</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">42 Pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.02952v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.02952v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.04799v1</id>
    <updated>2016-10-15T23:43:48Z</updated>
    <published>2016-10-15T23:43:48Z</published>
    <title>Trees That Grow</title>
    <summary>  We study the notion of extensibility in functional data types, as a new
approach to the problem of decorating abstract syntax trees with additional
sets of information. We observed the need for such extensibility while
redesigning the data types representing Haskell abstract syntax inside GHC.
  Specifically, we describe our approach to the tree-decoration problem using a
novel syntactic machinery in Haskell for expressing extensible data types. We
show that the syntactic machinery is complete in that it can express all the
syntactically possible forms of extensions to algebraic data type declarations.
Then, we describe an encoding of the syntactic machinery based on the existing
features in Glasgow Haskell Compiler(GHC).
</summary>
    <author>
      <name>Shayan Najd</name>
    </author>
    <author>
      <name>Simon Peyton Jones</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">EARLY DRAFT</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.04799v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.04799v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.05114v3</id>
    <updated>2016-10-30T15:55:27Z</updated>
    <published>2016-10-14T09:07:50Z</published>
    <title>Towards an Accurate Mathematical Model of Generic Nominally-Typed OOP</title>
    <summary>  The construction of GNOOP as a domain-theoretic model of generic
nominally-typed OOP is currently underway. This extended abstract presents the
concepts of `nominal intervals' and `full generication' that are likely to help
in building GNOOP as an accurate mathematical model of generic nominally-typed
OOP. The abstract also presents few related category-theoretic suggestions. The
presented concepts and suggestions are particularly geared towards enabling
GNOOP to offer a precise and simple view of so-far-hard-to-analyze features of
generic OOP such as variance annotations (e.g., Java wildcard types) and erased
generics (e.g., Java type erasure).
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1610.05114v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.05114v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.07118v1</id>
    <updated>2016-10-23T03:15:04Z</updated>
    <published>2016-10-23T03:15:04Z</published>
    <title>Verified Parallel String Matching in Haskell</title>
    <summary>  In this paper, we prove correctness of parallelizing a string matcher using
Haskell as a theorem prover. We use refinement types to specify correctness
properties, Haskell terms to express proofs and Liquid Haskell to check
correctness of proofs. First, we specify and prove that a class of monoid
morphisms can be parallelized via parallel monoid concatenation. Then, we
encode string matching as a morphism to get a provably correct parallel
transformation. Our 1839LoC prototype proof shows that Liquid Haskell can be
used as a fully expressive theorem prover on realistic Haskell implementations.
</summary>
    <author>
      <name>Niki Vazou</name>
    </author>
    <author>
      <name>Jeff Polakow</name>
    </author>
    <link href="http://arxiv.org/abs/1610.07118v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.07118v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.07965v1</id>
    <updated>2016-10-25T17:01:29Z</updated>
    <published>2016-10-25T17:01:29Z</published>
    <title>Higher-Order Linearisability</title>
    <summary>  Linearisability is a central notion for verifying concurrent libraries: a
given library is proven safe if its operational history can be rearranged into
a new sequential one which, in addition, satisfies a given specification.
Linearisability has been examined for libraries in which method arguments and
method results are of ground type, including libraries parameterised with such
methods. In this paper we extend linearisability to the general higher-order
setting: methods can be passed as arguments and returned as values. A library
may also depend on abstract methods of any order. We use this generalised
notion to show correctness of several higher-order example libraries.
</summary>
    <author>
      <name>Andrzej S. Murawski</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <link href="http://arxiv.org/abs/1610.07965v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.07965v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.3; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1610.08170v1</id>
    <updated>2016-10-26T05:00:33Z</updated>
    <published>2016-10-26T05:00:33Z</published>
    <title>Parameterized Dataflow (Extended Abstract)</title>
    <summary>  Dataflow networks have application in various forms of stream processing, for
example for parallel processing of multimedia data. The description of dataflow
graphs, including their firing behavior, is typically non-compositional and not
amenable to separate compilation. This article considers a dataflow language
with a type and effect system that captures the firing behavior of actors. This
system allows definitions to abstract over actor firing rates, supporting the
definition and safe composition of actor definitions where firing rates are not
instantiated until a dataflow graph is launched.
</summary>
    <author>
      <name>Dominic Duggan</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Stevens Institute of Technology</arxiv:affiliation>
    </author>
    <author>
      <name>Jianhua Yao</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Stevens Institute of Technology</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.227.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.227.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings QAPL'16, arXiv:1610.07696</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 227, 2016, pp. 63-81</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1610.08170v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1610.08170v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.00471v1</id>
    <updated>2018-01-01T16:46:28Z</updated>
    <published>2018-01-01T16:46:28Z</published>
    <title>TWAM: A Certifying Abstract Machine for Logic Programs</title>
    <summary>  Type-preserving (or typed) compilation uses typing derivations to certify
correctness properties of compilation. We have designed and implemented a
type-preserving compiler for a simply-typed dialect of Prolog we call T-Prolog.
The crux of our approach is a new certifying abstract machine which we call the
Typed Warren Abstract Machine (TWAM). The TWAM has a dependent type system
strong enough to specify the semantics of a logic program in the logical
framework LF. We present a soundness metatheorem which constitutes a partial
correctness guarantee: well-typed programs implement the logic program
specified by their type. This metatheorem justifies our design and
implementation of a certifying compiler from T-Prolog to TWAM.
</summary>
    <author>
      <name>Rose Bohrer</name>
    </author>
    <author>
      <name>Karl Crary</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">41 pages, under submission to ACM Transactions on Computational Logic</arxiv:comment>
    <link href="http://arxiv.org/abs/1801.00471v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.00471v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.02571v1</id>
    <updated>2018-01-08T17:26:35Z</updated>
    <published>2018-01-08T17:26:35Z</published>
    <title>Tamarin: Concolic Disequivalence for MIPS</title>
    <summary>  Given two MIPS programs, when are they equivalent? At first glance, this is
tricky to define, because of the unstructured nature of assembly code. We
propose the use of alternating concolic execution to detect whether two
programs are disequivalent. We have implemented our approach in a tool called
Tamarin, which includes a MIPS emulator instrumented to record symbolic traces,
as well as a concolic execution engine that integrates with the Z3 solver. We
show that Tamarin is able to reason about program disequivalence in a number of
scenarios, without any a-priori knowledge about the MIPS programs under
consideration.
</summary>
    <author>
      <name>Abel Nieto</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Technical Report</arxiv:comment>
    <link href="http://arxiv.org/abs/1801.02571v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.02571v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.04992v2</id>
    <updated>2018-06-07T18:06:32Z</updated>
    <published>2017-12-23T09:28:31Z</published>
    <title>Data</title>
    <summary>  The contribution of this article is a data concept that is essentially based
on the two concepts of information and computable functionality. In short, data
is viewed as typed information. A data type is defined as a pair of a set of
distinguishable characters (an alphabet) and a set of operations (computable
functions) that operate on this alphabet as domain. Two different ways of
subtyping in the sense of Liskov and Wing are described, one for restriction
and one for extension of existing types. They lead to two different partial
orders on types. It is argued that the proposed data concept matches the
concept of characteristics (Merkmale) of the automation industry.
</summary>
    <author>
      <name>Johannes Reich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Improved version</arxiv:comment>
    <link href="http://arxiv.org/abs/1801.04992v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.04992v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.08114v1</id>
    <updated>2018-01-24T18:30:22Z</updated>
    <published>2018-01-24T18:30:22Z</published>
    <title>Depending on Session-Typed Processes</title>
    <summary>  This work proposes a dependent type theory that combines functions and
session-typed processes (with value dependencies) through a contextual monad,
internalising typed processes in a dependently-typed lambda-calculus. The
proposed framework, by allowing session processes to depend on functions and
vice-versa, enables us to specify and statically verify protocols where the
choice of the next communication action can depend on specific values of
received data. Moreover, the type theoretic nature of the framework endows us
with the ability to internally describe and prove predicates on process
behaviours. Our main results are type soundness of the framework, and a
faithful embedding of the functional layer of the calculus within the
session-typed layer, showcasing the expressiveness of dependent session types.
</summary>
    <author>
      <name>Bernardo Toninho</name>
    </author>
    <author>
      <name>Nobuko Yoshida</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version</arxiv:comment>
    <link href="http://arxiv.org/abs/1801.08114v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.08114v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1801.10490v1</id>
    <updated>2018-01-31T15:28:30Z</updated>
    <published>2018-01-31T15:28:30Z</published>
    <title>Recognising and Generating Terms using Derivatives of Parsing Expression
  Grammars</title>
    <summary>  Grammar-based sentence generation has been thoroughly explored for
Context-Free Grammars (CFGs), but remains unsolved for recognition-based
approaches such as Parsing Expression Grammars (PEGs). Lacking tool support,
language designers using PEGs have difficulty predicting the behaviour of their
parsers. In this paper, we extend the idea of derivatives, originally
formulated for regular expressions, to PEGs. We then present a novel technique
for sentence generation based on derivatives, applicable to any grammatical
formalism for which the derivative can be defined--now including PEGs. Finally,
we propose applying derivatives more generally to other problems facing
language designers and implementers.
</summary>
    <author>
      <name>Tony Garnock-Jones</name>
    </author>
    <author>
      <name>Mahdi Eslamimehr</name>
    </author>
    <author>
      <name>Alessandro Warth</name>
    </author>
    <link href="http://arxiv.org/abs/1801.10490v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1801.10490v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1809.04151v1</id>
    <updated>2018-09-11T20:47:06Z</updated>
    <published>2018-09-11T20:47:06Z</published>
    <title>Feature-Specific Profiling</title>
    <summary>  While high-level languages come with significant readability and
maintainability benefits, their performance remains difficult to predict. For
example, programmers may unknowingly use language features inappropriately,
which cause their programs to run slower than expected. To address this issue,
we introduce feature-specific profiling, a technique that reports performance
costs in terms of linguistic constructs. Feature-specific profilers help
programmers find expensive uses of specific features of their language. We
describe the architecture of a profiler that implements our approach, explain
prototypes of the profiler for two languages with different characteristics and
implementation strategies, and provide empirical evidence for the approach's
general usefulness as a performance debugging tool.
</summary>
    <author>
      <name>Leif Andersen</name>
    </author>
    <author>
      <name>Vincent St-Amour</name>
    </author>
    <author>
      <name>Jan Vitek</name>
    </author>
    <author>
      <name>Matthias Felleisen</name>
    </author>
    <link href="http://arxiv.org/abs/1809.04151v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1809.04151v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PF" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1809.06336v1</id>
    <updated>2018-09-17T17:14:06Z</updated>
    <published>2018-09-17T17:14:06Z</published>
    <title>Verification of High-Level Transformations with Inductive Refinement
  Types</title>
    <summary>  High-level transformation languages like Rascal include expressive features
for manipulating large abstract syntax trees: first-class traversals,
expressive pattern matching, backtracking and generalized iterators. We present
the design and implementation of an abstract interpretation tool, Rabit, for
verifying inductive type and shape properties for transformations written in
such languages. We describe how to perform abstract interpretation based on
operational semantics, specifically focusing on the challenges arising when
analyzing the expressive traversals and pattern matching. Finally, we evaluate
Rabit on a series of transformations (normalization, desugaring, refactoring,
code generators, type inference, etc.) showing that we can effectively verify
stated properties.
</summary>
    <author>
      <name>Ahmad Salim Al-Sibahi</name>
    </author>
    <author>
      <name>Thomas P. Jensen</name>
    </author>
    <author>
      <name>Aleksandar S. Dimovski</name>
    </author>
    <author>
      <name>Andrzej Wasowski</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3278122.3278125</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3278122.3278125" rel="related"/>
    <link href="http://arxiv.org/abs/1809.06336v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1809.06336v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.00624v1</id>
    <updated>2018-11-01T20:23:48Z</updated>
    <published>2018-11-01T20:23:48Z</published>
    <title>User-Directed Loop-Transformations in Clang</title>
    <summary>  Directives for the compiler such as pragmas can help programmers to separate
an algorithm's semantics from its optimization. This keeps the code
understandable and easier to optimize for different platforms. Simple
transformations such as loop unrolling are already implemented in most
mainstream compilers. We recently submitted a proposal to add generalized loop
transformations to the OpenMP standard. We are also working on an
implementation in LLVM/Clang/Polly to show its feasibility and usefulness. The
current prototype allows applying patterns common to matrix-matrix
multiplication optimizations.
</summary>
    <author>
      <name>Michael Kruse</name>
    </author>
    <author>
      <name>Hal Finkel</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">LLVM-HPC Workshop 2018 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1811.00624v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.00624v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.06150v1</id>
    <updated>2018-11-15T02:51:29Z</updated>
    <published>2018-11-15T02:51:29Z</published>
    <title>Effect Handling for Composable Program Transformations in Edward2</title>
    <summary>  Algebraic effects and handlers have emerged in the programming languages
community as a convenient, modular abstraction for controlling computational
effects. They have found several applications including concurrent programming,
meta programming, and more recently, probabilistic programming, as part of
Pyro's Poutines library. We investigate the use of effect handlers as a
lightweight abstraction for implementing probabilistic programming languages
(PPLs). We interpret the existing design of Edward2 as an accidental
implementation of an effect-handling mechanism, and extend that design to
support nested, composable transformations. We demonstrate that this enables
straightforward implementation of sophisticated model transformations and
inference algorithms.
</summary>
    <author>
      <name>Dave Moore</name>
    </author>
    <author>
      <name>Maria I. Gorinova</name>
    </author>
    <link href="http://arxiv.org/abs/1811.06150v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.06150v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.CO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1811.09143v1</id>
    <updated>2018-11-22T12:47:18Z</updated>
    <published>2018-11-22T12:47:18Z</published>
    <title>Verifying C11 Programs Operationally</title>
    <summary>  This paper develops an operational semantics for a release-acquire fragment
of the C11 memory model with relaxed accesses. We show that the semantics is
both sound and complete with respect to the axiomatic model. The semantics
relies on a per-thread notion of observability, which allows one to reason
about a weak memory C11 program in program order. On top of this, we develop a
proof calculus for invariant-based reasoning, which we use to verify the
release-acquire version of Peterson's mutual exclusion algorithm.
</summary>
    <author>
      <name>Simon Doherty</name>
    </author>
    <author>
      <name>Brijesh Dongol</name>
    </author>
    <author>
      <name>Heike Wehrheim</name>
    </author>
    <author>
      <name>John Derrick</name>
    </author>
    <link href="http://arxiv.org/abs/1811.09143v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1811.09143v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.00089v1</id>
    <updated>2018-11-30T23:04:37Z</updated>
    <published>2018-11-30T23:04:37Z</published>
    <title>Parametric Denotational Semantics for Extensible Language Definition and
  Program Analysis</title>
    <summary>  We present a novel approach to construction of a formal semantics for a
programming language. Our approach, using a parametric denotational semantics,
allows the semantics to be easily extended to support new language features,
and abstracted to define program analyses. We apply this in analysing a
duck-typed, reflective, curried dynamic language. The benefits of this approach
include its terseness and modularity, and the ease with which one can gradually
build language features and analyses on top of a previous incarnation of a
semantics.
</summary>
    <author>
      <name>In-Ho Yi</name>
    </author>
    <link href="http://arxiv.org/abs/1812.00089v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.00089v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.04077v1</id>
    <updated>2018-12-07T02:49:49Z</updated>
    <published>2018-12-07T02:49:49Z</published>
    <title>BRISC-V Emulator: A Standalone, Installation-Free, Browser-Based
  Teaching Tool</title>
    <summary>  Many computer organization and computer architecture classes have recently
started adopting the RISC-V architecture as an alternative to proprietary RISC
ISAs and architectures. Emulators are a common teaching tool used to introduce
students to writing assembly. We present the BRISC-V (Boston University RISC-V)
Emulator and teaching tool, a RISC-V emulator inspired by existing RISC and
CISC emulators. The emulator is a web-based, pure javascript implementation
meant to simplify deployment, as it does not require maintaining support for
different operating systems or any installation. Here we present the workings,
usage, and extensibility of the BRISC-V emulator.
</summary>
    <author>
      <name>Mihailo Isakov</name>
    </author>
    <author>
      <name>Michel A. Kinsy</name>
    </author>
    <link href="http://arxiv.org/abs/1812.04077v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.04077v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.04125v1</id>
    <updated>2018-12-06T01:24:29Z</updated>
    <published>2018-12-06T01:24:29Z</published>
    <title>Yaps: Python Frontend to Stan</title>
    <summary>  Stan is a popular probabilistic programming language with a self-contained
syntax and semantics that is close to graphical models. Unfortunately, existing
embeddings of Stan in Python use multi-line strings. That approach forces users
to switch between two different language styles, with no support for syntax
highlighting or simple error reporting within the Stan code. This paper tackles
the question of whether Stan could use Python syntax while retaining its
self-contained semantics. The answer is yes, that can be accomplished by
reinterpreting the Python syntax. This paper introduces Yaps, a new frontend to
Stan based on reinterpreted Python. We tested Yaps on over a thousand Stan
models and made it available open-source.
</summary>
    <author>
      <name>Guillaume Baudart</name>
    </author>
    <author>
      <name>Martin Hirzel</name>
    </author>
    <author>
      <name>Kiran Kate</name>
    </author>
    <author>
      <name>Louis Mandel</name>
    </author>
    <author>
      <name>Avraham Shinnar</name>
    </author>
    <link href="http://arxiv.org/abs/1812.04125v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.04125v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.07439v1</id>
    <updated>2018-12-18T15:42:55Z</updated>
    <published>2018-12-18T15:42:55Z</published>
    <title>Automatic Alignment of Sequential Monte Carlo Inference in Higher-Order
  Probabilistic Programs</title>
    <summary>  Probabilistic programming is a programming paradigm for expressing flexible
probabilistic models. Implementations of probabilistic programming languages
employ a variety of inference algorithms, where sequential Monte Carlo methods
are commonly used. A problem with current state-of-the-art implementations
using sequential Monte Carlo inference is the alignment of program
synchronization points. We propose a new static analysis approach based on the
0-CFA algorithm for automatically aligning higher-order probabilistic programs.
We evaluate the automatic alignment on a phylogenetic model, showing a
significant decrease in runtime and increase in accuracy.
</summary>
    <author>
      <name>Daniel Lundén</name>
    </author>
    <author>
      <name>David Broman</name>
    </author>
    <author>
      <name>Fredrik Ronquist</name>
    </author>
    <author>
      <name>Lawrence M. Murray</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">19 pages, 10 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1812.07439v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.07439v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.08278v1</id>
    <updated>2018-12-19T22:37:59Z</updated>
    <published>2018-12-19T22:37:59Z</published>
    <title>Coroutines with Higher Order Functions</title>
    <summary>  Coroutines are non-preemptive concurrent subroutines that, unlike preemptive
threads, voluntarily transfer control between each others. Introduced in the
60s before loosing in popularity in the 80s, they have seen a regain of
interest in recent years, thanks to how elegantly they can solve numerous
algorithmic problems. Unfortunately, some mainstream languages still lack
support for coroutines, hence requiring either the use of non-standard
interpreter/compilers, or elaborate hacks in thrid-party libraries. In this
short paper, we propose a very simple way to implement coroutine-like
components on the top of any language that support or can emulate higher order
functions. We accompany our explanations with a handful of examples in
JavaScript.
</summary>
    <author>
      <name>Dimitri Racordon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">6 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/1812.08278v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.08278v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.09411v1</id>
    <updated>2018-12-21T23:26:07Z</updated>
    <published>2018-12-21T23:26:07Z</published>
    <title>Correct by construction</title>
    <summary>  Matrix code allows one to discover algorithms and to render them in code that
is both compilable and is correct by construction. In this way the difficulty
of verifying existing code is avoided. The method is especially important for
logically dense code and when precision programming is called for. The paper
explains both these concepts. Logically dense code is explained by means of the
partition stage of the Quicksort algorithm. Precision programming is explained
by means of fast exponentiation.
</summary>
    <author>
      <name>M. H. van Emden</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">16 pages, 4 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1812.09411v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.09411v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.4; D.2.3; D.2.4; D.2.10; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1812.11918v1</id>
    <updated>2018-12-21T20:41:20Z</updated>
    <published>2018-12-21T20:41:20Z</published>
    <title>Whittemore: An embedded domain specific language for causal programming</title>
    <summary>  This paper introduces Whittemore, a language for causal programming. Causal
programming is based on the theory of structural causal models and consists of
two primary operations: identification, which finds formulas that compute
causal queries, and estimation, which applies formulas to transform probability
distributions to other probability distribution. Causal programming provides
abstractions to declare models, queries, and distributions with syntax similar
to standard mathematical notation, and conducts rigorous causal inference,
without requiring detailed knowledge of the underlying algorithms. Examples of
causal inference with real data are provided, along with discussion of the
implementation and possibilities for future extension.
</summary>
    <author>
      <name>Joshua Brulé</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">7 pages, 6 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1812.11918v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1812.11918v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.ME" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.01906v1</id>
    <updated>2019-02-05T20:56:23Z</updated>
    <published>2019-02-05T20:56:23Z</published>
    <title>Fearless Concurrency? Understanding Concurrent Programming Safety in
  Real-World Rust Software</title>
    <summary>  Rust is a popular programming language in building various low-level software
in recent years. It aims to provide safe concurrency when implementing
multi-threaded software through a suite of compiler checking rules.
Unfortunately, there is limited understanding of how the checking rules
influence the safety of concurrent programming in Rust applications.
  In this paper, we perform a preliminary study on Rust's concurrency safety
from two aspects: concurrency usage and concurrency bugs. Our study can provide
better understanding on Rust's concurrency and can guide future researchers and
practitioners in writing better, more reliable Rust software and in developing
debugging and bug detection tools for Rust.
</summary>
    <author>
      <name>Zeming Yu</name>
    </author>
    <author>
      <name>Linhai Song</name>
    </author>
    <author>
      <name>Yiying Zhang</name>
    </author>
    <link href="http://arxiv.org/abs/1902.01906v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.01906v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1902.05283v1</id>
    <updated>2019-02-14T09:55:35Z</updated>
    <published>2019-02-14T09:55:35Z</published>
    <title>Reasoning About a Machine with Local Capabilities: Provably Safe Stack
  and Return Pointer Management - Technical Appendix Including Proofs and
  Details</title>
    <summary>  We propose a calling convention for capability machines with local
capabilities. The calling convention ensures local-state encapsulation and
well-bracketed control flow. We use the calling convention in a hand-full of
program examples and prove that they behave correctly. The correctness proofs
use a logical relation that is also presented in this appendix. This is the
technical appendix for the paper with the same name and authors accepted at
ESOP18 and under review for TOPLAS.
</summary>
    <author>
      <name>Lau Skorstengaard</name>
    </author>
    <author>
      <name>Dominique Devriese</name>
    </author>
    <author>
      <name>Lars Birkedal</name>
    </author>
    <link href="http://arxiv.org/abs/1902.05283v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1902.05283v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01009v1</id>
    <updated>2019-04-01T12:07:40Z</updated>
    <published>2019-04-01T12:07:40Z</published>
    <title>A benchmark for C program verification</title>
    <summary>  We present twenty-five C programs, as a benchmark for C program verification
using formal methods. This benchmark can be used for system demonstration, for
comparison of verification effort between systems, and as a friendly
competition. For this last purpose, we give a scoring formula that allows a
verification system to score up to a hundred points.
</summary>
    <author>
      <name>Marko van Eekelen</name>
    </author>
    <author>
      <name>Daniil Frumin</name>
    </author>
    <author>
      <name>Herman Geuvers</name>
    </author>
    <author>
      <name>Léon Gondelman</name>
    </author>
    <author>
      <name>Robbert Krebbers</name>
    </author>
    <author>
      <name>Marc Schoolderman</name>
    </author>
    <author>
      <name>Sjaak Smetsers</name>
    </author>
    <author>
      <name>Freek Verbeek</name>
    </author>
    <author>
      <name>Benoît Viguier</name>
    </author>
    <author>
      <name>Freek Wiedijk</name>
    </author>
    <link href="http://arxiv.org/abs/1904.01009v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01009v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01284v1</id>
    <updated>2019-04-02T08:44:24Z</updated>
    <published>2019-04-02T08:44:24Z</published>
    <title>FreeST: Context-free Session Types in a Functional Language</title>
    <summary>  FreeST is an experimental concurrent programming language. Based on a core
linear functional programming language, it features primitives to fork new
threads, and for channel creation and communication. A powerful type system of
context-free session types governs the interaction on channels. The compiler
builds on a novel algorithm for deciding type equivalence of context-free
session types. This abstract provides a gentle introduction to the language and
discusses the validation process and runtime system.
</summary>
    <author>
      <name>Bernardo Almeida</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciencias, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <author>
      <name>Andreia Mordido</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciencias, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <author>
      <name>Vasco T. Vasconcelos</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LASIGE, Faculdade de Ciencias, Universidade de Lisboa, Portugal</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.291.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.291.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2019, arXiv:1904.00396</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 291, 2019, pp. 12-23</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1904.01284v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01284v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.2; D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01286v1</id>
    <updated>2019-04-02T08:44:52Z</updated>
    <published>2019-04-02T08:44:52Z</published>
    <title>Concurrent Typestate-Oriented Programming in Java</title>
    <summary>  We describe a generative approach that enables concurrent typestate-oriented
programming in Java and other mainstream languages. The approach allows
programmers to implement objects exposing a state-sensitive interface using a
high-level synchronization abstraction that synchronizes methods with the
states of the receiver object in which those methods have an effect. An
external tool takes care of generating all the boilerplate code that implements
the synchronization logic. Behavioral types are used to specify object
protocols. The tool integrates protocol conformance verification with the
synchronization logic so that protocol violations are promptly detected at
runtime.
</summary>
    <author>
      <name>Rosita Gerbo</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <author>
      <name>Luca Padovani</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Università di Torino</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.291.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.291.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2019, arXiv:1904.00396</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 291, 2019, pp. 24-34</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1904.01286v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01286v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.01290v1</id>
    <updated>2019-04-02T08:47:53Z</updated>
    <published>2019-04-02T08:47:53Z</published>
    <title>A Message-Passing Interpretation of Adjoint Logic</title>
    <summary>  We present a system of session types based on adjoint logic which generalize
standard binary session types. Our system allows us to uniformly capture
several new behaviors in the space of asynchronous message-passing
communication, including multicast, where a process sends a single message to
multiple clients, replicable services, which have multiple clients and
replicate themselves on-demand to handle requests from those clients, and
cancellation, where a process discards a channel without communicating along
it. We provide session fidelity and deadlock-freedom results for this system,
from which we then derive a logically justified form of garbage collection.
</summary>
    <author>
      <name>Klaas Pruiksma</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <author>
      <name>Frank Pfenning</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.291.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.291.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2019, arXiv:1904.00396</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 291, 2019, pp. 60-79</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1904.01290v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.01290v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.03540v1</id>
    <updated>2019-04-06T22:09:53Z</updated>
    <published>2019-04-06T22:09:53Z</published>
    <title>Mek: Mechanics Prototyping Tool for 2D Tile-Based Turn-Based
  Deterministic Games</title>
    <summary>  There are few digital tools to help designers create game mechanics. A
general language to express game mechanics is necessary for rapid game design
iteration. The first iteration of a mechanics-focused language, together with
its interfacing tool, are introduced in this paper. The language is restricted
to two-dimensional, turn-based, tile-based, deterministic, complete-information
games. The tool is compared to the existing alternatives for game mechanics
prototyping and shown to be capable of succinctly implementing a range of
well-known game mechanics.
</summary>
    <author>
      <name>Rokas Volkovas</name>
    </author>
    <author>
      <name>Michael Fairbank</name>
    </author>
    <author>
      <name>John Woodward</name>
    </author>
    <author>
      <name>Simon Lucas</name>
    </author>
    <link href="http://arxiv.org/abs/1904.03540v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.03540v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.04371v1</id>
    <updated>2019-04-08T21:41:40Z</updated>
    <published>2019-04-08T21:41:40Z</published>
    <title>A HoTT Quantum Equational Theory (Extended Version)</title>
    <summary>  This paper presents an equational theory for the QRAM model of quantum
computation, formulated as an embedded language inside of homotopy type theory.
The embedded language approach is highly expressive, and reflects the style of
state-of-the art quantum languages like Quipper and QWIRE. The embedding takes
advantage of features of homotopy type theory to encode unitary transformations
as higher inductive paths, simplifying the presentation of an equational
theory. We prove that this equational theory is sound and complete with respect
to established models of quantum computation.
</summary>
    <author>
      <name>Jennifer Paykin</name>
    </author>
    <author>
      <name>Steve Zdancewic</name>
    </author>
    <link href="http://arxiv.org/abs/1904.04371v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.04371v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1904.06750v1</id>
    <updated>2019-04-14T20:08:04Z</updated>
    <published>2019-04-14T20:08:04Z</published>
    <title>From Theory to Systems: A Grounded Approach to Programming Language
  Education</title>
    <summary>  I present a new approach to teaching a graduate-level programming languages
course focused on using systems programming ideas and languages like
WebAssembly and Rust to motivate PL theory. Drawing on students' prior
experience with low-level languages, the course shows how type systems and PL
theory are used to avoid tricky real-world errors that students encounter in
practice. I reflect on the curricular design and lessons learned from two years
of teaching at Stanford, showing that integrating systems ideas can provide
students a more grounded and enjoyable education in programming languages. The
curriculum, course notes, and assignments are freely available:
http://cs242.stanford.edu/f18/
</summary>
    <author>
      <name>Will Crichton</name>
    </author>
    <link href="http://arxiv.org/abs/1904.06750v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1904.06750v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CY" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.04925v1</id>
    <updated>2019-06-12T07:40:55Z</updated>
    <published>2019-06-12T07:40:55Z</published>
    <title>Using Category Theory in Modeling Generics in OOP (Outline)</title>
    <summary>  Modeling generics in object-oriented programming languages such as Java and
C# is a challenge. Recently we proposed a new order-theoretic approach to
modeling generics. Given the strong relation between order theory and category
theory, in this extended abstract we present how also some tools from category
theory, such as adjunctions, monads and operads, are used in our approach to
modeling generics.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages (excluding references and an appendix). arXiv admin note:
  text overlap with arXiv:1906.03937</arxiv:comment>
    <link href="http://arxiv.org/abs/1906.04925v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.04925v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.10204v2</id>
    <updated>2019-06-26T07:11:51Z</updated>
    <published>2019-06-24T19:57:46Z</published>
    <title>Automatic verification of heap-manipulating programs</title>
    <summary>  Theoretical foundations of compositional reasoning about heaps in imperative
programming languages are investigated. We introduce a novel concept of
compositional symbolic memory and its relevant properties. We utilize these
formal foundations to build up a compositional algorithm that generates
generalized heaps, terms of symbolic heap calculus, which characterize
arbitrary cyclic code segments. All states inferred by this calculus precisely
correspond to reachable states of the original program. We establish the
correspondence between inference in this calculus and execution of pure
second-order functional programs.
</summary>
    <author>
      <name>Yurii Kostyukov</name>
    </author>
    <author>
      <name>Konstantin Batoev</name>
    </author>
    <author>
      <name>Dmitry Mordvinov</name>
    </author>
    <author>
      <name>Michael Kostitsyn</name>
    </author>
    <author>
      <name>Aleksandr Misonizhnik</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">44 pages, in Russian; to be published in Trudy ISP RAN/Proc. ISP RAS,
  2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1906.10204v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.10204v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.11197v1</id>
    <updated>2019-06-20T07:04:44Z</updated>
    <published>2019-06-20T07:04:44Z</published>
    <title>Java Generics: An Order-Theoretic Approach (Abridged Outline)</title>
    <summary>  The mathematical modeling of generics in Java and other similar
nominally-typed object-oriented programming languages is a challenge. In this
short paper we present the outline of a novel order-theoretic approach to
modeling generics, in which we also elementarily use some concepts and tools
from category theory. We believe a combined order-theoretic and
category-theoretic approach to modeling generics holds the keys to overcoming
much of the adversity found when analyzing features of generic OO type systems.
</summary>
    <author>
      <name>Moez A. AbdelGawad</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">5 pages excluding references. An abridged version of arXiv:1906.03937</arxiv:comment>
    <link href="http://arxiv.org/abs/1906.11197v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.11197v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.11606v1</id>
    <updated>2019-06-26T12:03:22Z</updated>
    <published>2019-06-26T12:03:22Z</published>
    <title>Structural Contracts -- Contracts for Type Construction &amp; Dependent
  Types to Ensure Consistency of Extra-Functional Reasoning</title>
    <summary>  Targeting to use contract-based design for the specification and refinement
of extra-functional properties, this research abstract suggests to use type
constraints and dependent types to ensure correct and consistent top-down
decomposition of contracts with respect to a specifiable type constructor. For
this, we summarize the composition problem and give a short draft of our
approach, called Structural Contracts.
</summary>
    <author>
      <name>Gregor Nitsche</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">4 pages, 2 figures, research abstract, submitted for acceptance at
  the Doctoral Symposium of 3. World Congress on Formal Methods (FM'19)</arxiv:comment>
    <link href="http://arxiv.org/abs/1906.11606v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.11606v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.11929v1</id>
    <updated>2019-06-27T19:37:49Z</updated>
    <published>2019-06-27T19:37:49Z</published>
    <title>Invariant Detection with Program Verification Tools</title>
    <summary>  Compilers can specialize programs having invariants for performance
improvement. Detecting program invariants that span large and complex code,
however, is difficult for compilers. Traditional compilers do not perform very
expensive analysis and thus only identify limited invariants, which limits the
potential of subsequent optimizations. We would like to address the invariant
detection problem via more sophisticated analyses using program verification
tools. In this paper, we reveal pitfalls of choosing program verification tools
for invariant detection, identify challenges of modeling program behavior using
one of these tools---CVC4, and propose some ideas about how to address the
challenges.
</summary>
    <author>
      <name>Wei He</name>
    </author>
    <link href="http://arxiv.org/abs/1906.11929v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.11929v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1906.12098v2</id>
    <updated>2019-08-09T12:55:26Z</updated>
    <published>2019-06-28T08:54:55Z</published>
    <title>Category-Theoretic Foundations of "STCLang: State Thread Composition as
  a Foundation for Monadic Dataflow Parallelism"</title>
    <summary>  This manuscript gives a category-theoretic foundation to the composition of
State Threads as a Foundation for Monadic Dataflow Parallelism. It serves as a
supplementary formalization of the concepts introduced in the Article "STCLang:
State Thread Composition as a Foundation for Monadic Dataflow Parallelism", as
published in Proceedings of the 12th ACM SIGPLAN International Symposium on
Haskell (Haskell'19).
</summary>
    <author>
      <name>Sebastian Ertel</name>
    </author>
    <author>
      <name>Justus Adam</name>
    </author>
    <author>
      <name>Norman A. Rink</name>
    </author>
    <author>
      <name>Andrés Goens</name>
    </author>
    <author>
      <name>Jeronimo Castrillon</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">11 Pages, Supplementary to article published in the Haskell'19
  Symposium</arxiv:comment>
    <link href="http://arxiv.org/abs/1906.12098v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1906.12098v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.02859v2</id>
    <updated>2020-04-02T22:57:41Z</updated>
    <published>2019-07-02T13:59:49Z</published>
    <title>GTIRB: Intermediate Representation for Binaries</title>
    <summary>  GTIRB is an intermediate representation for binary analysis and rewriting
tools including disassemblers, lifters, analyzers, rewriters, and
pretty-printers. GTIRB is designed to enable communication between tools in a
format that provides the basic information necessary for analysis and rewriting
while making no further assumptions about domain (e.g., malware vs. cleanware,
or PE vs. ELF) or semantic interpretation (functional vs. operational
semantics). This design supports the goals of (1) encouraging tool
modularization and re-use allowing researchers and developers to focus on a
single aspect of binary analysis and rewriting without committing to any single
tool chain and (2) facilitating communication and comparison between tools.
</summary>
    <author>
      <name>Eric Schulte</name>
    </author>
    <author>
      <name>Jonathan Dorn</name>
    </author>
    <author>
      <name>Antonio Flores-Montoya</name>
    </author>
    <author>
      <name>Aaron Ballman</name>
    </author>
    <author>
      <name>Tom Johnson</name>
    </author>
    <link href="http://arxiv.org/abs/1907.02859v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.02859v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.02952v1</id>
    <updated>2019-07-05T17:38:17Z</updated>
    <published>2019-07-05T17:38:17Z</published>
    <title>Solidity 0.5: when typed does not mean type safe</title>
    <summary>  The recent release of Solidity 0.5 introduced a new type to prevent Ether
transfers to smart contracts that are not supposed to receive money.
Unfortunately, the compiler fails in enforcing the guarantees this type
intended to convey, hence the type soundness of Solidity 0.5 is no better than
that of Solidity 0.4. In this paper we discuss a paradigmatic example showing
that vulnerable Solidity patterns based on potentially unsafe callback
expressions are still unchecked. We also point out a solution that strongly
relies on formal methods to support a type-safer smart contracts programming
discipline, while being retro-compatible with legacy Solidity code.
</summary>
    <author>
      <name>Silvia Crafa</name>
    </author>
    <author>
      <name>Matteo Di Pirro</name>
    </author>
    <link href="http://arxiv.org/abs/1907.02952v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.02952v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.03105v1</id>
    <updated>2019-07-06T09:58:55Z</updated>
    <published>2019-07-06T09:58:55Z</published>
    <title>Constraint-Based Type-Directed Program Synthesis</title>
    <summary>  We explore an approach to type-directed program synthesis rooted in
constraint-based type inference techniques. By doing this, we aim to more
efficiently synthesize polymorphic code while also tackling advanced typing
features such as GADTs that build upon polymorphism. Along the way, we also
present an implementation of these techniques in Scythe, a prototype live,
type-directed programming tool for the Haskell programming language and reflect
on our initial experience with the tool.
</summary>
    <author>
      <name>Peter-Michael Osera</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Extended version of report that appeared in TyDe 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1907.03105v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.03105v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.05649v1</id>
    <updated>2019-07-12T09:53:03Z</updated>
    <published>2019-07-12T09:53:03Z</published>
    <title>Augmenting Type Signatures for Program Synthesis</title>
    <summary>  Effective program synthesis requires a way to minimise the number of
candidate programs being searched. A type signature, for example, places some
small restrictions on the structure of potential candidates. We introduce and
motivate a distilled program synthesis problem where a type signature is the
only machine-readable information available, but does not sufficiently minimise
the search space. To address this, we develop a system of property relations
that can be used to flexibly encode and query information that was not
previously available to the synthesiser. Our experience using these tools has
been positive: by encoding simple properties and by using a minimal set of
synthesis primitives, we have been able to synthesise complex programs in novel
contexts
</summary>
    <author>
      <name>Bruce Collie</name>
    </author>
    <author>
      <name>Michael O'Boyle</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">TyDe 2019 Extended Abstract</arxiv:comment>
    <link href="http://arxiv.org/abs/1907.05649v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.05649v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.05818v1</id>
    <updated>2019-07-12T16:13:03Z</updated>
    <published>2019-07-12T16:13:03Z</published>
    <title>Verified Self-Explaining Computation</title>
    <summary>  Common programming tools, like compilers, debuggers, and IDEs, crucially rely
on the ability to analyse program code to reason about its behaviour and
properties. There has been a great deal of work on verifying compilers and
static analyses, but far less on verifying dynamic analyses such as program
slicing. Recently, a new mathematical framework for slicing was introduced in
which forward and backward slicing are dual in the sense that they constitute a
Galois connection. This paper formalises forward and backward dynamic slicing
algorithms for a simple imperative programming language, and formally verifies
their duality using the Coq proof assistant.
</summary>
    <author>
      <name>Jan Stolarek</name>
    </author>
    <author>
      <name>James Cheney</name>
    </author>
    <link href="http://arxiv.org/abs/1907.05818v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.05818v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.06522v1</id>
    <updated>2019-07-15T14:32:52Z</updated>
    <published>2019-07-15T14:32:52Z</published>
    <title>A Relational Static Semantics for Call Graph Construction</title>
    <summary>  The problem of resolving virtual method and interface calls in
object-oriented languages has been a long standing challenge to the program
analysis community. The complexities are due to various reasons, such as
increased levels of class inheritance and polymorphism in large programs. In
this paper, we propose a new approach called type flow analysis that represent
propagation of type information between program variables by a group of
relations without the help of a heap abstraction. We prove that regarding the
precision on reachability of class information to a variable, our method
produces results equivalent to that one can derive from a points-to analysis.
Moreover, in practice, our method consumes lower time and space usage, as
supported by the experimental results.
</summary>
    <author>
      <name>Xilong Zhuo</name>
    </author>
    <author>
      <name>Chenyi Zhang</name>
    </author>
    <link href="http://arxiv.org/abs/1907.06522v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.06522v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.08834v1</id>
    <updated>2019-07-20T16:39:06Z</updated>
    <published>2019-07-20T16:39:06Z</published>
    <title>Towards meta-interpretive learning of programming language semantics</title>
    <summary>  We introduce a new application for inductive logic programming: learning the
semantics of programming languages from example evaluations. In this short
paper, we explored a simplified task in this domain using the Metagol
meta-interpretive learning system. We highlighted the challenging aspects of
this scenario, including abstracting over function symbols, nonterminating
examples, and learning non-observed predicates, and proposed extensions to
Metagol helpful for overcoming these challenges, which may prove useful in
other domains.
</summary>
    <author>
      <name>Sándor Bartha</name>
    </author>
    <author>
      <name>James Cheney</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ILP 2019, to appear</arxiv:comment>
    <link href="http://arxiv.org/abs/1907.08834v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.08834v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1907.11133v1</id>
    <updated>2019-07-25T15:17:27Z</updated>
    <published>2019-07-25T15:17:27Z</published>
    <title>An Introduction to Logical Relations</title>
    <summary>  Logical relations (LR) have been around for many years, and today they are
used in many formal results. However, it can be difficult to LR beginners to
find a good place to start to learn. Papers often use highly specialized LRs
that use the latest advances of the technique which makes it impossible to make
a proper presentation within the page limit.
  This note is a good starting point for beginners that want to learn about
LRs. Almost no prerequisite knowledge is assumed, and the note starts from the
very basics. The note covers the following: LRs for proving normalization and
type safety of simply typed lambda calculus, relational substitutions for
reasoning about universal and existential types, step-indexing for reasoning
about recursive types, and worlds for reasoning about references.
</summary>
    <author>
      <name>Lau Skorstengaard</name>
    </author>
    <link href="http://arxiv.org/abs/1907.11133v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1907.11133v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.02375v1</id>
    <updated>2019-10-06T05:06:38Z</updated>
    <published>2019-10-06T05:06:38Z</published>
    <title>Design and Use of Loop-Transformation Pragmas</title>
    <summary>  Adding a pragma directive into the source code is arguably easier than
rewriting it, for instance for loop unrolling. Moreover, if the application is
maintained for multiple platforms, their difference in performance
characteristics may require different code transformations. Code transformation
directives allow replacing the directives depending on the platform, i.e.
separation of code semantics and its performance optimization.
  In this paper, we explore the design space (syntax and semantics) of adding
such directive into a future OpenMP specification. Using a prototype
implementation in Clang, we demonstrate the usefulness of such directives on a
few benchmarks.
</summary>
    <author>
      <name>Michael Kruse</name>
    </author>
    <author>
      <name>Hal Finkel</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-28596-8_9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-28596-8_9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IWOMP 2019, September 11-13, Auckland, preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.02375v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.02375v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.03784v2</id>
    <updated>2019-11-26T19:26:09Z</updated>
    <published>2019-10-09T04:15:18Z</published>
    <title>Generalized Property-Directed Reachability for Hybrid Systems</title>
    <summary>  Generalized property-directed reachability (GPDR) belongs to the family of
the model-checking techniques called IC3/PDR. It has been successfully applied
to software verification; for example, it is the core of Spacer, a
state-of-the-art Horn-clause solver bundled with Z3. However, it has yet to be
applied to hybrid systems, which involve a continuous evolution of values over
time. As the first step towards GPDR- based model checking for hybrid systems,
this paper formalizes HGPDR, an adaptation of GPDR to hybrid systems, and
proves its soundness. We also implemented a semi-automated proof-of-concept
verifier, which allows a user to provide hints to guide verification steps.
</summary>
    <author>
      <name>Kohei Suenaga</name>
    </author>
    <author>
      <name>Takuya Ishizawa</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in VMCAI 2020</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.03784v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.03784v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.09579v2</id>
    <updated>2021-03-01T21:12:23Z</updated>
    <published>2019-10-21T18:12:46Z</published>
    <title>Transparent Synchronous Dataflow</title>
    <summary>  Dataflow programming is a popular and convenient programming paradigm in
systems modelling, optimisation, and machine learning. It has a number of
advantages, for instance the lacks of control flow allows computation to be
carried out in parallel as well as in distributed machines. More recently the
idea of dataflow graphs has also been brought into the design of various deep
learning frameworks. They facilitate an easy and efficient implementation of
automatic differentiation, which is the heart of modern deep learning paradigm.
[abstract abridged]
</summary>
    <author>
      <name>Steven W. T. Cheung</name>
    </author>
    <author>
      <name>Dan R. Ghica</name>
    </author>
    <author>
      <name>Koko Muroya</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.22152/programming-journal.org/2021/5/12</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.22152/programming-journal.org/2021/5/12" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">The Art, Science, and Engineering of Programming, 2021, Vol. 5,
  Issue 3, Article 12</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1910.09579v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.09579v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.09744v2</id>
    <updated>2020-07-22T21:36:15Z</updated>
    <published>2019-10-22T03:06:11Z</published>
    <title>Decidable Synthesis of Programs with Uninterpreted Functions</title>
    <summary>  We identify a decidable synthesis problem for a class of programs of
unbounded size with conditionals and iteration that work over infinite data
domains. The programs in our class use uninterpreted functions and relations,
and abide by a restriction called coherence that was recently identified to
yield decidable verification. We formulate a powerful grammar-restricted
(syntax-guided) synthesis problem for coherent uninterpreted programs, and we
show the problem to be decidable, identify its precise complexity, and also
study several variants of the problem.
</summary>
    <author>
      <name>Paul Krogmeier</name>
    </author>
    <author>
      <name>Umang Mathur</name>
    </author>
    <author>
      <name>Adithya Murali</name>
    </author>
    <author>
      <name>P. Madhusudan</name>
    </author>
    <author>
      <name>Mahesh Viswanathan</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-53291-8_32</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-53291-8_32" rel="related"/>
    <link href="http://arxiv.org/abs/1910.09744v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.09744v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.10421v1</id>
    <updated>2019-10-23T09:10:56Z</updated>
    <published>2019-10-23T09:10:56Z</published>
    <title>Towards a Complete Picture of Lens Laws</title>
    <summary>  Bidirectional transformation, also called lens, has played important roles in
maintaining consistency in many fields of applications. A lens is specified by
a pair of forward and backward functions which relate to each other in a
consistent manner. The relation is formalized as a set of equations called lens
laws. This report investigates precise dependencies among lens laws: which law
implies another and which combination of laws implies another. The set of such
implications forms a complicated graph structure. It would be helpful to check
a well-definedness of bidirectional transformation in a lightweight way.
</summary>
    <author>
      <name>Keisuke Nakano</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the Third Workshop on Software Foundations for Data
  Interoperability (SFDI2019+), October 28, 2019, Fukuoka, Japan</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.10421v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.10421v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.11629v2</id>
    <updated>2020-04-18T20:26:57Z</updated>
    <published>2019-10-25T11:37:35Z</published>
    <title>Runners in action</title>
    <summary>  Runners of algebraic effects, also known as comodels, provide a mathematical
model of resource management. We show that they also give rise to a programming
concept that models top-level external resources, as well as allows programmers
to modularly define their own intermediate "virtual machines". We capture the
core ideas of programming with runners in an equational calculus
$\lambda_{\mathsf{coop}}$, which we equip with a sound and coherent
denotational semantics that guarantees the linear use of resources and
execution of finalisation code. We accompany $\lambda_{\mathsf{coop}}$ with
examples of runners in action, provide a prototype language implementation in
OCaml, as well as a Haskell library based on $\lambda_{\mathsf{coop}}$.
</summary>
    <author>
      <name>Danel Ahman</name>
    </author>
    <author>
      <name>Andrej Bauer</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-44914-8_2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-44914-8_2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">ESOP 2020 final version + online appendix</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.11629v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.11629v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.11717v2</id>
    <updated>2019-10-28T14:53:56Z</updated>
    <published>2019-10-25T13:31:21Z</published>
    <title>Selective Lambda Lifting</title>
    <summary>  Lambda lifting is a well-known transformation, traditionally employed for
compiling functional programs to supercombinators. However, more recent
abstract machines for functional languages like OCaml and Haskell tend to do
closure conversion instead for direct access to the environment, so lambda
lifting is no longer necessary to generate machine code. We propose to revisit
selective lambda lifting in this context as an optimising code generation
strategy and conceive heuristics to identify beneficial lifting opportunities.
We give a static analysis for estimating impact on heap allocations of a
lifting decision. Performance measurements of our implementation within the
Glasgow Haskell Compiler on a large corpus of Haskell benchmarks suggest modest
speedups.
</summary>
    <author>
      <name>Sebastian Graf</name>
    </author>
    <author>
      <name>Simon Peyton Jones</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Rejected from ICFP 2019</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.11717v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.11717v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.11724v1</id>
    <updated>2019-10-25T13:41:13Z</updated>
    <published>2019-10-25T13:41:13Z</published>
    <title>Embracing a mechanized formalization gap</title>
    <summary>  If a code base is so big and complicated that complete mechanical
verification is intractable, can we still apply and benefit from verification
methods? We show that by allowing a deliberate mechanized formalization gap we
can shrink and simplify the model until it is manageable, while still retaining
a meaningful, declaratively documented connection to the original, unmodified
source code. Concretely, we translate core parts of the Haskell compiler GHC
into Coq, using hs-to-coq, and verify invariants related to the use of term
variables.
</summary>
    <author>
      <name>Antal Spector-Zabusky</name>
    </author>
    <author>
      <name>Joachim Breitner</name>
    </author>
    <author>
      <name>Yao Li</name>
    </author>
    <author>
      <name>Stephanie Weirich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to CPP'20</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.11724v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.11724v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1910.12272v1</id>
    <updated>2019-10-27T14:45:17Z</updated>
    <published>2019-10-27T14:45:17Z</published>
    <title>Declarative Semantics of the Hybrid Constraint Language HydLa</title>
    <summary>  Hybrid systems are dynamical systems with continuous evolution of states and
discrete evolution of states and governing equations. We have worked on the
design and implementation of HydLa, a constraint-based modeling language for
hybrid systems, with a view to the proper handling of uncertainties and the
integration of simulation and verification. HydLa's constraint hierarchies
facilitate the description of constraints with adequate strength, but its
semantical foundations are not obvious due to the interaction of various
language constructs. This paper gives the declarative semantics of HydLa and
discusses its properties and consequences by means of examples.
</summary>
    <author>
      <name>Kazunori Ueda</name>
    </author>
    <author>
      <name>Hiroshi Hosobe</name>
    </author>
    <author>
      <name>Daisuke Ishii</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages, 3 figures. This is an English translation of the paper that
  originally appeared in Computer Software, Vol.28, No.1 (2011), pp.306-311,
  doi:10.11309/jssst.28.1_306</arxiv:comment>
    <link href="http://arxiv.org/abs/1910.12272v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1910.12272v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.03584v1</id>
    <updated>2019-12-08T01:05:17Z</updated>
    <published>2019-12-08T01:05:17Z</published>
    <title>Formalizing Event-Driven Behavior of Serverless Applications</title>
    <summary>  We present new operational semantics for serverless computing that model the
event-driven relationships between serverless functions, as well as their
interaction with platforms services such as databases and object stores. These
semantics precisely encapsulate how control transfers between functions, both
directly and through reads and writes to platform services. We use these
semantics to define the notion of the service call graph for serverless
applications that captures program flows through functions and services.
Finally, we construct service call graphs for twelve serverless JavaScript
applications, using a prototype of our call graph construction algorithm, and
we evaluate their accuracy.
</summary>
    <author>
      <name>Matthew Obetz</name>
    </author>
    <author>
      <name>Stacy Patterson</name>
    </author>
    <author>
      <name>Ana Milanova</name>
    </author>
    <link href="http://arxiv.org/abs/1912.03584v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.03584v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.03854v1</id>
    <updated>2019-12-09T05:05:07Z</updated>
    <published>2019-12-09T05:05:07Z</published>
    <title>Variability-aware Datalog</title>
    <summary>  Variability-aware computing is the efficient application of programs to
different sets of inputs that exhibit some variability. One example is program
analyses applied to Software Product Lines (SPLs). In this paper we present the
design and development of a variability-aware version of the Souffl\'{e}
Datalog engine. The engine can take facts annotated with Presence Conditions
(PCs) as input, and compute the PCs of its inferred facts, eliminating facts
that do not exist in any valid configuration. We evaluate our variability-aware
Souffl\'{e} implementation on several fact sets annotated with PCs to measure
the associated overhead in terms of processing time and database size.
</summary>
    <author>
      <name>Ramy Shahin</name>
    </author>
    <author>
      <name>Marsha Chechik</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-39197-3_14</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-39197-3_14" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">PADL'20 paper</arxiv:comment>
    <link href="http://arxiv.org/abs/1912.03854v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.03854v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.09770v2</id>
    <updated>2020-05-26T10:11:02Z</updated>
    <published>2019-12-20T11:31:28Z</published>
    <title>CacheQuery: Learning Replacement Policies from Hardware Caches</title>
    <summary>  We show how to infer deterministic cache replacement policies using
off-the-shelf automata learning and program synthesis techniques. For this, we
construct and chain two abstractions that expose the cache replacement policy
of any set in the cache hierarchy as a membership oracle to the learning
algorithm, based on timing measurements on a silicon CPU. Our experiments
demonstrate an advantage in scope and scalability over prior art and uncover 2
previously undocumented cache replacement policies.
</summary>
    <author>
      <name>Pepe Vila</name>
    </author>
    <author>
      <name>Pierre Ganty</name>
    </author>
    <author>
      <name>Marco Guarnieri</name>
    </author>
    <author>
      <name>Boris Köpf</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages, 5 tables, 5 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/1912.09770v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.09770v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.10135v1</id>
    <updated>2019-12-20T22:59:39Z</updated>
    <published>2019-12-20T22:59:39Z</published>
    <title>QuB: A Resource Aware Functional Programming Language</title>
    <summary>  Managing resources---file handles, database connections, etc.---is a hard
problem. Debugging resource leaks and runtime errors due to resource
mismanagement are difficult in evolving production code. Programming languages
with static type systems are great tools to ensure erroneous code is detected
at compile time. However, modern static type systems do little in the aspect of
resource management as resources are treated as normal values. We propose a
type system, Qub, based on the logic of bunched implications (BI) which models
resources as first class citizens. We distinguish two kinds of program
objects---restricted and unrestricted---and two kinds of functions---sharing
and separating. Our approach guarantees resource correctness without
compromising existing functional abstractions.
</summary>
    <author>
      <name>Apoorv Ingle</name>
    </author>
    <link href="http://arxiv.org/abs/1912.10135v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.10135v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.10631v1</id>
    <updated>2019-12-23T05:40:43Z</updated>
    <published>2019-12-23T05:40:43Z</published>
    <title>A Component-Based Formal Language Workbench</title>
    <summary>  The CBS framework supports component-based specification of programming
languages. It aims to significantly reduce the effort of formal language
specification, and thereby encourage language developers to exploit formal
semantics more widely. CBS provides an extensive library of reusable language
specification components, facilitating co-evolution of languages and their
specifications.
  After introducing CBS and its formal definition, this short paper reports
work in progress on generating an IDE for CBS from the definition. It also
considers the possibility of supporting component-based language specification
in other formal language workbenches.
</summary>
    <author>
      <name>Peter D. Mosses</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.310.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.310.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings F-IDE 2019, arXiv:1912.09611</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 310, 2019, pp. 29-34</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/1912.10631v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.10631v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.2.6; D.2.13; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/1912.10817v2</id>
    <updated>2021-04-23T10:40:40Z</updated>
    <published>2019-12-17T18:24:17Z</published>
    <title>Using Prolog for Transforming XML Documents</title>
    <summary>  Proponents of the programming language Prolog share the opinion Prolog is
more appropriate for transforming XML-documents as other well-established
techniques and languages like XSLT. In order to clarify this position this work
proposes a tuProlog-styled interpreter for parsing XML-documents into
Prolog-internal lists and vice versa for serialising lists into XML-documents.
Based on this implementation a comparison between XSLT and Prolog follows.
First, criteria are researched, such as considered language features of XSLT,
usability and expressibility. These criteria are validated. Second, it is
assessed when Prolog distinguishes between input and output parameters towards
reversible transformation.
</summary>
    <author>
      <name>René Haberland</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">49 pages, 54 figures, 2 appendices</arxiv:comment>
    <link href="http://arxiv.org/abs/1912.10817v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/1912.10817v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.IR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.02933v1</id>
    <updated>2020-08-07T01:23:29Z</updated>
    <published>2020-08-07T01:23:29Z</published>
    <title>Prolog for Verification, Analysis and Transformation Tools</title>
    <summary>  This article examines the use of the Prolog language for writing
verification, analysis and transformation tools. Guided by experience in
teaching and the development of verification tools like ProB or specialisation
tools like ECCE and LOGEN, the article presents an assessment of various
aspects of Prolog and provides guidelines for using them. The article shows the
usefulness of a few key Prolog features. In particular, it discusses how to
deal with negation at the level of the object programs being verified or
analysed.
</summary>
    <author>
      <name>Michael Leuschel</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Düsseldorf</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.320.6</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.320.6" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT/HCVS 2020, arXiv:2008.02483</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 320, 2020, pp. 80-94</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2008.02933v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.02933v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.04669v1</id>
    <updated>2020-08-07T01:24:07Z</updated>
    <published>2020-08-07T01:24:07Z</published>
    <title>Optimizing Program Size Using Multi-result Supercompilation</title>
    <summary>  Supercompilation is a powerful program transformation technique with numerous
interesting applications. Existing methods of supercompilation, however, are
often very unpredictable with respect to the size of the resulting programs. We
consider an approach for controlling result size, based on a combination of
multi-result supercompilation and a specific generalization strategy, which
avoids code duplication. The current early experiments with this method show
promising results - we can keep the size of the result small, while still
performing powerful optimizations.
</summary>
    <author>
      <name>Dimitur Nikolaev Krustev</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IGE+XAO Balkan</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.320.9</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.320.9" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT/HCVS 2020, arXiv:2008.02483. arXiv admin note:
  identical to arXiv:2006.02204, which has added appendices</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 320, 2020, pp. 125-139</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2008.04669v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.04669v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.04720v1</id>
    <updated>2020-08-11T14:27:22Z</updated>
    <published>2020-08-11T14:27:22Z</published>
    <title>Backjumping is Exception Handling</title>
    <summary>  ISO Prolog provides catch and throw to realise the control flow of exception
handling. This pearl demonstrates that catch and throw are inconspicuously
amenable to the implementation of backjumping. In fact, they have precisely the
semantics required: rewinding the search to a specific point, and carrying of a
preserved term to that point. The utility of these properties is demonstrated
through an implementation of graph colouring with backjumping and a backjumping
SAT solver that applies Conflict Driven Clause Learning.
</summary>
    <author>
      <name>Ed Robbins</name>
    </author>
    <author>
      <name>Andy King</name>
    </author>
    <author>
      <name>Jacob M. Howe</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S1471068420000435</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S1471068420000435" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Theory and Practice of Logic Programming 21 (2021) 125-144</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2008.04720v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.04720v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.07901v1</id>
    <updated>2020-08-15T14:28:46Z</updated>
    <published>2020-08-15T14:28:46Z</published>
    <title>LPOP: Challenges and Advances in Logic and Practice of Programming</title>
    <summary>  This article describes the work presented at the first Logic and Practice of
Programming (LPOP) Workshop, which was held in Oxford, UK, on July 18, 2018, in
conjunction with the Federated Logic Conference (FLoC) 2018. Its focus is
challenges and advances in logic and practice of programming. The workshop was
organized around a challenge problem that specifies issues in role-based access
control (RBAC), with many participants proposing combined imperative and
declarative solutions expressed in the languages of their choice.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">arXiv admin note: substantial text overlap with arXiv:1804.10247 by
  other authors</arxiv:comment>
    <link href="http://arxiv.org/abs/2008.07901v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.07901v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.09610v3</id>
    <updated>2022-02-07T17:59:08Z</updated>
    <published>2020-08-21T08:24:26Z</published>
    <title>Implementing backjumping by throw/1 and catch/3 of Prolog</title>
    <summary>  We discuss how to implement backjumping (or intelligent backtracking) in
Prolog programs by means of exception handling. This seems impossible in a
general case. We provide two solutions. One works for binary programs; in a
general case it imposes a restriction on where backjumping may originate. The
other restricts a class of backjump targets. We also show how to simulate
backjumping by means of backtracking and the Prolog database.
</summary>
    <author>
      <name>Włodzimierz Drabent</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">10 pages. This version - extensions and corrections</arxiv:comment>
    <link href="http://arxiv.org/abs/2008.09610v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.09610v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N17" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6; I.2.8; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.13358v1</id>
    <updated>2020-08-31T04:34:53Z</updated>
    <published>2020-08-31T04:34:53Z</published>
    <title>Substructural Observed Communication Semantics</title>
    <summary>  Session-types specify communication protocols for communicating processes,
and session-typed languages are often specified using substructural operational
semantics given by multiset rewriting systems. We give an observed
communication semantics for a session-typed language with recursion, where a
process's observation is given by its external communications. To do so, we
introduce fair executions for multiset rewriting systems, and extract observed
communications from fair process executions. This semantics induces an
intuitively reasonable notion of observational equivalence that we conjecture
coincides with semantic equivalences induced by denotational semantics,
bisimulations, and barbed congruences for these languages.
</summary>
    <author>
      <name>Ryan Kavanagh</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.322.7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.322.7" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS 2020, arXiv:2008.12414</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 322, 2020, pp. 69-87</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2008.13358v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.13358v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2008.13460v1</id>
    <updated>2020-08-31T09:57:19Z</updated>
    <published>2020-08-31T09:57:19Z</published>
    <title>Constraint-Logic Object-Oriented Programming with Free Arrays</title>
    <summary>  Constraint-logic object-oriented programming provides a useful symbiosis
between object-oriented programming and constraint-logic search. The ability to
use logic variables, constraints, non-deterministic search, and object-oriented
programming in an integrated way facilitates the combination of search-related
program parts and other business logic in object-oriented applications. With
this work we conceptualize array-typed logic variables ("free arrays"), thus
completing the set of types that logic variables can assume in constraint-logic
object-oriented programming. Free arrays exhibit interesting properties, such
as indeterminate lengths and non-deterministic accesses to array elements.
</summary>
    <author>
      <name>Jan C. Dageförde</name>
    </author>
    <author>
      <name>Herbert Kuchen</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Part of WFLP 2020 pre-proceedings</arxiv:comment>
    <link href="http://arxiv.org/abs/2008.13460v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2008.13460v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2012.10086v1</id>
    <updated>2020-12-18T07:27:23Z</updated>
    <published>2020-12-18T07:27:23Z</published>
    <title>Program Analysis (an Appetizer)</title>
    <summary>  This book is an introduction to program analysis that is meant to be
considerably more elementary than our advanced book Principles of Program
Analysis (Springer, 2005). Rather than using flow charts as the model of
programs, the book follows our introductory book Formal Methods an Appetizer
(Springer, 2019) using program graphs as the model of programs. In our
experience this makes the underlying ideas more accessible to our computer
science and computer engineering students on the master course 02242: Program
Analysis at The Technical University of Denmark. Here we have gradually
replaced our use of the more elementary parts of Principles of Program Analysis
with material from the current book.
</summary>
    <author>
      <name>Flemming Nielson</name>
    </author>
    <author>
      <name>Hanne Riis Nielson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">208 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2012.10086v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2012.10086v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.06759v1</id>
    <updated>2021-01-17T19:38:54Z</updated>
    <published>2021-01-17T19:38:54Z</published>
    <title>Proceedings of the 2020 Scheme and Functional Programming Workshop</title>
    <summary>  This report aggregates the papers presented at the twenty-first annual Scheme
and Functional Programming Workshop, hosted on August 28th, 2020, online and
co-located with the twenty-fifth International Conference on Functional
Programming. The Scheme and Functional Programming Workshop is held every year
to provide an opportunity for researchers and practitioners using Scheme and
related functional programming languages like Racket, Clojure, and Lisp, to
share research findings and discuss the future of the Scheme programming
language.
</summary>
    <author>
      <name>Baptiste Saleil</name>
    </author>
    <author>
      <name>Michael D. Adams</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">85 pages; 30 figures; workshop website at
  https://icfp20.sigplan.org/home/scheme-2020</arxiv:comment>
    <link href="http://arxiv.org/abs/2101.06759v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.06759v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.m" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.09408v1</id>
    <updated>2021-01-23T03:17:31Z</updated>
    <published>2021-01-23T03:17:31Z</published>
    <title>Equational reasoning for non-determinism monad: the case of Spark
  aggregation</title>
    <summary>  As part of the author's studies on equational reasoning for monadic programs,
this report focus on non-determinism monad.
  We discuss what properties this monad should satisfy, what additional
operators and notations can be introduced to facilitate equational reasoning
about non-determinism, and put them to the test by proving a number of
properties in our example problem inspired by the author's previous work on
proving properties of Spark aggregation.
</summary>
    <author>
      <name>Shin-Cheng Mu</name>
    </author>
    <link href="http://arxiv.org/abs/2101.09408v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.09408v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.09409v1</id>
    <updated>2021-01-23T03:27:20Z</updated>
    <published>2021-01-23T03:27:20Z</published>
    <title>Calculating a backtracking algorithm: an exercise in monadic program
  derivation</title>
    <summary>  Equational reasoning is among the most important tools that functional
programming provides us. Curiously, relatively less attention has been paid to
reasoning about monadic programs.
  In this report we derive a backtracking algorithm for problem specifications
that use a monadic unfold to generate possible solutions, which are filtered
using a $\mathit{scanl}$-like predicate. We develop theorems that convert a
variation of $\mathit{scanl}$ to a $\mathit{foldr}$ that uses the state monad,
as well as theorems constructing hylomorphism. The algorithm is used to solve
the $n$-queens puzzle, our running example. The aim is to develop theorems and
patterns useful for the derivation of monadic programs, focusing on the
intricate interaction between state and non-determinism.
</summary>
    <author>
      <name>Shin-Cheng Mu</name>
    </author>
    <link href="http://arxiv.org/abs/2101.09409v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.09409v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.09699v2</id>
    <updated>2021-08-21T09:57:50Z</updated>
    <published>2021-01-24T12:20:27Z</published>
    <title>Longest segment of balanced parentheses -- an exercise in program
  inversion in a segment problem (Functional Pearl)</title>
    <summary>  Given a string of parentheses, the task is to find the longest consecutive
segment that is balanced, in linear time. We find this problem interesting
because it involves a combination of techniques: the usual approach for solving
segment problems, and a theorem for constructing the inverse of a function --
through which we derive an instance of shift-reduce parsing.
</summary>
    <author>
      <name>Shin-Cheng Mu</name>
    </author>
    <author>
      <name>Tsung-Ju Chiang</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0956796821000253</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0956796821000253" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Functional Programming , Volume 31 , 2021 , e31</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2101.09699v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.09699v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.09700v1</id>
    <updated>2021-01-24T12:20:59Z</updated>
    <published>2021-01-24T12:20:59Z</published>
    <title>A greedy algorithm for dropping digits (Functional Pearl)</title>
    <summary>  Consider the puzzle: given a number, remove $k$ digits such that the
resulting number is as large as possible. Various techniques were employed to
derive a linear-time solution to the puzzle: predicate logic was used to
justify the structure of a greedy algorithm, a dependently-typed proof
assistant was used to give a constructive proof of the greedy condition, and
equational reasoning was used to calculate the greedy step as well as the
final, linear-time optimisation.
</summary>
    <author>
      <name>Richard Bird</name>
    </author>
    <author>
      <name>Shin-Cheng Mu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0956796821000198</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0956796821000198" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Journal of Functional Programming , Volume 31 , 2021 , e29</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2101.09700v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.09700v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2101.11421v1</id>
    <updated>2021-01-27T14:15:46Z</updated>
    <published>2021-01-27T14:15:46Z</published>
    <title>Deriving monadic quicksort (Declarative Pearl)</title>
    <summary>  To demonstrate derivation of monadic programs, we present a specification of
sorting using the non-determinism monad, and derive pure quicksort on lists and
state-monadic quicksort on arrays. In the derivation one may switch between
point-free and pointwise styles, and deploy techniques familiar to functional
programmers such as pattern matching and induction on structures or on sizes.
Derivation of stateful programs resembles reasoning backwards from the
postcondition.
</summary>
    <author>
      <name>Shin-Cheng Mu</name>
    </author>
    <author>
      <name>Tsung-Ju Chiang</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-59025-3_8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-59025-3_8" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">In Nakano K., Sagonas K. (eds) Functional and Logic Programming
  (FLOPS 2020). LNCS 12073. pp 124-138. 2020</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2101.11421v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2101.11421v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2102.02363v1</id>
    <updated>2021-02-04T01:41:23Z</updated>
    <published>2021-02-04T01:41:23Z</published>
    <title>Operational Semantics with Hierarchical Abstract Syntax Graphs</title>
    <summary>  This is a motivating tutorial introduction to a semantic analysis of
programming languages using a graphical language as the representation of
terms, and graph rewriting as a representation of reduction rules. We show how
the graphical language automatically incorporates desirable features, such as
alpha-equivalence and how it can describe pure computation, imperative store,
and control features in a uniform framework. The graph semantics combines some
of the best features of structural operational semantics and abstract machines,
while offering powerful new methods for reasoning about contextual equivalence.
  All technical details are available in an extended technical report by Muroya
and the author and in Muroya's doctoral dissertation.
</summary>
    <author>
      <name>Dan R. Ghica</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Huawei Research, Edinburgh, University of Birmingham, UK</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.334.1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.334.1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TERMGRAPH 2020, arXiv:2102.01804</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 334, 2021, pp. 1-10</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2102.02363v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2102.02363v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2102.07888v1</id>
    <updated>2021-02-15T22:58:18Z</updated>
    <published>2021-02-15T22:58:18Z</published>
    <title>Metatheory.jl: Fast and Elegant Algebraic Computation in Julia with
  Extensible Equality Saturation</title>
    <summary>  We introduce Metatheory.jl: a lightweight and performant general purpose
symbolics and metaprogramming framework meant to simplify the act of writing
complex Julia metaprograms and to significantly enhance Julia with a native
term rewriting system, based on state-of-the-art equality saturation
techniques, and a dynamic first class Abstract Syntax Tree (AST) pattern
matching system that is dynamically composable in an algebraic fashion, taking
full advantage of the language's powerful reflection capabilities. Our
contribution allows to perform general purpose symbolic mathematics,
manipulation, optimization, synthesis or analysis of syntactically valid Julia
expressions with a clean and concise programming interface, both during
compilation or execution of programs.
</summary>
    <author>
      <name>Alessandro Cheli</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.21105/joss.03078</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.21105/joss.03078" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 1 figure</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">The Open Journal, 2021</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2102.07888v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2102.07888v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.1.0; I.1.2; I.1.3; D.3.2; D.3.3; D.3.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2102.09436v1</id>
    <updated>2021-02-18T15:54:30Z</updated>
    <published>2021-02-18T15:54:30Z</published>
    <title>Interleaving classical and reversible</title>
    <summary>  Given a simple recursive function, we show how to extract two interacting
processes from it. The two processes can be described by means of iterative
programs, one of which is intrinsically reversible, in a language that, up to
minor details, belongs to the core of widely used imperative programming
languages. We implement the two processes as interleaving synchronous JAVA
threads whose interaction is equivalent to the recursive function they are
extracted from.
</summary>
    <author>
      <name>Armando B. Matos</name>
    </author>
    <author>
      <name>Luca Paolini</name>
    </author>
    <author>
      <name>Luca Roversi</name>
    </author>
    <link href="http://arxiv.org/abs/2102.09436v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2102.09436v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.1, D.3.2, D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2102.10698v2</id>
    <updated>2021-08-26T19:44:19Z</updated>
    <published>2021-02-21T22:00:34Z</published>
    <title>Certifying Choreography Compilation</title>
    <summary>  Choreographic programming is a paradigm for developing concurrent and
distributed systems, where programs are choreographies that define, from a
global viewpoint, the computations and interactions that communicating
processes should enact. Choreography compilation translates choreographies into
the local definitions of process behaviours, given as terms in a process
calculus.
  Proving choreography compilation correct is challenging and error-prone,
because it requires relating languages in different paradigms (global
interactions vs local actions) and dealing with a combinatorial explosion of
proof cases. We present the first certified program for choreography
compilation for a nontrivial choreographic language supporting recursion.
</summary>
    <author>
      <name>Luís Cruz-Filipe</name>
    </author>
    <author>
      <name>Fabrizio Montesi</name>
    </author>
    <author>
      <name>Marco Peressotti</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-85315-0_8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-85315-0_8" rel="related"/>
    <link href="http://arxiv.org/abs/2102.10698v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2102.10698v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.00063v1</id>
    <updated>2021-06-09T04:20:46Z</updated>
    <published>2021-06-09T04:20:46Z</published>
    <title>Visualizing The Intermediate Representation of Just-in-Time Compilers</title>
    <summary>  Just-in-Time (JIT) compilers are used by many modern programming systems in
order to improve performance. Bugs in JIT compilers provide exploitable
security vulnerabilities and debugging them is difficult as they are large,
complex, and dynamic. Current debugging and visualization tools deal with
static code and are not suitable in this domain. We describe a new approach for
simplifying the large and complex intermediate representation, generated by a
JIT compiler and visualize it with a metro map metaphor to aid developers in
debugging. Experiments using our prototype implementation on Google's V8
JavaScript interpreter and TurboFan JIT compiler demonstrate that it can help
identify and localize buggy code.
</summary>
    <author>
      <name>HeuiChan Lim</name>
    </author>
    <author>
      <name>Stephen Kobourov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">24 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2107.00063v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.00063v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.08729v1</id>
    <updated>2021-07-19T09:56:30Z</updated>
    <published>2021-07-19T09:56:30Z</published>
    <title>Towards Probabilistic Session-Type Monitoring</title>
    <summary>  We present a tool-based approach for the runtime analysis of communicating
processes grounded on probabilistic binary session types. We synthesise a
monitor out of a probabilistic session type where each choice point is
decorated by a probability distribution. The monitor observes the execution of
a process, infers its probabilistic behaviour and issues warnings when the
observed behaviour deviates from the one specified by the probabilistic session
type.
</summary>
    <author>
      <name>Christian Bartolo Burlò</name>
    </author>
    <author>
      <name>Adrian Francalanza</name>
    </author>
    <author>
      <name>Alceste Scalas</name>
    </author>
    <author>
      <name>Catia Trubiani</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-030-78142-2_7</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-030-78142-2_7" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings 23rd IFIP WG 6.1 International Conference,
  COORDINATION 2021. Springer International Publishing</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2107.08729v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.08729v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.10160v3</id>
    <updated>2021-08-31T08:49:08Z</updated>
    <published>2021-07-21T15:43:23Z</published>
    <title>Pre-proceedings of the 31st International Symposium on Logic-Based
  Program Synthesis and Transformation (LOPSTR 2021)</title>
    <summary>  This volume constitutes the pre-proceedings of the 31st International
Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2021),
held on 7-8th September 2021 as a hybrid (blended) meeting, both in-person (at
the Teachers' House in Tallinn, Estonia) and virtual, and co-located with the
23rd International Symposium on Principles and Practice of Declarative
Programming (PPDP 2021). After discussion at the symposium papers will go
through a second round of refereeing and selection for the formal proceedings.
</summary>
    <author>
      <name>Emanuele De Angelis</name>
    </author>
    <author>
      <name>Wim Vanhoof</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Papers selected for presentation at LOPSTR 2021, Invited talks and
  Tutorial</arxiv:comment>
    <link href="http://arxiv.org/abs/2107.10160v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.10160v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.13072v1</id>
    <updated>2021-07-27T20:17:50Z</updated>
    <published>2021-07-27T20:17:50Z</published>
    <title>The Probabilistic Termination Tool Amber</title>
    <summary>  We describe the Amber tool for proving and refuting the termination of a
class of probabilistic while-programs with polynomial arithmetic, in a fully
automated manner. Amber combines martingale theory with properties of
asymptotic bounding functions and implements relaxed versions of existing
probabilistic termination proof rules to prove/disprove (positive) almost sure
termination of probabilistic loops. Amber supports programs parameterized by
symbolic constants and drawing from common probability distributions. Our
experimental comparisons give practical evidence of Amber outperforming
existing state-of-the-art tools.
</summary>
    <author>
      <name>Marcel Moosbrugger</name>
    </author>
    <author>
      <name>Ezio Bartocci</name>
    </author>
    <author>
      <name>Joost-Pieter Katoen</name>
    </author>
    <author>
      <name>Laura Kovács</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted to FM 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2107.13072v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.13072v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2107.13433v1</id>
    <updated>2021-07-28T15:25:32Z</updated>
    <published>2021-07-28T15:25:32Z</published>
    <title>Functorial String Diagrams for Reverse-Mode Automatic Differentiation</title>
    <summary>  We enhance the calculus of string diagrams for monoidal categories with
hierarchical features in order to capture closed monoidal (and cartesian
closed) structure. Using this new syntax we formulate an automatic
differentiation algorithm for (applied) simply typed lambda calculus in the
style of [Pearlmutter and Siskind 2008] and we prove for the first time its
soundness. To give an efficient yet principled implementation of the AD
algorithm we define a sound and complete representation of hierarchical string
diagrams as a class of hierarchical hypergraphs we call hypernets.
</summary>
    <author>
      <name>Mario Alvarez-Picallo</name>
    </author>
    <author>
      <name>Dan R. Ghica</name>
    </author>
    <author>
      <name>David Sprunger</name>
    </author>
    <author>
      <name>Fabio Zanasi</name>
    </author>
    <link href="http://arxiv.org/abs/2107.13433v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2107.13433v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.00281v1</id>
    <updated>2021-07-31T16:25:40Z</updated>
    <published>2021-07-31T16:25:40Z</published>
    <title>Enhanced Regular Corecursion for Data Streams</title>
    <summary>  We propose a simple calculus for processing data streams (infinite flows of
data series), represented by finite sets of equations built on stream
operators. Furthermore, functions defining streams are regularly corecursive,
that is, cyclic calls are detected, avoiding non-termination as happens with
ordinary recursion in the call-by-value evaluation strategy. As we illustrate
by several examples, the combination of such two mechanisms provides a good
compromise between expressive power and decidability. Notably, we provide an
algorithm to check that the stream returned by a function call is represented
by a well-formed set of equations which actually admits a unique solution,
hence access to an arbitrary element of the returned stream will never diverge.
</summary>
    <author>
      <name>Davide Ancona</name>
    </author>
    <author>
      <name>Pietro Barbieri</name>
    </author>
    <author>
      <name>Elena Zucca</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">18 Pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2108.00281v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.00281v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.03602v1</id>
    <updated>2021-08-08T10:45:56Z</updated>
    <published>2021-08-08T10:45:56Z</published>
    <title>Planning for an Efficient Implementation of Hypothetical Bousi~Prolog</title>
    <summary>  This paper explores the integration of hypothetical reasoning into an
efficient implementation of the fuzzy logic language Bousi~Prolog. To this end,
we first analyse what would be expected from a logic inference system, equipped
with what is called embedded implication, to model solving goals with respect
to assumptions. We start with a propositional system and incrementally build
more complex systems and implementations to satisfy the requirements imposed by
a system like Bousi~Prolog. Finally, we propose an inference system,
operational semantics, and the translation function to generate efficient
Prolog programs from Bousi~Prolog programs.
</summary>
    <author>
      <name>Pascual Julián-Iranzo</name>
    </author>
    <author>
      <name>Fernando Sáenz-Pérez</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 37th International Conference on Logic
  Programming (ICLP 2021), 16 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2108.03602v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.03602v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.6" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.07179v1</id>
    <updated>2021-08-16T15:38:07Z</updated>
    <published>2021-08-16T15:38:07Z</published>
    <title>Writing R Extensions in Rust</title>
    <summary>  This paper complements "Writing R Extensions," the official guide for writing
R extensions, for those interested in developing R packages using Rust. It
highlights idiosyncrasies of R and Rust that must be addressed by any
integration and describes how to develop Rust-based packages which comply with
the CRAN Repository Policy. This paper introduces the "cargo" framework, a
transparent Rust-based API which wraps commonly-used parts of R's API with
minimal overhead and allows a programmer to easily add additional wrappers.
</summary>
    <author>
      <name>David B. Dahl</name>
    </author>
    <link href="http://arxiv.org/abs/2108.07179v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.07179v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.CO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.08724v1</id>
    <updated>2021-08-19T14:46:34Z</updated>
    <published>2021-08-19T14:46:34Z</published>
    <title>Programming-By-Example by Programming-By-Example: Synthesis of Looping
  Programs</title>
    <summary>  Program synthesis has seen many new applications in recent years, in large
part thanks to the introduction of SyGuS. However, no existing SyGuS solvers
have support for synthesizing recursive functions. We introduce an multi-phase
algorithm for the synthesis of recursive ``looplike'' programs in SyGuS for
programming-by-example. We solve constraints individually and treat them as
``unrolled`` examples of how a recursive program would behave, and solve for
the generalized recursive solution. Our approach is modular and supports any
SyGuS Solver.
</summary>
    <author>
      <name>Shmuel Berman</name>
    </author>
    <author>
      <name>Mark Santolucito</name>
    </author>
    <link href="http://arxiv.org/abs/2108.08724v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.08724v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.11347v3</id>
    <updated>2021-08-27T08:53:52Z</updated>
    <published>2021-08-25T17:11:24Z</published>
    <title>The Next 700 Program Transformers</title>
    <summary>  In this paper, we describe a hierarchy of program transformers in which the
transformer at each level of the hierarchy builds on top of those at lower
levels. The program transformer at level 1 of the hierarchy corresponds to
positive supercompilation, and that at level 2 corresponds to distillation. We
prove that the transformers at each level terminate. We then consider the
speedups that can be obtained at each level in the hierarchy, and try to
characterise the improvements that can be made.
</summary>
    <author>
      <name>Geoffrey Hamilton</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Pre-proceedings paper presented at the 31st International Symposium
  on Logic-Based Program Synthesis and Transformation (LOPSTR 2021), Tallinn,
  Estonia, and Virtual, September 7-8, 2021 (arXiv:2107.10160)</arxiv:comment>
    <link href="http://arxiv.org/abs/2108.11347v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.11347v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; I.2.2; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.11426v1</id>
    <updated>2021-08-25T18:41:12Z</updated>
    <published>2021-08-25T18:41:12Z</published>
    <title>Visualizing JIT Compiler Graphs</title>
    <summary>  Just-in-time (JIT) compilers are used by many modern programming systems in
order to improve performance. Bugs in JIT compilers provide exploitable
security vulnerabilities and debugging them is difficult as they are large,
complex, and dynamic. Current debugging and visualization tools deal with
static code and are not suitable in this domain. We describe a new approach for
simplifying the large and complex intermediate representation, generated by a
JIT compiler and visualize it with a metro map metaphor to aid developers in
debugging.
</summary>
    <author>
      <name>HeuiChan Lim</name>
    </author>
    <author>
      <name>Stephen Kobourov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Appears in the Proceedings of the 29th International Symposium on
  Graph Drawing and Network Visualization (GD 2021). arXiv admin note:
  substantial text overlap with arXiv:2107.00063</arxiv:comment>
    <link href="http://arxiv.org/abs/2108.11426v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.11426v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2108.13114v2</id>
    <updated>2022-07-29T10:40:11Z</updated>
    <published>2021-08-30T10:47:19Z</published>
    <title>Embedded Pattern Matching</title>
    <summary>  Haskell is a popular choice for hosting deeply embedded languages. A
recurring challenge for these embeddings is how to seamlessly integrate user
defined algebraic data types. In particular, one important, convenient, and
expressive feature for creating and inspecting data -- pattern matching -- is
not directly available on embedded terms. We present a novel technique,
embedded pattern matching, which enables a natural and user friendly embedding
of user defined algebraic data types into the embedded language, and allows
programmers to pattern match on terms in the embedded language in much the same
way they would in the host language.
</summary>
    <author>
      <name>Trevor L. McDonell</name>
    </author>
    <author>
      <name>Joshua D. Meredith</name>
    </author>
    <author>
      <name>Gabriele Keller</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3546189.3549917</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3546189.3549917" rel="related"/>
    <link href="http://arxiv.org/abs/2108.13114v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2108.13114v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.02814v1</id>
    <updated>2021-09-07T01:57:50Z</updated>
    <published>2021-09-07T01:57:50Z</published>
    <title>An Empirical Study of Partial Deduction for miniKanren</title>
    <summary>  We study conjunctive partial deduction, an advanced specialization technique
aimed at improving the performance of logic programs, in the context of
relational programming language miniKanren. We identify a number of issues,
caused by miniKanren peculiarities, and describe a novel approach to
specialization based on partial deduction and supercompilation. The results of
the evaluation demonstrate successful specialization of relational
interpreters. Although the project is at an early stage, we consider it as the
first step towards an efficient optimization framework for miniKanren.
</summary>
    <author>
      <name>Ekaterina Verbitskaia</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">JetBrains Research</arxiv:affiliation>
    </author>
    <author>
      <name>Daniil Berezun</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">SPbSU, JetBrains Research</arxiv:affiliation>
    </author>
    <author>
      <name>Dmitry Boulytchev</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">SPbSU, JetBrains Research</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.341.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.341.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings VPT 2021, arXiv:2109.02001</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 341, 2021, pp. 73-94</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2109.02814v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.02814v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.02958v1</id>
    <updated>2021-09-07T09:28:37Z</updated>
    <published>2021-09-07T09:28:37Z</published>
    <title>Multi-Level Quickening: Ten Years Later</title>
    <summary>  This paper presents important performance improvements for interpreters,
exemplified by speedups of up to 5.5$\times$ for CPython. Although the original
version of this papers was rejected multiple times, the reported speedups have
not been achieved by any other interpreter optimization technique since. In
addition, the paper uses a sound evaluation methodology based on a corollary on
Amdahl's law to quantify the speedup potential of benchmarks, which also has
not been used in any other paper since.
  This paper documents my best efforts, and includes all of the reviews the
paper received, plus some more commentary on my side on what has changed since
and what purpose the archived document could serve.
</summary>
    <author>
      <name>Stefan Brunthaler</name>
    </author>
    <link href="http://arxiv.org/abs/2109.02958v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.02958v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.03950v1</id>
    <updated>2021-09-08T22:22:38Z</updated>
    <published>2021-09-08T22:22:38Z</published>
    <title>Study of the Subtyping Machine of Nominal Subtyping with Variance (full
  version)</title>
    <summary>  This is a study of the computing power of the subtyping machine behind
Kennedy and Pierce's nominal subtyping with variance. We depict the lattice of
fragments of Kennedy and Pierce's type system and characterize their computing
power in terms of regular, context-free, deterministic, and non-deterministic
tree languages. Based on the theory, we present Treetop -- a generator of C#
implementations of subtyping machines. The software artifact constitutes the
first feasible (yet POC) fluent API generator to support context-free API
protocols in a decidable type system fragment.
</summary>
    <author>
      <name>Ori Roth</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3485514</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3485514" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proc. ACM Program. Lang. 5 (2021) 27 pages</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2109.03950v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.03950v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.08291v1</id>
    <updated>2021-09-17T01:47:57Z</updated>
    <published>2021-09-17T01:47:57Z</published>
    <title>Natlog: a Lightweight Logic Programming Language with a Neuro-symbolic
  Touch</title>
    <summary>  We introduce Natlog, a lightweight Logic Programming language, sharing
Prolog's unification-driven execution model, but with a simplified syntax and
semantics. Our proof-of-concept Natlog implementation is tightly embedded in
the Python-based deep-learning ecosystem with focus on content-driven indexing
of ground term datasets. As an overriding of our symbolic indexing algorithm,
the same function can be delegated to a neural network, serving ground facts to
Natlog's resolution engine. Our open-source implementation is available as a
Python package at https://pypi.org/project/natlog/ .
</summary>
    <author>
      <name>Paul Tarau</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of North Texas</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.345.27</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.345.27" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICLP 2021, arXiv:2109.07914</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 345, 2021, pp. 141-154</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2109.08291v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.08291v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.11397v1</id>
    <updated>2021-09-22T17:30:40Z</updated>
    <published>2021-09-22T17:30:40Z</published>
    <title>Position Paper: Goals of the Luau Type System</title>
    <summary>  Luau is the scripting language that powers user-generated experiences on the
Roblox platform. It is a statically-typed language, based on the
dynamically-typed Lua language, with type inference. These types are used for
providing editor assistance in Roblox Studio, the IDE for authoring Roblox
experiences. Due to Roblox's uniquely heterogeneous developer community, Luau
must operate in a somewhat different fashion than a traditional
statically-typed language. In this paper, we describe some of the goals of the
Luau type system, focusing on where the goals differ from those of other type
systems.
</summary>
    <author>
      <name>Lily Brown</name>
    </author>
    <author>
      <name>Andy Friesen</name>
    </author>
    <author>
      <name>Alan Jeffrey</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In HATRA '21: Human Aspects of Types and Reasoning Assistants 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2109.11397v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.11397v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2109.12997v1</id>
    <updated>2021-09-20T07:44:47Z</updated>
    <published>2021-09-20T07:44:47Z</published>
    <title>Benchmarking the Status of Default Pseudorandom Number Generators in
  Common Programming Languages</title>
    <summary>  The ever-increasing need for random numbers is clear in many areas of
computer science, from neural networks to optimization. As such, most common
programming language provide easy access to Pseudorandom Number Generators.
However, these generators are not all made equal, and empirical verification
has previously shown some to be flawed in key ways. Because of the constant
changes in programming languages, we perform the same empirical benchmarking
using large batteries of statistcal tests on a wide array of PRNGs, and
identify that while some languages have improved significantly over the years,
there are still cases where the default PRNG fails to deliver sufficiently
random results.
</summary>
    <author>
      <name>Nils van den Honert</name>
    </author>
    <author>
      <name>Diederick Vermetten</name>
    </author>
    <author>
      <name>Anna V. Kononova</name>
    </author>
    <link href="http://arxiv.org/abs/2109.12997v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2109.12997v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2111.03484v2</id>
    <updated>2021-11-09T10:39:34Z</updated>
    <published>2021-11-05T13:00:12Z</published>
    <title>Pirouette: Higher-Order Typed Functional Choreographies</title>
    <summary>  We present Pirouette, a language for typed higher-order functional
choreographic programming. Pirouette offers programmers the ability to write a
centralized functional program and compile it via endpoint projection into
programs for each node in a distributed system. Moreover, Pirouette is defined
generically over a (local) language of messages, and lifts guarantees about the
message type system to its own. Message type soundness also guarantees deadlock
freedom. All of our results are verified in Coq.
</summary>
    <author>
      <name>Andrew K. Hirsch</name>
    </author>
    <author>
      <name>Deepak Garg</name>
    </author>
    <link href="http://arxiv.org/abs/2111.03484v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2111.03484v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2111.05617v1</id>
    <updated>2021-11-10T10:19:48Z</updated>
    <published>2021-11-10T10:19:48Z</published>
    <title>Software Model-Checking as Cyclic-Proof Search</title>
    <summary>  This paper shows that a variety of software model-checking algorithms can be
seen as proof-search strategies for a non-standard proof system, known as a
cyclic proof system. Our use of the cyclic proof system as a logical foundation
of software model checking enables us to compare different algorithms, to
reconstruct well-known algorithms from a few simple principles, and to obtain
soundness proofs of algorithms for free. Among others, we show the significance
of a heuristics based on a notion that we call maximal conservativity; this
explains the cores of important algorithms such as property-directed
reachability (PDR) and reveals a surprising connection to an efficient solver
of games over infinite graphs that was not regarded as a kind of PDR.
</summary>
    <author>
      <name>Takeshi Tsukada</name>
    </author>
    <author>
      <name>Hiroshi Unno</name>
    </author>
    <link href="http://arxiv.org/abs/2111.05617v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2111.05617v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2111.13384v5</id>
    <updated>2024-03-01T10:41:48Z</updated>
    <published>2021-11-26T09:42:45Z</published>
    <title>EOLANG and $\varphi$-calculus</title>
    <summary>  Object-oriented programming (OOP) is one of the most popular paradigms used
for building software systems. However, despite its industrial and academic
popularity, OOP is still missing a formal apparatus similar to
$\lambda$-calculus, which functional programming is based on. There were a
number of attempts to formalize OOP, but none of them managed to cover all the
features available in modern OO programming languages, such as C++ or Java. We
have made yet another attempt and created $\varphi$-calculus. We also created
EOLANG (also called EO), an experimental programming language based on
$\varphi$-calculus.
</summary>
    <author>
      <name>Yegor Bugayenko</name>
    </author>
    <link href="http://arxiv.org/abs/2111.13384v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2111.13384v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2111.14249v1</id>
    <updated>2021-11-28T22:23:01Z</updated>
    <published>2021-11-28T22:23:01Z</published>
    <title>Virtualizing Intermittent Computing</title>
    <summary>  Intermittent computing requires custom programming models to ensure the
correct execution of applications despite power failures. However, existing
programming models lead to programs that are hardware-dependent and not
reusable. This paper aims at virtualizing intermittent computing to remedy
these problems. We introduce PureVM, a virtual machine that abstracts a
transiently powered computer, and PureLANG, a continuation-passing-style
programming language to develop programs that run on PureVM. This
virtualization, for the first time, paves the way for portable and reusable
transiently-powered applications.
</summary>
    <author>
      <name>Caglar Durmaz</name>
    </author>
    <author>
      <name>Kasim Sinan Yildirim</name>
    </author>
    <author>
      <name>Geylani Kardas</name>
    </author>
    <link href="http://arxiv.org/abs/2111.14249v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2111.14249v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.11988v3</id>
    <updated>2023-10-27T09:02:45Z</updated>
    <published>2021-12-17T10:54:26Z</published>
    <title>Reducing Programs to Objects</title>
    <summary>  C++, Java, C#, Python, Ruby, JavaScript are the most powerful object-oriented
programming languages, if language power would be defined as the number of
features available for a programmer. EO, on the other hand, is an
object-oriented programming language with a reduced set of features: it has
nothing by objects and mechanisms of their composition and decoration. We are
trying to answer the following research question: "Which known features are
possible to implement using only objects?"
</summary>
    <author>
      <name>Yegor Bugayenko</name>
    </author>
    <link href="http://arxiv.org/abs/2112.11988v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.11988v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.12869v3</id>
    <updated>2022-02-22T18:16:08Z</updated>
    <published>2021-12-23T22:31:27Z</published>
    <title>A Lightweight Approach to Computing Message Races with an Application to
  Causal-Consistent Reversible Debugging</title>
    <summary>  This paper presents a lightweight formalism (a trace) to model
message-passing concurrent executions where some common common problems can be
identified, like lost or delayed messages, some forms of deadlock, etc. In
particular, we consider (potential) message races that can be useful to analyze
alternative executions. We consider a particular application for our
developments in the context of a causal-consistent reversible debugging
framework for Erlang programs
</summary>
    <author>
      <name>Juan José González-Abril</name>
    </author>
    <author>
      <name>Germán Vidal</name>
    </author>
    <link href="http://arxiv.org/abs/2112.12869v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.12869v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.14048v1</id>
    <updated>2021-12-28T09:06:35Z</updated>
    <published>2021-12-28T09:06:35Z</published>
    <title>Monads for Measurable Queries in Probabilistic Databases</title>
    <summary>  We consider a bag (multiset) monad on the category of standard Borel spaces,
and show that it gives a free measurable commutative monoid. Firstly, we show
that a recent measurability result for probabilistic database queries (Grohe
and Lindner, ICDT 2020) follows quickly from the fact that queries can be
expressed in monad-based terms. We also extend this measurability result to a
fuller query language. Secondly, we discuss a distributive law between
probability and bag monads, and we illustrate that this is useful for
generating probabilistic databases.
</summary>
    <author>
      <name>Swaraj Dash</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oxford</arxiv:affiliation>
    </author>
    <author>
      <name>Sam Staton</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oxford</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.351.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.351.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MFPS 2021, arXiv:2112.13746</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 351, 2021, pp. 34-50</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2112.14048v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.14048v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2112.14053v1</id>
    <updated>2021-12-28T09:08:43Z</updated>
    <published>2021-12-28T09:08:43Z</published>
    <title>From Semantics to Types: the Case of the Imperative lambda-Calculus</title>
    <summary>  We propose an intersection type system for an imperative lambda-calculus
based on a state monad and equipped with algebraic operations to read and write
to the store. The system is derived by solving a suitable domain equation in
the category of omega-algebraic lattices; the solution consists of a
filter-model generalizing the well-known construction for ordinary
lambda-calculus. Then the type system is obtained out of the term
interpretations into the filter-model itself. The so obtained type system
satisfies the "type-semantics" property, and it is sound and complete by
construction.
</summary>
    <author>
      <name>Ugo de'Liguoro</name>
    </author>
    <author>
      <name>Riccardo Treglia</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.351.11</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.351.11" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings MFPS 2021, arXiv:2112.13746. arXiv admin note:
  substantial text overlap with arXiv:2104.01358</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 351, 2021, pp. 168-183</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2112.14053v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2112.14053v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.4.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2204.10784v2</id>
    <updated>2022-06-25T06:18:39Z</updated>
    <published>2022-04-22T15:59:42Z</published>
    <title>MCBeth: A Measurement Based Quantum Programming Language</title>
    <summary>  Gate-based quantum programming languages are ubiquitous but measurement-based
languages currently exist only on paper. This work introduces MCBeth, a quantum
programming language which allows programmers to directly represent, program,
and simulate measurement-based and cluster state computation by building upon
the measurement calculus. While MCBeth programs are meant to be executed
directly on hardware, to take advantage of current machines we also provide a
compiler to gate-based instructions. We argue that there are clear advantages
to measurement-based quantum computation compared to gate-based when it comes
to implementing common quantum algorithms and distributed quantum computation.
</summary>
    <author>
      <name>Aidan Evans</name>
    </author>
    <author>
      <name>Seun Omonije</name>
    </author>
    <author>
      <name>Robert Soulé</name>
    </author>
    <author>
      <name>Robert Rand</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">24 pages, 16 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2204.10784v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2204.10784v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.00795v1</id>
    <updated>2022-05-02T10:25:46Z</updated>
    <published>2022-05-02T10:25:46Z</published>
    <title>Rusty Links in Local Chains</title>
    <summary>  Rust successfully applies ownership types to control memory allocation. This
restricts the programs' topologies to the point where doubly-linked lists
cannot be programmed in Safe Rust. We sketch how more flexible "local"
ownership could be added to Rust, permitting multiple mutable references to
objects, provided each reference is bounded by the object's lifetime. To
maintain thread-safety, locally owned objects must remain thread-local; to
maintain memory safety, local objects can be deallocated when their owner's
lifetime expires.
</summary>
    <author>
      <name>James Noble</name>
    </author>
    <author>
      <name>Julian Mackay</name>
    </author>
    <author>
      <name>Tobias Wrigstad</name>
    </author>
    <link href="http://arxiv.org/abs/2205.00795v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.00795v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.01171v1</id>
    <updated>2022-05-02T19:27:24Z</updated>
    <published>2022-05-02T19:27:24Z</published>
    <title>Reversing an Imperative Concurrent Programming Language</title>
    <summary>  We introduce a method of reversing the execution of imperative concurrent
programs. Given an irreversible program, we describe the process of producing
two versions. The first performs forward execution and saves information
necessary for reversal. The second uses this saved information to simulate
reversal. We propose using identifiers to overcome challenges of reversing
concurrent programs. We prove this reversibility to be correct, showing that
the initial program state is restored and that all saved information is used
(garbage-free).
</summary>
    <author>
      <name>James Hoey</name>
    </author>
    <author>
      <name>Irek Ulidowski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">48 pages, 21 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2205.01171v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.01171v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.02282v1</id>
    <updated>2022-05-04T18:38:48Z</updated>
    <published>2022-05-04T18:38:48Z</published>
    <title>Low-Code Programming Models</title>
    <summary>  Traditionally, computer programming has been the prerogative of professional
developers using textual programming languages such as C, Java, or Python.
Low-code programming promises an alternative: letting citizen developers create
programs using visual abstractions, demonstrations, or natural language. While
low-code programming is currently getting a lot of attention in industry, the
relevant research literature is scattered, and in fact, rarely uses the term
"low-code". This article brings together low-code literature from various
research fields, explaining how techniques work while providing a unified point
of view. Low-code has the potential to empower more people to automate tasks by
creating computer programs, making them more productive and less dependent on
scarce professional software developers.
</summary>
    <author>
      <name>Martin Hirzel</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3587691</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3587691" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Communications of the ACM (CACM), 66(10), pages 76-85, October
  2023</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2205.02282v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.02282v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.06841v1</id>
    <updated>2022-05-13T18:20:50Z</updated>
    <published>2022-05-13T18:20:50Z</published>
    <title>From Logic to Functional Logic Programs</title>
    <summary>  Logic programming is a flexible programming paradigm due to the use of
predicates without a fixed data flow. To extend logic languages with the
compact notation of functional programming, there are various proposals to map
evaluable functions into predicates in order to stay in the logic programming
framework. Since amalgamated functional logic languages offer flexible as well
as efficient evaluation strategies, we propose an opposite approach in this
paper. By mapping logic programs into functional logic programs with a
transformation based on inferring functional dependencies, we develop a fully
automatic transformation which keeps the flexibility of logic programming but
can improve computations by reducing infinite search spaces to finite ones.
</summary>
    <author>
      <name>Michael Hanus</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Paper presented at the 38th International Conference on Logic
  Programming (ICLP 2022), 16 pages (without appendix)</arxiv:comment>
    <link href="http://arxiv.org/abs/2205.06841v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.06841v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.07811v1</id>
    <updated>2022-05-16T17:05:45Z</updated>
    <published>2022-05-16T17:05:45Z</published>
    <title>Natural Language Specifications in Proof Assistants</title>
    <summary>  Interactive proof assistants are computer programs carefully constructed to
check a human-designed proof of a mathematical claim with high confidence in
the implementation. However, this only validates truth of a formal claim, which
may have been mistranslated from a claim made in natural language. This is
especially problematic when using proof assistants to formally verify the
correctness of software with respect to a natural language specification. The
translation from informal to formal remains a challenging, time-consuming
process that is difficult to audit for correctness. This paper argues that it
is possible to build support for natural language specifications within
existing proof assistants, in a way that complements the principles used to
establish trust and auditability in proof assistants themselves.
</summary>
    <author>
      <name>Colin S. Gordon</name>
    </author>
    <author>
      <name>Sergey Matskevich</name>
    </author>
    <link href="http://arxiv.org/abs/2205.07811v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.07811v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.08768v2</id>
    <updated>2022-05-19T15:25:25Z</updated>
    <published>2022-05-18T07:31:59Z</published>
    <title>Global Type Inference for Featherweight Generic Java</title>
    <summary>  Java's type system mostly relies on type checking augmented with local type
inference to improve programmer convenience. We study global type inference for
Featherweight Generic Java (FGJ), a functional Java core language. Given
generic class headers and field specifications, our inference algorithm infers
all method types if classes do not make use of polymorphic recursion. The
algorithm is constraint-based and improves on prior work in several respects.
Despite the restricted setting, global type inference for FGJ is NP-complete.
</summary>
    <author>
      <name>Andreas Stadelmeier</name>
    </author>
    <author>
      <name>Martin Plümicke</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">33 pages, abridged version appears in ECOOP 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2205.08768v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.08768v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68N15" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.15211v2</id>
    <updated>2022-07-12T19:35:50Z</updated>
    <published>2022-05-30T16:16:17Z</published>
    <title>Type Systems in Resource-Aware Programming: Opportunities and Challenges</title>
    <summary>  Type systems provide software developers immediate feedback about a subset of
correctness properties of their programs. IDE integrations often take advantage
of type systems to present errors, suggest completions and even improve
navigation. On the other hand, understanding the time and energy consumption of
the execution of a program requires manual testing.
  In this paper, we identify existing work on using type systems for energy
awareness, and define the requirements for a practical approach, which the
existing approaches do not address fully.
  Furthermore, we also discuss how existing type systems can help generalize
refactors for energy-efficiency.
</summary>
    <author>
      <name>Alcides Fonseca</name>
    </author>
    <author>
      <name>Guilherme Espada</name>
    </author>
    <link href="http://arxiv.org/abs/2205.15211v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.15211v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2205.15917v1</id>
    <updated>2022-05-31T16:06:42Z</updated>
    <published>2022-05-31T16:06:42Z</published>
    <title>Concrete categories and higher-order recursion (With applications
  including probability, differentiability, and full abstraction)</title>
    <summary>  We study concrete sheaf models for a call-by-value higher-order language with
recursion. Our family of sheaf models is a generalization of many examples from
the literature, such as models for probabilistic and differentiable
programming, and fully abstract logical relations models. We treat recursion in
the spirit of synthetic domain theory. We provide a general construction of a
lifting monad starting from a class of admissible monomorphisms in the site of
the sheaf category. In this way, we obtain a family of models parametrized by a
concrete site and a class of monomorphisms, for which we prove a general
computational adequacy theorem.
</summary>
    <author>
      <name>Cristina Matache</name>
    </author>
    <author>
      <name>Sean Moss</name>
    </author>
    <author>
      <name>Sam Staton</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3531130.3533370</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3531130.3533370" rel="related"/>
    <link href="http://arxiv.org/abs/2205.15917v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2205.15917v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.02585v4</id>
    <updated>2024-04-10T06:52:28Z</updated>
    <published>2022-06-06T12:49:00Z</published>
    <title>On the Origins of Objects by Means of Careful Selection</title>
    <summary>  We introduce a taxonomy of objects for EO programming language. This taxonomy
is designed with a few principles in mind: non-redundancy, simplicity, and so
on. The taxonomy is supposed to be used as a navigation map by EO programmers.
It may also be helpful as a guideline for designers of other object-oriented
languages or libraries for them.
</summary>
    <author>
      <name>Yegor Bugayenko</name>
    </author>
    <link href="http://arxiv.org/abs/2206.02585v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.02585v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.03866v2</id>
    <updated>2023-03-19T20:49:47Z</updated>
    <published>2022-06-01T03:01:35Z</published>
    <title>JuMP 1.0: Recent improvements to a modeling language for mathematical
  optimization</title>
    <summary>  JuMP is an algebraic modeling language embedded in the Julia programming
language. JuMP allows users to model optimization problems of a variety of
kinds, including linear programming, integer programming, conic optimization,
semidefinite programming, and nonlinear programming, and handles the low-level
details of communicating with solvers. After nearly 10 years in development,
JuMP 1.0 was released in March, 2022. In this short communication, we highlight
the improvements to JuMP from recent releases up to and including 1.0.
</summary>
    <author>
      <name>Miles Lubin</name>
    </author>
    <author>
      <name>Oscar Dowson</name>
    </author>
    <author>
      <name>Joaquim Dias Garcia</name>
    </author>
    <author>
      <name>Joey Huchette</name>
    </author>
    <author>
      <name>Benoît Legat</name>
    </author>
    <author>
      <name>Juan Pablo Vielma</name>
    </author>
    <link href="http://arxiv.org/abs/2206.03866v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.03866v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.05716v1</id>
    <updated>2022-06-12T11:02:34Z</updated>
    <published>2022-06-12T11:02:34Z</published>
    <title>Divergences on Monads for Relational Program Logics</title>
    <summary>  Several relational program logics have been introduced for integrating
reasoning about relational properties of programs and measurement of
quantitative difference between computational effects. Towards a general
framework for such logics, in this paper, we formalize quantitative difference
between computational effects as divergence on monad, then develop a relational
program logic acRL that supports generic computational effects and divergences
on them. To give a categorical semantics of acRL supporting divergences, we
give a method to obtain graded strong relational liftings from divergences on
monads. We derive two instantiations of acRL for the verification of 1) various
differential privacy of higher-order functional probabilistic programs and 2)
difference of distribution of costs between higher-order functional programs
with probabilistic choice and cost counting operations.
</summary>
    <author>
      <name>Tetsuya Sato</name>
    </author>
    <author>
      <name>Shin-ya Katsumata</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1017/S0960129523000245</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1017/S0960129523000245" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/2206.05716v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.05716v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.09534v1</id>
    <updated>2022-06-20T01:58:44Z</updated>
    <published>2022-06-20T01:58:44Z</published>
    <title>Proceedings Ninth Workshop on Mathematically Structured Functional
  Programming</title>
    <summary>  This volume contains the proceedings of the Ninth Workshop on Mathematically
Structured Functional Programming (MSFP 2022). The meeting took place on the
2nd of April as a satellite of European Joint Conferences on Theory &amp; Practice
of Software (ETAPS 2022). The MSFP workshop highlights applications of
mathematical structures to programming applications. We promote the use of
category theory, type theory, and formal language semantics to the development
of simple and reasonable programs. As the range of papers presented in this
year's workshop shows, this continues to be a fruitful interface.
</summary>
    <author>
      <name>Jeremy Gibbons</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Oxford</arxiv:affiliation>
    </author>
    <author>
      <name>Max S. New</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Michigan</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.360</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.360" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 360, 2022</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2206.09534v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.09534v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.11192v1</id>
    <updated>2022-06-22T16:22:34Z</updated>
    <published>2022-06-22T16:22:34Z</published>
    <title>Functional or imperative? On pleasant semantics for differentiable
  programming languages</title>
    <summary>  In machine learning (ML), researchers and engineers seem to be at odds.
System implementers would prefer models to be declarative, with detailed type
information and semantic restrictions that allow models to be optimised,
rearranged and parallelised. Yet practitioners show an overwhelming preference
for dynamic, imperative languages with mutable state, and much engineering
effort is spent bridging the resulting semantic divide. Is there a fundamental
conflict? This article explores why imperative and functional styles are used,
and how future language designs might get the best of both worlds.
</summary>
    <author>
      <name>Michael Innes</name>
    </author>
    <link href="http://arxiv.org/abs/2206.11192v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.11192v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.14270v1</id>
    <updated>2022-06-28T19:51:48Z</updated>
    <published>2022-06-28T19:51:48Z</published>
    <title>Exporting Ada Software to Python and Julia</title>
    <summary>  The objective is to demonstrate the making of Ada software available to
Python and Julia programmers using GPRbuild. GPRbuild is the project manager of
the GNAT toolchain. With GPRbuild the making of shared object files is fully
automated and the software can be readily used in Python and Julia. The
application is the build process of PHCpack, a free and open source software
package to solve polynomial systems by homotopy continuation methods, written
mainly in Ada, with components in C++, available at github at
https://github.com/janverschelde/PHCpack.
</summary>
    <author>
      <name>Jan Verschelde</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear in the Ada User Journal, in the Proceedings of the Ada
  Devroom at FOSDEM 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2206.14270v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.14270v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.NA" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.NA" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2206.14879v1</id>
    <updated>2022-06-29T19:44:41Z</updated>
    <published>2022-06-29T19:44:41Z</published>
    <title>Programming Languages and Law: A Research Agenda</title>
    <summary>  If code is law, then the language of law is a programming language. Lawyers
and legal scholars can learn about law by studying programming-language theory,
and programming-language tools can be usefully applied to legal problems. This
article surveys the history of research on programming languages and law and
presents ten promising avenues for future efforts. Its goals are to explain how
the combination of programming languages and law is distinctive within the
broader field of computer science and law, and to demonstrate with concrete
examples the remarkable power of programming-language concepts in this new
domain.
</summary>
    <author>
      <name>James Grimmelmann</name>
    </author>
    <link href="http://arxiv.org/abs/2206.14879v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2206.14879v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0; J.5.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.01090v2</id>
    <updated>2022-07-26T11:49:55Z</updated>
    <published>2022-07-03T18:20:05Z</published>
    <title>Folding over Neural Networks</title>
    <summary>  Neural networks are typically represented as data structures that are
traversed either through iteration or by manual chaining of method calls.
However, a deeper analysis reveals that structured recursion can be used
instead, so that traversal is directed by the structure of the network itself.
This paper shows how such an approach can be realised in Haskell, by encoding
neural networks as recursive data types, and then their training as recursion
scheme patterns. In turn, we promote a coherent implementation of neural
networks that delineates between their structure and semantics, allowing for
compositionality in both how they are built and how they are trained.
</summary>
    <author>
      <name>Minh Nguyen</name>
    </author>
    <author>
      <name>Nicolas Wu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-031-16912-0_5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-031-16912-0_5" rel="related"/>
    <link href="http://arxiv.org/abs/2207.01090v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.01090v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.04218v1</id>
    <updated>2022-07-09T07:46:39Z</updated>
    <published>2022-07-09T07:46:39Z</published>
    <title>Subclasses of Class Function used to Implement Transformations of
  Statistical Models</title>
    <summary>  A library of software for inductive inference guided by the Minimum Message
Length (MML) principle was created previously. It contains various
(object-oriented-) classes and subclasses of statistical Model and can be used
to infer Models from given data sets in machine learning problems. Here
transformations of statistical Models are considered and implemented within the
library so as to have desirable properties from the object-oriented programming
and mathematical points of view. The subclasses of class Function needed to do
such transformations are defined.
</summary>
    <author>
      <name>Lloyd Allison</name>
    </author>
    <link href="http://arxiv.org/abs/2207.04218v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.04218v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; G.3; I.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.05617v1</id>
    <updated>2022-07-12T15:37:54Z</updated>
    <published>2022-07-12T15:37:54Z</published>
    <title>Mechanizing Refinement Types (extended)</title>
    <summary>  Practical checkers based on refinement types use the combination of implicit
semantic sub-typing and parametric polymorphism to simplify the specification
and automate the verification of sophisticated properties of programs. However,
a formal meta-theoretic accounting of the soundness of refinement type systems
using this combination has proved elusive. We present \lambda_RF a core
refinement calculus that combines semantic sub-typing and parametric
polymorphism. We develop a meta-theory for this calculus and prove soundness of
the type system. Finally, we give a full mechanization of our meta-theory using
the refinement-type based LiquidHaskell as a proof checker, showing how
refinements can be used for mechanization.
</summary>
    <author>
      <name>Michael Borkowski</name>
    </author>
    <author>
      <name>Niki Vazou</name>
    </author>
    <author>
      <name>Ranjit Jhala</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">32 pages, under review</arxiv:comment>
    <link href="http://arxiv.org/abs/2207.05617v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.05617v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.08795v1</id>
    <updated>2022-07-18T17:48:55Z</updated>
    <published>2022-07-18T17:48:55Z</published>
    <title>Multi Types and Reasonable Space (Long Version)</title>
    <summary>  Accattoli, Dal Lago, and Vanoni have recently proved that the space used by
the Space KAM, a variant of the Krivine abstract machine, is a reasonable space
cost model for the lambda-calculus accounting for logarithmic space, solving a
longstanding open problem. In this paper, we provide a new system of multi
types (a variant of intersection types) and extract from multi type derivations
the space used by the Space KAM, capturing into a type system the space
complexity of the abstract machine. Additionally, we show how to capture also
the time of the Space KAM, which is a reasonable time cost model, via minor
changes to the type system.
</summary>
    <author>
      <name>Beniamino Accattoli</name>
    </author>
    <author>
      <name>Ugo Dal Lago</name>
    </author>
    <author>
      <name>Gabriele Vanoni</name>
    </author>
    <link href="http://arxiv.org/abs/2207.08795v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.08795v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.11350v1</id>
    <updated>2022-07-22T21:41:11Z</updated>
    <published>2022-07-22T21:41:11Z</published>
    <title>CoqQ: Foundational Verification of Quantum Programs</title>
    <summary>  CoqQ is a framework for reasoning about quantum programs in the Coq proof
assistant. Its main components are: a deeply embedded quantum programming
language, in which classic quantum algorithms are easily expressed, and an
expressive program logic for proving properties of programs. CoqQ is
foundational: the program logic is formally proved sound with respect to a
denotational semantics based on state-of-art mathematical libraries (mathcomp
and mathcomp analysis). CoqQ is also practical: assertions can use Dirac
expressions, which eases concise specifications, and proofs can exploit local
and parallel reasoning, which minimizes verification effort. We illustrate the
applicability of CoqQ with many examples from the literature.
</summary>
    <author>
      <name>Li Zhou</name>
    </author>
    <author>
      <name>Gilles Barthe</name>
    </author>
    <author>
      <name>Pierre-Yves Strub</name>
    </author>
    <author>
      <name>Junyi Liu</name>
    </author>
    <author>
      <name>Mingsheng Ying</name>
    </author>
    <link href="http://arxiv.org/abs/2207.11350v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.11350v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.12702v1</id>
    <updated>2022-07-26T07:46:41Z</updated>
    <published>2022-07-26T07:46:41Z</published>
    <title>Teaching Programming to Novices Using the codeBoot Online Environment</title>
    <summary>  Teaching programming to novices is best done with tools with simpler user
interfaces than professional IDEs that are tailored for experienced
programmers. In a distance learning situation it is also important to have a
development environment that is easy to explain and use, and that integrates
well with the variety of course material used (slides, homework, etc). In this
paper we give an experience report on teaching programming with codeBoot, an
online programming environment we designed specifically for novices.
</summary>
    <author>
      <name>Marc Feeley</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Université de Montréal</arxiv:affiliation>
    </author>
    <author>
      <name>Olivier Melançon</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Université de Montréal</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.363.3</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.363.3" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2021/22, arXiv:2207.11600</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 363, 2022, pp. 44-53</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2207.12702v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.12702v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2207.13291v1</id>
    <updated>2022-07-27T04:45:32Z</updated>
    <published>2022-07-27T04:45:32Z</published>
    <title>Correct Compilation of Semiring Contractions</title>
    <summary>  We introduce a formal operational semantics that describes the fused
execution of variable contraction problems, which compute indexed arithmetic
over a semiring and generalize sparse and dense tensor algebra, relational
algebra, and graph algorithms. We prove that the model is correct with respect
to a functional semantics. We also develop a compiler for variable contraction
expressions and show that its performance is equivalent to a state-of-the art
sparse tensor algebra compiler, while providing greater generality and
correctness guarantees.
</summary>
    <author>
      <name>Scott Kovach</name>
    </author>
    <author>
      <name>Fredrik Kjolstad</name>
    </author>
    <link href="http://arxiv.org/abs/2207.13291v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2207.13291v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.00192v1</id>
    <updated>2022-07-30T11:37:00Z</updated>
    <published>2022-07-30T11:37:00Z</published>
    <title>Typed SLD-Resolution: Dynamic Typing for Logic Programming</title>
    <summary>  The semantic foundations for logic programming are usually separated into two
different approaches. The operational semantics, which uses SLD-resolution, the
proof method that computes answers in logic programming, and the declarative
semantics, which sees logic programs as formulas and its semantics as models.
Here, we define a new operational semantics called TSLD-resolution, which
stands for Typed SLD-resolution, where we include a value "wrong", that
corresponds to the detection of a type error at run-time. For this we define a
new typed unification algorithm. Finally we prove the correctness of
TSLD-resolution with respect to a typed declarative semantics.
</summary>
    <author>
      <name>João Barbosa</name>
    </author>
    <author>
      <name>Mário Florido</name>
    </author>
    <author>
      <name>Vítor Santos Costa</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2208.00192v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.00192v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.04235v1</id>
    <updated>2022-07-29T16:05:18Z</updated>
    <published>2022-07-29T16:05:18Z</published>
    <title>Informal proceedings of the 32nd International Symposium on Logic-Based
  Program Synthesis and Transformation (LOPSTR 2022)</title>
    <summary>  This volume constitutes the informal proceedings of the 32nd International
Symposium on Logic-Based Program Synthesis and Transformation (LOPSTR 2022),
held on 21-23rd September 2022 as a hybrid (blended) meeting, both in-person
(at the Ivane Javakhishvili Tbilisi State University -TSU- in Tbilisi, Georgia)
and virtual, and co-located with the 24th International Symposium on Principles
and Practice of Declarative Programming (PPDP 2022) as part of the
Computational Logic Autumn Summit 2022 (CLAS 2022).
</summary>
    <author>
      <name>Alicia Villanueva</name>
    </author>
    <link href="http://arxiv.org/abs/2208.04235v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.04235v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.04631v1</id>
    <updated>2022-08-09T09:53:12Z</updated>
    <published>2022-08-09T09:53:12Z</published>
    <title>Session Fidelity for ElixirST: A Session-Based Type System for Elixir
  Modules</title>
    <summary>  This paper builds on prior work investigating the adaptation of session types
to provide behavioural information about Elixir modules. A type system called
ElixirST has been constructed to statically determine whether functions in an
Elixir module observe their endpoint specifications, expressed as session
types; a corresponding tool automating this typechecking has also been
constructed. In this paper we formally validate this type system. An LTS-based
operational semantics for the language fragment supported by the type system is
developed, modelling its runtime behaviour when invoked by the module client.
This operational semantics is then used to prove session fidelity for ElixirST.
</summary>
    <author>
      <name>Gerard Tabone</name>
    </author>
    <author>
      <name>Adrian Francalanza</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.365.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.365.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2022, arXiv:2208.04086</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 365, 2022, pp. 17-36</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2208.04631v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.04631v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.04635v1</id>
    <updated>2022-08-09T09:54:38Z</updated>
    <published>2022-08-09T09:54:38Z</published>
    <title>Lang-n-Send Extended: Sending Regular Expressions to Monitors</title>
    <summary>  In prior work, Cimini has presented Lang-n-Send, a pi-calculus with language
definitions.
  In this paper, we present an extension of this calculus called Lang-n-Send+m.
First, we revise Lang-n-Send to work with transition system specifications
rather than its language specifications. This revision allows the use of
negative premises in deduction rules. Next, we extend Lang-n-Send with monitors
and with the ability of sending and receiving regular expressions, which then
can be used in the context of larger regular expressions to monitor the
execution of programs.
  We present a reduction semantics for Lang-n-Send+m, and we offer examples
that demonstrate the scenarios that our calculus captures.
</summary>
    <author>
      <name>Matteo Cimini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Massachusetts Lowell, USA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.365.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.365.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings ICE 2022, arXiv:2208.04086</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 365, 2022, pp. 69-84</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2208.04635v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.04635v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.08732v1</id>
    <updated>2022-08-18T09:33:26Z</updated>
    <published>2022-08-18T09:33:26Z</published>
    <title>Complete Stream Fusion for Software-Defined Radio</title>
    <summary>  Software-Defined Radio (SDR) is widely used not only as a practical
application but also as a fitting benchmark of high-performance signal
processing. We report using the SDR benchmark -- specifically, FM Radio
reception -- to evaluate the recently developed single-thread stream processing
library strymonas, contrasting it with the synchronous dataflow system
StreamIt. Despite the absence of parallel processing or windowing as a core
primitive, strymonas turns out to easily support SDR, offering high
expressiveness and performance, approaching the peak single-core floating-point
performance, sufficient for real-time FM reception.
</summary>
    <author>
      <name>Tomoaki Kobayashi</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Tohoku University, Japan</arxiv:affiliation>
    </author>
    <author>
      <name>Oleg Kiselyov</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Tohoku University, Japan</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/2208.08732v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.08732v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.13741v2</id>
    <updated>2022-08-30T15:01:19Z</updated>
    <published>2022-08-29T17:23:37Z</published>
    <title>Recursive Session Logical Relations</title>
    <summary>  Program equivalence is the fulcrum for reasoning about and proving properties
of programs. For noninterference, for example, program equivalence up to the
secrecy level of an observer is shown. A powerful enabler for such proofs are
logical relations. Logical relations only recently were adopted for session
types--but exclusively for terminating languages. This paper scales logical
relations to recursive session types. It develops a logical relation for
progress-sensitive noninterference for linear session types, tackling the
challenges non-termination and concurrency pose. The contributions include
secrecy-polymorphic processes and the logical relation with metatheory. A
distinguishing feature is the choice of "step index" of the logical relation,
allowing for a natural proof of transitivity and soundness.
</summary>
    <author>
      <name>Farzaneh Derakhshan</name>
    </author>
    <author>
      <name>Stephanie Balzer</name>
    </author>
    <link href="http://arxiv.org/abs/2208.13741v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.13741v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2208.14260v1</id>
    <updated>2022-08-30T13:36:04Z</updated>
    <published>2022-08-30T13:36:04Z</published>
    <title>Program Equivalence in an Untyped, Call-by-value Lambda Calculus with
  Uncurried Recursive Functions</title>
    <summary>  We aim to reason about the correctness of behaviour-preserving
transformations of Erlang programs. Behaviour preservation is characterised by
semantic equivalence. Based upon our existing formal semantics for Core Erlang,
we investigate potential definitions of suitable equivalence relations. In
particular we adapt a number of existing approaches of expression equivalence
to a simple functional programming language that carries the main features of
sequential Core Erlang; we then examine the properties of the equivalence
relations and formally establish connections between them. The results
presented in this paper, including all theorems and their proofs, have been
machine checked using the Coq proof assistant.
</summary>
    <author>
      <name>Dániel Horpácsi</name>
    </author>
    <author>
      <name>Péter Bereczky</name>
    </author>
    <author>
      <name>Simon Thompson</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted to the Journal of Logical and Algebraic Methods in
  Programming</arxiv:comment>
    <link href="http://arxiv.org/abs/2208.14260v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2208.14260v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.01825v2</id>
    <updated>2022-10-13T20:55:57Z</updated>
    <published>2022-09-05T08:19:37Z</published>
    <title>Detecting Unjustified Assumptions in Subclasses via Elegant Objects
  Representation</title>
    <summary>  Elegant Objects (EO) is a programming language based on ideas of pure objects
and the Decorator pattern. Bugayenko has suggested it as an intermediate
representation for object-oriented programs. This paper presents a version of
dynamic dispatch modelled in EO and formulates a problem of unjustified
assumptions in decorator objects, which parallels similar problem in
subclasses. Then, we introduce an approach to detect such problems in EO
programs via method inlining and limited property inference. Finally, we
discuss prototype implementation of this approach in Scala programming
language.
</summary>
    <author>
      <name>Vitaliy Korbashov</name>
    </author>
    <author>
      <name>Nikolai Kudasov</name>
    </author>
    <author>
      <name>Mikhail Olokin</name>
    </author>
    <author>
      <name>Violetta Sim</name>
    </author>
    <link href="http://arxiv.org/abs/2209.01825v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.01825v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.05250v1</id>
    <updated>2022-09-08T20:16:41Z</updated>
    <published>2022-09-08T20:16:41Z</published>
    <title>Looplets: A Language For Structured Coiteration</title>
    <summary>  Real world arrays often contain underlying structure, such as sparsity, runs
of repeated values, or symmetry. Specializing for structure yields significant
speedups. But automatically generating efficient code for structured data is
challenging, especially when arrays with different structure interact. We show
how to abstract over array structures so that the compiler can generate code to
coiterate over any combination of them. Our technique enables new array formats
(such as 1DVBL for irregular clustered sparsity), new iteration strategies
(such as galloping intersections), and new operations over structured data
(such as concatenation or convolution).
</summary>
    <author>
      <name>Willow Ahrens</name>
    </author>
    <author>
      <name>Daniel Donenfeld</name>
    </author>
    <author>
      <name>Fredrik Kjolstad</name>
    </author>
    <author>
      <name>Saman Amarasinghe</name>
    </author>
    <link href="http://arxiv.org/abs/2209.05250v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.05250v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.MS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.08205v1</id>
    <updated>2022-09-17T00:44:54Z</updated>
    <published>2022-09-17T00:44:54Z</published>
    <title>Necessity Specifications for Robustness</title>
    <summary>  Robust modules guarantee to do only what they are supposed to do - even in
the presence of untrusted, malicious clients, and considering not just the
direct behaviour of individual methods, but also the emergent behaviour from
calls to more than one method. Necessity is a language for specifying
robustness, based on novel necessity operators capturing temporal implication,
and a proof logic that derives explicit robustness specifications from
functional specifications. Soundness and an exemplar proof are mechanised in
Coq.
</summary>
    <author>
      <name>Julian Mackay</name>
    </author>
    <author>
      <name>Sophia Drossopoulou</name>
    </author>
    <author>
      <name>James Noble</name>
    </author>
    <author>
      <name>Susan Eisenbach</name>
    </author>
    <link href="http://arxiv.org/abs/2209.08205v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.08205v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.08385v1</id>
    <updated>2022-09-17T18:25:08Z</updated>
    <published>2022-09-17T18:25:08Z</published>
    <title>langcc: A Next-Generation Compiler Compiler</title>
    <summary>  Traditionally, parsing has been a laborious and error-prone component of
compiler development, and most parsers for full industrial programming
languages are still written by hand. The author [Zim22] shows that automatic
parser generation can be practical, via a number of new innovations upon the
standard LR paradigm of Knuth et al. With this methodology, we can
automatically generate efficient parsers for virtually all languages that are
intuitively "easy to parse". This includes Golang 1.17.8 and Python 3.9.12, for
which our generated parsers are, respectively, 1.2x and 4.3x faster than the
standard parsers. This document is a companion technical report which describes
the software implementation of that work, which is available open-source at
https://github.com/jzimmerman/langcc.
</summary>
    <author>
      <name>Joe Zimmerman</name>
    </author>
    <link href="http://arxiv.org/abs/2209.08385v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.08385v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2209.10941v1</id>
    <updated>2022-09-22T11:46:03Z</updated>
    <published>2022-09-22T11:46:03Z</published>
    <title>Embedding generic monadic transformer into Scala</title>
    <summary>  Dotty-cps-async is an open-source package that consists of scala macro, which
implements generic async/await via monadic cps transform, and library, which
provides monadic substitutions for higher-order functions from the standard
library. It allows developers to use direct control flow constructions of the
base language instead of monadic DSL for various applications. Behind
well-known async/await operations, the package provides options for
transforming higher-order function applications, generating call-chain proxies,
and automatic coloring.
</summary>
    <author>
      <name>Ruslan Shevchenko</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-031-21314-4_1</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-031-21314-4_1" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted to publication into "Trends of Functional Programming 2022"</arxiv:comment>
    <link href="http://arxiv.org/abs/2209.10941v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2209.10941v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.00758v1</id>
    <updated>2022-10-03T08:26:44Z</updated>
    <published>2022-10-03T08:26:44Z</published>
    <title>Reflections on existential types</title>
    <summary>  Existential types are reconstructed in terms of small reflective subuniverses
and dependent sums. The folklore decomposition detailed here gives rise to a
particularly simple account of first-class modules as a mode of use of
traditional second-class modules in connection with the modal operator induced
by a reflective subuniverse, leading to a semantic justification for the rules
of first-class modules in languages like OCaml and MoscowML. Additionally, we
expose several constructions that give rise to semantic models of ML-style
programming languages with both first-class modules and realistic computational
effects, culminating in a model that accommodates higher-order first-class
recursive modules and higher-order store.
</summary>
    <author>
      <name>Jonathan Sterling</name>
    </author>
    <link href="http://arxiv.org/abs/2210.00758v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.00758v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.01047v1</id>
    <updated>2022-10-03T16:04:22Z</updated>
    <published>2022-10-03T16:04:22Z</published>
    <title>Testing by Dualization</title>
    <summary>  Software engineering requires rigorous testing to guarantee the product's
quality. Semantic testing of functional correctness is challenged by
nondeterminism in behavior, which makes testers difficult to write and reason
about.
  This thesis presents a language-based technique for testing interactive
systems. I propose a theory for specifying and validating nondeterministic
behaviors, with guaranteed soundness and correctness. I then apply the theory
to testing practices, and show how to derive specifications into interactive
tester programs. I also introduce a language design for producing test inputs
that can effectively detect and reproduce invalid behaviors.
  I evaluate the methodology by specifying and testing real-world systems such
as web servers and file synchronizers, demonstrating the derived testers'
ability to find disagreements between the specification and the implementation.
</summary>
    <author>
      <name>Yishuai Li</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">20.500.14332/32046</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/20.500.14332/32046" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Publicly Accessible Penn Dissertations 2022</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2210.01047v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.01047v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.02336v1</id>
    <updated>2022-09-21T02:54:23Z</updated>
    <published>2022-09-21T02:54:23Z</published>
    <title>An Integrated Web Platform for the Mizar Mathematical Library</title>
    <summary>  This paper reports on the development of a Web platform to host the Mizar
Mathematical Library (MML). In recent years, the size of formalized
mathematical libraries has been drastically increasing, and this has led to a
growing demand for tools that support efficient and comprehensive browsing,
searching, and annotation of these libraries. This platform implements a Wiki
function to add comments to the HTMLized MML, three types of search function
(article, symbol, and theorem), and a function to show the dependency graph of
the MML. This platform is designed with consistency, scalability, and
interoperability as top priorities for long-term use.
</summary>
    <author>
      <name>Hideharu Furushima</name>
    </author>
    <author>
      <name>Daichi Yamamichi</name>
    </author>
    <author>
      <name>Seigo Shigenaka</name>
    </author>
    <author>
      <name>Kazuhisa Nakasho</name>
    </author>
    <author>
      <name>Katsumi Wasaki</name>
    </author>
    <link href="http://arxiv.org/abs/2210.02336v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.02336v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68V25, 68V30, 68V35" scheme="http://arxiv.org/schemas/atom"/>
    <category term="G.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.03413v1</id>
    <updated>2022-10-07T09:13:44Z</updated>
    <published>2022-10-07T09:13:44Z</published>
    <title>Removing Qualified Names in Modular Languages</title>
    <summary>  Although the notion of qualified names is popular in module systems, it
causes severe complications. In this paper, we propose an alternative to
qualified names. The key idea is to import the declarations in other modules to
the current module before they are used. In this way, all the declarations can
be accessed locally. However, this approach is not efficient in memory usage.
Our contribution is the {\it module weakening} scheme which allows us to import
the minimal parts. As an example of this approach, we propose a module system
for functional languages.
</summary>
    <author>
      <name>Keehang Kwon</name>
    </author>
    <author>
      <name>Daeseong Kang</name>
    </author>
    <link href="http://arxiv.org/abs/2210.03413v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.03413v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.04729v1</id>
    <updated>2022-10-10T14:36:15Z</updated>
    <published>2022-10-10T14:36:15Z</published>
    <title>The Foil: Capture-Avoiding Substitution With No Sharp Edges</title>
    <summary>  Correctly manipulating program terms in a compiler is surprisingly difficult
because of the need to avoid name capture. The rapier from "Secrets of the
Glasgow Haskell Compiler inliner" is a cutting-edge technique for fast,
stateless capture-avoiding substitution for expressions represented with
explicit names. It is, however, a sharp tool: its invariants are tricky and
need to be maintained throughout the whole compiler that uses it. We describe
the foil, an elaboration of the rapier that uses Haskell's type system to
enforce the rapier's invariants statically, preventing a class of hard-to-find
bugs, but without adding any run-time overheads.
</summary>
    <author>
      <name>Dougal Maclaurin</name>
    </author>
    <author>
      <name>Alexey Radul</name>
    </author>
    <author>
      <name>Adam Paszke</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at IFL 2022</arxiv:comment>
    <link href="http://arxiv.org/abs/2210.04729v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.04729v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.08232v4</id>
    <updated>2023-06-06T12:01:01Z</updated>
    <published>2022-10-15T08:52:36Z</published>
    <title>A tutorial on implementing De Morgan cubical type theory</title>
    <summary>  This tutorial explains (one way) how to implement De Morgan cubical type
theory to people who know how to implement a dependent type theory. It contains
an introduction to basic concepts of cubes, type checking algorithms under a
cofibration, the idea of "transportation rules" and cubical operations. This
tutorial is a by-product of an experimental implementation of cubical type
theory, called Guest0x0.
</summary>
    <author>
      <name>Tesla Zhang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">27 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2210.08232v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.08232v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.11240v1</id>
    <updated>2022-10-07T02:21:38Z</updated>
    <published>2022-10-07T02:21:38Z</published>
    <title>Strong Normalization for the Calculus of Constructions</title>
    <summary>  The calculus of constructions (CC) is a core theory for dependently typed
programming and higher-order constructive logic. Originally introduced in
Coquand's 1985 thesis, CC has inspired 25 years of research in programming
languages and type theory. Today, extensions of CC form the basis of languages
like Coq and Agda. This survey reviews three proofs of CC's strong
normalization property (the fact that there are no infinite reduction sequences
from well-typed expressions). It highlights the similarities in the structure
of the proofs while showing how their differences are motivated by the varying
goals of their authors.
</summary>
    <author>
      <name>Chris Casinghino</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This survey was originally written to fulfill the written preliminary
  exam requirement of the University of Pennsylvania's computer science PhD
  program</arxiv:comment>
    <link href="http://arxiv.org/abs/2210.11240v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.11240v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2210.13873v1</id>
    <updated>2022-10-25T09:57:00Z</updated>
    <published>2022-10-25T09:57:00Z</published>
    <title>Program Synthesis Using Example Propagation</title>
    <summary>  We present Scrybe, an example-based synthesis tool for a statically-typed
functional programming language, which combines top-down deductive reasoning in
the style of $\lambda^2$ with Smyth-style live bidirectional evaluation. During
synthesis, example constraints are propagated through sketches to prune and
guide the search. This enables Scrybe to make more effective use of functions
provided in the context. To evaluate our tool, it is run on the combined,
largely disjoint, benchmarks of $\lambda^2$ and Myth. Scrybe is able to
synthesize most of the combined benchmark tasks.
</summary>
    <author>
      <name>Niek Mulleners</name>
    </author>
    <author>
      <name>Johan Jeuring</name>
    </author>
    <author>
      <name>Bastiaan Heeren</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">17 pages, 4 figures, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/2210.13873v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2210.13873v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2211.01473v2</id>
    <updated>2023-02-10T12:40:09Z</updated>
    <published>2022-11-02T20:33:32Z</published>
    <title>Fluent APIs in Functional Languages (full version)</title>
    <summary>  Fluent API is an object-oriented pattern for elegant APIs and embedded DSLs.
A smart fluent API can enforce the API protocol or DSL syntax at compile time.
As fluent API designs typically rely on function overloading, they are hard to
realize in functional programming languages. We show how to write functional
fluent APIs using parametric polymorphism and type inference instead of
overloading. Our designs support all regular and deterministic context-free API
protocols and beyond.
</summary>
    <author>
      <name>Ori Roth</name>
    </author>
    <author>
      <name>Yossi Gil</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3586057</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3586057" rel="related"/>
    <link href="http://arxiv.org/abs/2211.01473v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2211.01473v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2211.09923v1</id>
    <updated>2022-11-17T22:50:56Z</updated>
    <published>2022-11-17T22:50:56Z</published>
    <title>Proceedings of the 2nd Workshop on Logic and Practice of Programming
  (LPOP)</title>
    <summary>  This proceedings contains abstracts and position papers for the work
presented at the second Logic and Practice of Programming (LPOP) Workshop. The
workshop was held online, virtually in place of Chicago, USA, on November 15,
2010, in conjunction with the ACM SIGPLAN Conference on Systems, Programming,
Languages, and Applications: Software for Humanity (SPLASH) 2020. The purpose
of this workshop is to be a bridge between different areas of computer science
that use logic as a practical tool. We take advantage of the common language of
formal logic to exchange ideas between these different areas.
</summary>
    <author>
      <name>David S. Warren</name>
    </author>
    <author>
      <name>Peter Van Roy</name>
    </author>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <link href="http://arxiv.org/abs/2211.09923v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2211.09923v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2211.13461v1</id>
    <updated>2022-11-24T07:56:25Z</updated>
    <published>2022-11-24T07:56:25Z</published>
    <title>Highest-performance Stream Processing</title>
    <summary>  We present the stream processing library that achieves the highest
performance of existing OCaml streaming libraries, attaining the speed and
memory efficiency of hand-written state machines. It supports finite and
infinite streams with the familiar declarative interface, of any combination of
map, filter, take(while), drop(while), zip, flatmap combinators and tupling.
Experienced users may use the lower-level interface of stateful streams and
implement accumulating maps, compression and windowing. The library is based on
assured code generation (at present, of OCaml and C) and guarantees in all
cases complete fusion.
</summary>
    <author>
      <name>Oleg Kiselyov</name>
    </author>
    <author>
      <name>Tomoaki Kobayashi</name>
    </author>
    <author>
      <name>Aggelos Biboudis</name>
    </author>
    <author>
      <name>Nick Palladinos</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Peer-reviewed, accepted for presentation and presented at the ACM
  SIGPLAN OCAML 2022 workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2211.13461v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2211.13461v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DB" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.3; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.02754v2</id>
    <updated>2022-12-08T10:16:39Z</updated>
    <published>2022-12-06T05:11:21Z</published>
    <title>Automatically Transform Rust Source to Petri Nets for Checking Deadlocks</title>
    <summary>  This paper presents a method of automatically converting source codes (Rust
programs) into Petri nets, focusing on the detection of deadlocks caused by the
double locks and lock conflicts in the parallel Rust programs. We construct the
transformation rules and develop a tool. Our method can omit those Rust codes
without relations to locks when scanning the input codes, and thus tool can
handle a large-scale code. We do a number of experiments to show the advantages
of our method compared with the state-of-the-art ones.
</summary>
    <author>
      <name>Kaiwen Zhang</name>
    </author>
    <author>
      <name>Guanjun Liu</name>
    </author>
    <link href="http://arxiv.org/abs/2212.02754v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.02754v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.07329v2</id>
    <updated>2022-12-15T07:46:21Z</updated>
    <published>2022-12-14T16:49:28Z</published>
    <title>PSTMonitor: Monitor Synthesis from Probabilistic Session Types</title>
    <summary>  We present PSTMonitor, a tool for the run-time verification of quantitative
specifications of message-passing applications, based on probabilistic session
types. The key element of PSTMonitor is the detection of executions that
deviate from expected probabilistic behaviour. Besides presenting PSTMonitor
and its operation, the paper analyses its feasibility in terms of the runtime
overheads it induces.
</summary>
    <author>
      <name>Christian Bartolo Burlò</name>
    </author>
    <author>
      <name>Adrian Francalanza</name>
    </author>
    <author>
      <name>Alceste Scalas</name>
    </author>
    <author>
      <name>Catia Trubiani</name>
    </author>
    <author>
      <name>Emilio Tuosto</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1016/j.scico.2022.102847</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1016/j.scico.2022.102847" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">SI: Special Issue on Selected Tool Papers of the 22nd and 23rd
  International Conference on Coordination Models and Languages, COORDINATION
  2020 and 2021</arxiv:comment>
    <link href="http://arxiv.org/abs/2212.07329v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.07329v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.11245v1</id>
    <updated>2022-12-19T07:53:14Z</updated>
    <published>2022-12-19T07:53:14Z</published>
    <title>@C -- augmented version of C programming language</title>
    <summary>  The augmented version of C programming language is presented. The language
was completed with a series of low-level and high-level facilities to enlarge
the language usage spectrum to various computing systems, operations, users.
The ambiguities and inconsistencies have been resolved by managing problematic
and undefined languages elements through an interpretation and management
similar to that used in the case of other C syntax based languages. The
proposed augmentative completeness elements, through @C approach, preserve the
spirit of C language and its basic characteristics through compatibility with
the standard version but also allow rejuvenation and bring C language to the
present programming languages state of the art.
</summary>
    <author>
      <name>Iosif Iulian Petrila</name>
    </author>
    <link href="http://arxiv.org/abs/2212.11245v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.11245v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.FL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.11580v5</id>
    <updated>2024-05-31T14:02:34Z</updated>
    <published>2022-12-22T10:16:17Z</published>
    <title>A Theory of Conversion Relations for Prefixed Units of Measure</title>
    <summary>  Units of measure with prefixes and conversion rules are given a formal
semantic model in terms of categorial group theory. Basic structures and both
natural and contingent semantic operations are defined. Conversion rules are
represented as a class of ternary relations with both group-like and
category-like properties. A hierarchy of subclasses is explored, each
satisfying stronger useful algebraic properties than the preceding, culminating
in a direct efficient conversion-by-rewriting algorithm.
</summary>
    <author>
      <name>Baltasar Trancón y Widemann</name>
    </author>
    <author>
      <name>Markus Lepper</name>
    </author>
    <link href="http://arxiv.org/abs/2212.11580v5" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.11580v5" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.11637v1</id>
    <updated>2022-12-22T12:07:38Z</updated>
    <published>2022-12-22T12:07:38Z</published>
    <title>Time and Space Measures for a Complete Graph Computation Model</title>
    <summary>  We present a computation model based on a subclass of GP 2 graph programs
which can simulate any off-line Turing machine of space complexity O(s(n) log
s(n)) in space O(s(n)). The simulation only requires a quadratic time overhead.
Our model shares this property with Sch\"onhage's storage modification machines
and Kolmogorov-Uspenskii machines. These machines use low-level pointer
instructions whereas our GP 2-based model uses pattern-based transformation
rules and high-level control constructs.
</summary>
    <author>
      <name>Brian Courtehoute</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of York</arxiv:affiliation>
    </author>
    <author>
      <name>Detlef Plump</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of York</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.374.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.374.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings GCM 2022, arXiv:2212.10975</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 374, 2022, pp. 23-44</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2212.11637v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.11637v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.12320v1</id>
    <updated>2022-12-22T17:02:19Z</updated>
    <published>2022-12-22T17:02:19Z</published>
    <title>Architecture and Knowledge Representation for Composable Inductive
  Programming</title>
    <summary>  We present an update on the current architecture of the Zoea knowledge-based,
Composable Inductive Programming system. The Zoea compiler is built using a
modern variant of the black-board architecture. Zoea integrates a large number
of knowledge sources that encode different aspects of programming language and
software development expertise. We describe the use of synthetic test cases as
a ubiquitous form of knowledge and hypothesis representation that sup-ports a
variety of reasoning strategies. Some future plans are also outlined.
</summary>
    <author>
      <name>Edward McDaid</name>
    </author>
    <author>
      <name>Sarah McDaid</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">14 pages, 3 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2212.12320v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.12320v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.2; D.2.3; D.3.2; D.3.4; F.3.1; I.2.2; I.2.4; I.2.5; I.2.11" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2212.14129v1</id>
    <updated>2022-12-29T00:10:31Z</updated>
    <published>2022-12-29T00:10:31Z</published>
    <title>Matchertext: Towards Verbatim Interlanguage Embedding</title>
    <summary>  Embedding text in one language within text of another is commonplace for
numerous purposes, but usually requires tedious and error-prone "escaping"
transformations on the embedded string. We propose a simple cross-language
syntactic discipline, matchertext, which enables the safe embedding a string in
any compliant language into a string in any other language via simple
"copy-and-paste" - in particular with no escaping, obfuscation, or expansion of
embedded strings. We apply this syntactic discipline to several common and
frequently-embedded language syntaxes such as URIs, HTML, and JavaScript,
exploring the benefits, costs, and compatibility issues in adopting the
proposed matchertext discipline. One early matchertext-based language is MinML,
a concise but general alternative syntax for writing HTML or XML.
</summary>
    <author>
      <name>Bryan Ford</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">23 pages, 4 figures, 2 tables</arxiv:comment>
    <link href="http://arxiv.org/abs/2212.14129v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2212.14129v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2301.01188v4</id>
    <updated>2024-08-27T13:28:52Z</updated>
    <published>2022-12-29T01:07:19Z</published>
    <title>Deep R Programming</title>
    <summary>  Deep R Programming is a comprehensive and in-depth introductory course on one
of the most popular languages for data science. It equips ambitious students,
professionals, and researchers with the knowledge and skills to become
independent users of this potent environment so that they can tackle any
problem related to data wrangling and analytics, numerical computing,
statistics, and machine learning. This textbook is a non-profit project. Its
online and PDF versions are freely available at
&lt;https://deepr.gagolewski.com/&gt;.
</summary>
    <author>
      <name>Marek Gagolewski</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5281/zenodo.7490464</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5281/zenodo.7490464" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">v1.0.1 (2024-08-27)</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Zenodo, Melbourne, ISBN: 978-0-6455719-2-9 (2024)
  https://deepr.gagolewski.com/</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2301.01188v4" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2301.01188v4" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.AP" scheme="http://arxiv.org/schemas/atom"/>
    <category term="stat.CO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2301.02194v1</id>
    <updated>2023-01-05T17:55:56Z</updated>
    <published>2023-01-05T17:55:56Z</published>
    <title>Builtin Types viewed as Inductive Families</title>
    <summary>  State of the art optimisation passes for dependently typed languages can help
erase the redundant information typical of invariant-rich data structures and
programs. These automated processes do not dramatically change the structure of
the data, even though more efficient representations could be available.
  Using Quantitative Type Theory, we demonstrate how to define an
invariant-rich, typechecking time data structure packing an efficient runtime
representation together with runtime irrelevant invariants. The compiler can
then aggressively erase all such invariants during compilation.
  Unlike other approaches, the complexity of the resulting representation is
entirely predictable, we do not require both representations to have the same
structure, and yet we are able to seamlessly program as if we were using the
high-level structure.
</summary>
    <author>
      <name>Guillaume Allais</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">32 pages, accepted for publication at ESOP'23</arxiv:comment>
    <link href="http://arxiv.org/abs/2301.02194v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2301.02194v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2301.04862v1</id>
    <updated>2023-01-12T08:13:43Z</updated>
    <published>2023-01-12T08:13:43Z</published>
    <title>Naturalistic Static Program Analysis</title>
    <summary>  Static program analysis development is a non-trivial and time-consuming task.
We present a framework through which developers can define static program
analyses in natural language. We show the application of this framework to
identify cryptography misuses in Java programs, and we discuss how it
facilitates static program analysis development for developers.
</summary>
    <author>
      <name>Mohammad Mehdi Pourhashem Kallehbasti</name>
    </author>
    <author>
      <name>Mohammad Ghafari</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">The 30th IEEE International Conference on Software Analysis,
  Evolution and Reengineering, March 21st-24th, 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2301.04862v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2301.04862v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2301.05162v1</id>
    <updated>2023-01-12T17:30:12Z</updated>
    <published>2023-01-12T17:30:12Z</published>
    <title>Duoidally enriched Freyd categories</title>
    <summary>  Freyd categories provide a semantics for first-order effectful programming
languages by capturing the two different orders of evaluation for products. We
enrich Freyd categories in a duoidal category, which provides a new, third
choice of parallel composition. Duoidal categories have two monoidal structures
which account for the sequential and parallel compositions. The traditional
setting is recovered as a full coreflective subcategory for a judicious choice
of duoidal category. We give several worked examples of this uniform framework,
including the parameterised state monad, basic separation semantics for
resources, and interesting cases of change of enrichment
</summary>
    <author>
      <name>Chris Heunen</name>
    </author>
    <author>
      <name>Jesse Sigal</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1007/978-3-031-28083-2_15</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1007/978-3-031-28083-2_15" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear at RAMiCS 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2301.05162v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2301.05162v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2302.00558v1</id>
    <updated>2023-02-01T16:24:45Z</updated>
    <published>2023-02-01T16:24:45Z</published>
    <title>Ideas for the future of Prolog inspired by Oz</title>
    <summary>  Both Prolog and Oz are multiparadigm languages with a logic programming core.
There is a significant subset of Oz that is a syntactic variant of Prolog: pure
Prolog programs with green or blue cuts and bagof/3 or setof/3 can be
translated directly to Oz. Because of this close relationship between Prolog
and Oz, we propose that the extensions made by Oz to logic programming can be
an inspiration for the future evolution of Prolog. We explain three extensions,
namely deterministic logic programming, lazy concurrent functional programming,
and purely functional distributed computing. We briefly present these
extensions and we explain how they can help Prolog evolve in its next 50 years.
</summary>
    <author>
      <name>Peter Van Roy</name>
    </author>
    <author>
      <name>Seif Haridi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 0 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2302.00558v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2302.00558v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2302.02462v1</id>
    <updated>2023-02-05T19:12:07Z</updated>
    <published>2023-02-05T19:12:07Z</published>
    <title>The Marriage of Effects and Rewrites</title>
    <summary>  In the research on computational effects, defined algebraically, effect
symbols are often expected to obey certain equations. If we orient these
equations, we get a rewrite system, which may be an effective way of
transforming or optimizing the effects in a program. In order to do so, we need
to establish strong normalization, or termination, of the rewrite system. Here
we define a framework for carrying out such proofs, and extend the well-known
Recursive Path Ordering of Dershowitz to show termination of some effect
systems.
</summary>
    <author>
      <name>Ezra e. k. Cooper</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">15 pages, 2 figures. Submitted to FSCD 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2302.02462v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2302.02462v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.4.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2302.05792v1</id>
    <updated>2023-02-11T22:04:18Z</updated>
    <published>2023-02-11T22:04:18Z</published>
    <title>An Evaluation Algorithm for Datalog with Equality</title>
    <summary>  We describe an evaluation algorithm for relational Horn logic (RHL). RHL
extends Datalog with quantification over sorts, existential quantification in
conclusions and, crucially, the ability to infer equalities. These capabilities
allow RHL evaluation to subsume and expand applications of Datalog and
congruence closure algorithms.
  We explain how aspects of a fast congruence closure algorithm can be
incorporated into Datalog evaluation to obtain an efficient RHL evaluation
algorithm. We then sketch how Steensgaard's points-to analysis and type
inference can be implemented using RHL evaluation. RHL and the evaluation
algorithm described here are the foundation of the Eqlog Datalog engine.
</summary>
    <author>
      <name>Martin E. Bidlingmaier</name>
    </author>
    <link href="http://arxiv.org/abs/2302.05792v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2302.05792v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="03C05" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2302.08775v3</id>
    <updated>2024-11-11T10:28:02Z</updated>
    <published>2023-02-17T09:24:41Z</published>
    <title>Triemaps that match</title>
    <summary>  The trie data structure is a good choice for finite maps whose keys are data
structures (trees) rather than atomic values. But what if we want the keys to
be patterns, each of which matches many lookup keys? Efficient matching of this
kind is well studied in the theorem prover community, but much less so in the
context of statically typed functional programming. Doing so yields an
interesting new viewpoint -- and a practically useful design pattern, with good
runtime performance.
</summary>
    <author>
      <name>Simon Peyton Jones</name>
    </author>
    <author>
      <name>Sebastian Graf</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Rejected from ICFP 2022; lack of novelty, too heavy on code that is
  "tiresome boilerplate". Accepted for a Festschrift in honour of Alan Mycroft</arxiv:comment>
    <link href="http://arxiv.org/abs/2302.08775v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2302.08775v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2303.10381v1</id>
    <updated>2023-03-18T10:12:07Z</updated>
    <published>2023-03-18T10:12:07Z</published>
    <title>Modelling Chess in VDM++</title>
    <summary>  The game of chess is well-known and widely played all over the world.
However, the rules for playing it are rather complex since there are different
types of pieces and the ways they are allowed to move depend upon the type of
the piece. In this paper we discuss alternative paradigms that can be used for
modelling the rule of the chess game using VDM++ and show what we believe is
the best model. It is also illustrated how this model can be connected to a
standard textual notation for the moves in a chess game. This can be used to
combine the formal model to a more convenient interface.
</summary>
    <author>
      <name>Morten Haahr Kristensen</name>
    </author>
    <author>
      <name>Peter Gorm Larsen</name>
    </author>
    <link href="http://arxiv.org/abs/2303.10381v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2303.10381v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2303.10515v1</id>
    <updated>2023-03-18T23:14:04Z</updated>
    <published>2023-03-18T23:14:04Z</published>
    <title>Ownership guided C to Rust translation</title>
    <summary>  Dubbed a safer C, Rust is a modern programming language that combines memory
safety and low-level control. This interesting combination has made Rust very
popular among developers and there is a growing trend of migrating legacy
codebases (very often in C) to Rust. In this paper, we present a C to Rust
translation approach centred around static ownership analysis. We design a
suite of analyses that infer ownership models of C pointers and automatically
translate the pointers into safe Rust equivalents. The resulting tool, Crown,
scales to real-world codebases (half a million lines of code in less than 10
seconds) and achieves a high conversion rate.
</summary>
    <author>
      <name>Hanliang Zhang</name>
    </author>
    <author>
      <name>Cristina David</name>
    </author>
    <author>
      <name>Yijun Yu</name>
    </author>
    <author>
      <name>Meng Wang</name>
    </author>
    <link href="http://arxiv.org/abs/2303.10515v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2303.10515v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2303.15784v1</id>
    <updated>2023-03-28T07:52:50Z</updated>
    <published>2023-03-28T07:52:50Z</published>
    <title>Ideograph: A Language for Expressing and Manipulating Structured Data</title>
    <summary>  We introduce Ideograph, a language for expressing and manipulating structured
data. Its types describe kinds of structures, such as natural numbers, lists,
multisets, binary trees, syntax trees with variable binding, directed
multigraphs, and relational databases. Fully normalized terms of a type
correspond exactly to members of the structure, analogous to a Church-encoding.
Moreover, definable operations over these structures are guaranteed to respect
the structures' equivalences. In this paper, we give the syntax and semantics
of the non-polymorphic subset of Ideograph, and we demonstrate how it can
represent and manipulate several interesting structures.
</summary>
    <author>
      <name>Stephen Mell</name>
    </author>
    <author>
      <name>Osbert Bastani</name>
    </author>
    <author>
      <name>Steve Zdancewic</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.377.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.377.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TERMGRAPH 2022, arXiv:2303.14219</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 377, 2023, pp. 65-84</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2303.15784v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2303.15784v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2303.16048v3</id>
    <updated>2023-08-17T07:09:28Z</updated>
    <published>2023-03-28T15:27:10Z</published>
    <title>Amortized Analysis via Coinduction</title>
    <summary>  Amortized analysis is a program cost analysis technique for data structures
in which the cost of operations is specified in aggregate, under the assumption
of continued sequential use. Typically, amortized analyses are presented
inductively, in terms of finite sequences of operations. We give an alternative
coinductive formulation and prove that it is equivalent to the standard
inductive definition. We describe a classic amortized data structure, the
batched queue, and outline a coinductive proof of its amortized efficiency in
$\textbf{calf}$, a dependent type theory for cost analysis.
</summary>
    <author>
      <name>Harrison Grodin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <author>
      <name>Robert Harper</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Carnegie Mellon University</arxiv:affiliation>
    </author>
    <link href="http://arxiv.org/abs/2303.16048v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2303.16048v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.03764v1</id>
    <updated>2023-04-07T17:57:50Z</updated>
    <published>2023-04-07T17:57:50Z</published>
    <title>Parameterized Algebraic Protocols</title>
    <summary>  We propose algebraic protocols that enable the definition of protocol
templates and session types analogous to the definition of domain-specific
types with algebraic datatypes. Parameterized algebraic protocols subsume all
regular as well as most context-free and nested session types and, at the same
time, replace the expensive superlinear algorithms for type checking by a
nominal check that runs in linear time. Algebraic protocols in combination with
polymorphism increase expressiveness and modularity by facilitating new ways of
parameterizing and composing session types.
</summary>
    <author>
      <name>Andreia Mordido</name>
    </author>
    <author>
      <name>Janek Spaderna</name>
    </author>
    <author>
      <name>Peter Thiemann</name>
    </author>
    <author>
      <name>Vasco T. Vasconcelos</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3591277</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3591277" rel="related"/>
    <link href="http://arxiv.org/abs/2304.03764v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.03764v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.04886v1</id>
    <updated>2023-04-10T22:15:22Z</updated>
    <published>2023-04-10T22:15:22Z</published>
    <title>Make flows small again: revisiting the flow framework</title>
    <summary>  We present a new flow framework for separation logic reasoning about programs
that manipulate general graphs. The framework overcomes problems in earlier
developments: it is based on standard fixed point theory, guarantees least
flows, rules out vanishing flows, and has an easy to understand notion of
footprint as needed for soundness of the frame rule. In addition, we present
algorithms for automating the frame rule, which we evaluate on graph updates
extracted from linearizability proofs for concurrent data structures. The
evaluation demonstrates that our algorithms help to automate key aspects of
these proofs that have previously relied on user guidance or heuristics.
</summary>
    <author>
      <name>Roland Meyer</name>
    </author>
    <author>
      <name>Thomas Wies</name>
    </author>
    <author>
      <name>Sebastian Wolff</name>
    </author>
    <link href="http://arxiv.org/abs/2304.04886v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.04886v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.06397v1</id>
    <updated>2023-04-13T11:02:36Z</updated>
    <published>2023-04-13T11:02:36Z</published>
    <title>A Declarative Validator for GSOS Languages</title>
    <summary>  Rule formats can quickly establish meta-theoretic properties of process
algebras. It is then desirable to identify domain-specific languages (DSLs)
that can easily express rule formats. In prior work, we have developed
Lang-n-Change, a DSL that includes convenient features for browsing language
definitions and retrieving information from them. In this paper, we use
Lang-n-Change to write a validator for the GSOS rule format, and we augment
Lang-n-Change with suitable macros on our way to do so. Our GSOS validator is
concise, and amounts to a few lines of code. We have used it to validate
several concurrency operators as adhering to the GSOS format. Moreover, our
code expresses the restrictions of the format declaratively.
</summary>
    <author>
      <name>Matteo Cimini</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">University of Massachusetts Lowell</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.378.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.378.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2023, arXiv:2304.05439</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 378, 2023, pp. 14-25</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2304.06397v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.06397v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.06399v1</id>
    <updated>2023-04-13T11:03:08Z</updated>
    <published>2023-04-13T11:03:08Z</published>
    <title>Choreographic Programming of Isolated Transactions</title>
    <summary>  Implementing distributed systems is hard; choreographic programming aims to
make it easier. In this paper, we present the design of a new choreographic
programming language that supports isolated transactions among overlapping sets
of processes. The first idea is to track for every variable which processes are
permitted to use it. The second idea is to use model checking to prove
isolation.
</summary>
    <author>
      <name>Ton Smeele</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Open University of the Netherlands</arxiv:affiliation>
    </author>
    <author>
      <name>Sung-Shik Jongmans</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Open University of the Netherlands, Centrum Wiskunde &amp; Informatica</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.378.5</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.378.5" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings PLACES 2023, arXiv:2304.05439</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 378, 2023, pp. 49-60</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2304.06399v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.06399v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2304.15006v1</id>
    <updated>2023-04-01T13:34:10Z</updated>
    <published>2023-04-01T13:34:10Z</published>
    <title>Topologically sorting VDM-SL definitions for Isabelle/HOL translation</title>
    <summary>  There is an ecosystem of VDM libraries and extensions that includes a
translation and proof environment for VDM in Isabelle. Translation works for a
large subset of VDM-SL and further constructs are being added on demand. A key
impediment for novice users is that Isabelle/HOL requires all definitions to be
declared before they are used, where (mutually) recursive definitions must be
defined in tandem. In this paper, we describe a solution to this problem, which
will enable wider access to the translator plugin for novice users as well as
real models.
</summary>
    <author>
      <name>Leo Freitas</name>
    </author>
    <link href="http://arxiv.org/abs/2304.15006v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2304.15006v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2305.02991v1</id>
    <updated>2023-05-04T16:58:02Z</updated>
    <published>2023-05-04T16:58:02Z</published>
    <title>Notes on Refactoring Exponential Macros in Common Lisp</title>
    <summary>  I recently consulted for a very big Common Lisp project having more than one
million lines of code (including comments). Let's call it "System X" in the
following. System X suffered from extremely long compilation times; i.e., a
full recompile took about 33:17 minutes on a 3.1 GHz MacBook Pro Intel Core i7
with SSD and 16 GBs of RAM, using ACL 10.1. It turns out that a number of
macros were causing an exponential code blowup. With these macros refactored,
the system then recompiled in 5:30 minutes - a speedup by a factor of ~ 6. In
this experience report, I will first illuminate the problem, and then
demonstrate two potential solutions in terms of macro refactoring techniques.
These techniques can be applied in related scenarios.
</summary>
    <author>
      <name>Michael Wessel</name>
    </author>
    <link href="http://arxiv.org/abs/2305.02991v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2305.02991v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2305.04311v2</id>
    <updated>2024-04-05T16:40:43Z</updated>
    <published>2023-05-07T15:35:17Z</published>
    <title>Egglog Python: A Pythonic Library for E-graphs</title>
    <summary>  E-graphs have emerged as a versatile data structure with applications in
synthesis, optimization, and verification through techniques such as equality
saturation. This paper introduces Python bindings for the experimental egglog
library (previously called egg-smol), which aims to bring the benefits of
e-graphs to the Python ecosystem. The bindings offer a high-level, Pythonic API
providing an accessible and familiar interface for Python users. By integrating
e-graph techniques with Python, we hope to enable collaboration and innovation
across various domains in the scientific computing and machine learning
communities. We discuss the advantages of using Python bindings for both Python
and existing egg-smol users, as well as possible future directions for
development.
</summary>
    <author>
      <name>Saul Shanabrook</name>
    </author>
    <link href="http://arxiv.org/abs/2305.04311v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2305.04311v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2305.06223v1</id>
    <updated>2023-05-08T19:21:41Z</updated>
    <published>2023-05-08T19:21:41Z</published>
    <title>ComputeGPT: A computational chat model for numerical problems</title>
    <summary>  Language models are not accurate in numerical problems. Their architecture
does not allow for anything less than a probabilistic next word. This paper
introduces ComputeGPT: an approach of creating a chat model able to answer
computational problems through running on-demand code. ComputeGPT converts each
question to relevant code, runs the code, and returns the computed answer as
part of the chat. We combine this approach with a local browser-based Python
interpretation and fine-tuned prompts in order to achieve state-of-the-art
efficiency on numerical problems and provide a suitable front-end and safe
environment for the code to be executed in.
</summary>
    <author>
      <name>Ryan Hardesty Lewis</name>
    </author>
    <author>
      <name>Junfeng Jiao</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">12 pages, 2 figures</arxiv:comment>
    <link href="http://arxiv.org/abs/2305.06223v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2305.06223v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="68T50, 68N18, 97R50" scheme="http://arxiv.org/schemas/atom"/>
    <category term="I.2.7; I.2.6; H.5.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2305.09580v1</id>
    <updated>2023-05-16T16:27:51Z</updated>
    <published>2023-05-16T16:27:51Z</published>
    <title>Generate Compilers from Hardware Models!</title>
    <summary>  Compiler backends should be automatically generated from hardware design
language (HDL) models of the hardware they target. Generating compiler
components directly from HDL can provide stronger correctness guarantees, ease
development effort, and encourage hardware exploration. Past work has already
championed this idea; here we argue that advances in program synthesis make the
approach more feasible. We present a concrete example by demonstrating how FPGA
technology mappers can be automatically generated from SystemVerilog models of
an FPGA's primitives using program synthesis.
</summary>
    <author>
      <name>Gus Henry Smith</name>
    </author>
    <author>
      <name>Ben Kushigian</name>
    </author>
    <author>
      <name>Vishal Canumalla</name>
    </author>
    <author>
      <name>Andrew Cheung</name>
    </author>
    <author>
      <name>René Just</name>
    </author>
    <author>
      <name>Zachary Tatlock</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">3 pages, 2 figures, to be presented at the 2023 PLARCH Workshop at
  FCRC</arxiv:comment>
    <link href="http://arxiv.org/abs/2305.09580v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2305.09580v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2306.02073v2</id>
    <updated>2023-07-14T13:50:45Z</updated>
    <published>2023-06-03T10:34:46Z</published>
    <title>Verifying C++ Dynamic Binding</title>
    <summary>  We propose an approach for modular verification of programs written in an
object-oriented language where, like in C++, the same virtual method call is
bound to different methods at different points during the construction or
destruction of an object. Our separation logic combines Parkinson and Bierman's
abstract predicate families with essentially explicitly tracking each
subobject's vtable pointer. Our logic supports polymorphic destruction. Virtual
inheritance is not yet supported. We formalised our approach and implemented it
in our VeriFast tool for semi-automated modular formal verification of C++
programs.
</summary>
    <author>
      <name>Niels Mommen</name>
    </author>
    <author>
      <name>Bart Jacobs</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">9 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2306.02073v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2306.02073v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.04960v1</id>
    <updated>2023-07-11T01:42:10Z</updated>
    <published>2023-07-11T01:42:10Z</published>
    <title>Simple Reference Immutability for System F-sub</title>
    <summary>  Reference immutability is a type based technique for taming mutation that has
long been studied in the context of object-oriented languages, like Java.
Recently, though, languages like Scala have blurred the lines between
functional programming languages and object oriented programming languages. We
explore how reference immutability interacts with features commonly found in
these hybrid languages, in particular with higher-order functions --
polymorphism -- and subtyping. We construct a calculus System F-sub-M which
encodes a reference immutability system as a simple extension of F-sub and
prove that it satisfies the standard soundness and immutability safety
properties.
</summary>
    <author>
      <name>Edward Lee</name>
    </author>
    <author>
      <name>Ondřej Lhoták</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3622828</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3622828" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">25 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.04960v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.04960v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.05557v1</id>
    <updated>2023-07-09T15:51:01Z</updated>
    <published>2023-07-09T15:51:01Z</published>
    <title>Type-Preserving Compilation of Class-Based Languages</title>
    <summary>  The Dependent Object Type (DOT) calculus was designed to put Scala on a sound
basis, but while DOT relies on structural subtyping, Scala is a fundamentally
class-based language. This impedance mismatch means that a proof of DOT
soundness by itself is not enough to declare a particular subset of the
language as sound. While a few examples of Scala snippets have been manually
translated into DOT, no systematic compilation scheme has been presented so
far. In this thesis we develop a series of calculi of increasing complexity to
model Scala and present a type-preserving compilation scheme from each of these
calculus into DOT. Along the way, we develop some necessary extensions to DOT.
</summary>
    <author>
      <name>Guillaume Martres</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.5075/epfl-thesis-8218</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.5075/epfl-thesis-8218" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">153 pages, officially accepted doctoral thesis</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.05557v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.05557v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.07069v1</id>
    <updated>2023-07-13T21:23:31Z</updated>
    <published>2023-07-13T21:23:31Z</published>
    <title>Typed Design Patterns for the Functional Era</title>
    <summary>  This paper explores how design patterns could be revisited in the era of
mainstream functional programming languages. I discuss the kinds of knowledge
that ought to be represented as functional design patterns: architectural
concepts that are relatively self-contained, but whose entirety cannot be
represented as a language-level abstraction. I present four concrete examples
embodying this idea: the Witness, the State Machine, the Parallel Lists, and
the Registry. Each pattern is implemented in Rust to demonstrate how careful
use of a sophisticated type system can better model each domain construct and
thereby catch user mistakes at compile-time.
</summary>
    <author>
      <name>Will Crichton</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3609025.3609477</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3609025.3609477" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear at FUNARCH'23 @ ICFP</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.07069v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.07069v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.09951v1</id>
    <updated>2023-07-19T12:46:50Z</updated>
    <published>2023-07-19T12:46:50Z</published>
    <title>Symbolic Semantics for Probabilistic Programs (extended version)</title>
    <summary>  We present a new symbolic execution semantics of probabilistic programs that
include observe statements and sampling from continuous distributions. Building
on Kozen's seminal work, this symbolic semantics consists of a countable
collection of measurable functions, along with a partition of the state space.
We use the new semantics to provide a full correctness proof of symbolic
execution for probabilistic programs. We also implement this semantics in the
tool symProb, and illustrate its use on examples.
</summary>
    <author>
      <name>Erik Voogd</name>
    </author>
    <author>
      <name>Einar Broch Johnsen</name>
    </author>
    <author>
      <name>Alexandra Silva</name>
    </author>
    <author>
      <name>Zachary J. Susag</name>
    </author>
    <author>
      <name>Andrzej Wąsowski</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">38 pages including references and appendices, 14 pages excluding,
  accepted at QEST'23, to appear in LNCS, Springer</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.09951v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.09951v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.11194v1</id>
    <updated>2023-07-20T19:11:54Z</updated>
    <published>2023-07-20T19:11:54Z</published>
    <title>An Exceptional Actor System (Functional Pearl)</title>
    <summary>  The Glasgow Haskell Compiler is known for its feature-laden runtime system
(RTS), which includes lightweight threads, asynchronous exceptions, and a slew
of other features. Their combination is powerful enough that a programmer may
complete the same task in many different ways -- some more advisable than
others.
  We present a user-accessible actor framework hidden in plain sight within the
RTS and demonstrate it on a classic example from the distributed systems
literature. We then extend both the framework and example to the realm of
dynamic types. Finally, we raise questions about how RTS features intersect and
possibly subsume one another, and suggest that GHC can guide good practice by
constraining the use of some features.
</summary>
    <author>
      <name>Patrick Redmond</name>
    </author>
    <author>
      <name>Lindsey Kuper</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3609026.3609728</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3609026.3609728" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">To appear at Haskell Symposium 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.11194v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.11194v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.13661v2</id>
    <updated>2023-10-27T15:55:47Z</updated>
    <published>2023-07-25T17:14:49Z</published>
    <title>Parametric Subtyping for Structural Parametric Polymorphism</title>
    <summary>  We study the interaction of structural subtyping with parametric polymorphism
and recursively defined type constructors. Although structural subtyping is
undecidable in this setting, we describe a notion of parametricity for type
constructors and then exploit it to define parametric subtyping, a conceptually
simple, decidable, and expressive fragment of structural subtyping that
strictly generalizes rigid subtyping. We present and prove correct an effective
saturation-based decision procedure for parametric subtyping, demonstrating its
applicability using a variety of examples. We also provide an implementation of
this decision procedure online.
</summary>
    <author>
      <name>Henry DeYoung</name>
    </author>
    <author>
      <name>Andreia Mordido</name>
    </author>
    <author>
      <name>Frank Pfenning</name>
    </author>
    <author>
      <name>Ankush Das</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">36 pages</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.13661v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.13661v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.16073v1</id>
    <updated>2023-07-29T20:46:35Z</updated>
    <published>2023-07-29T20:46:35Z</published>
    <title>Ad-hoc polymorphic delimited continuations</title>
    <summary>  We designed and implemented a framework for creating extensible
domain-specific languages that consists of library-defined keywords.
First-class language features in other programming languages can be implemented
as libraries with the help of our framework. The core concept in our framework
is the type class Dsl, which can be considered as both the ad-hoc polymorphic
version of a delimited continuation and a more generic version of Monad. Thus
it can be also used as a statically typed extensible effect system that is more
efficient and more concise than existing Monad-based effect systems.
</summary>
    <author>
      <name>Bo Yang</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">44 pages, 2 figures, 6 tables, 81 listings</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.16073v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.16073v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2307.16270v2</id>
    <updated>2023-10-07T20:07:45Z</updated>
    <published>2023-07-30T16:32:19Z</published>
    <title>Formalizing Monoidal Categories and Actions for Syntax with Binders</title>
    <summary>  We discuss some aspects of our work on the mechanization of syntax and
semantics in the UniMath library, based on the proof assistant Coq. We focus on
experiences where Coq (as a type-theoretic proof assistant with decidable
typechecking) made us use more theory or helped us to see theory more clearly.
</summary>
    <author>
      <name>Benedikt Ahrens</name>
    </author>
    <author>
      <name>Ralph Matthes</name>
    </author>
    <author>
      <name>Kobe Wullaert</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Abstract for a talk at CoqPL 2023,
  https://popl23.sigplan.org/details/CoqPL-2023-papers/7/Formalizing-Monoidal-Categories-and-Actions-for-Syntax-with-Binders</arxiv:comment>
    <link href="http://arxiv.org/abs/2307.16270v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2307.16270v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.CT" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2308.06956v1</id>
    <updated>2023-08-14T06:20:32Z</updated>
    <published>2023-08-14T06:20:32Z</published>
    <title>Modular System Synthesis</title>
    <summary>  This paper describes a way to improve the scalability of program synthesis by
exploiting modularity: larger programs are synthesized from smaller programs.
The key issue is to make each "larger-created-from-smaller" synthesis
sub-problem be of a similar nature, so that the kind of synthesis sub-problem
that needs to be solved--and the size of each search space--has roughly the
same character at each level. This work holds promise for creating
program-synthesis tools that have far greater capabilities than currently
available tools, and opens new avenues for synthesis research: how synthesis
tools should support modular system design, and how synthesis applications can
best exploit such capabilities.
</summary>
    <author>
      <name>Kanghee Park</name>
    </author>
    <author>
      <name>Keith J. C. Johnson</name>
    </author>
    <author>
      <name>Loris D'Antoni</name>
    </author>
    <author>
      <name>Thomas Reps</name>
    </author>
    <link href="http://arxiv.org/abs/2308.06956v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2308.06956v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2308.06971v1</id>
    <updated>2023-08-14T07:09:15Z</updated>
    <published>2023-08-14T07:09:15Z</published>
    <title>Disco: A Functional Programming Language for Discrete Mathematics</title>
    <summary>  Disco is a pure, strict, statically typed functional programming language
designed to be used in the setting of a discrete mathematics course. The goals
of the language are to introduce students to functional programming concepts
early, and to enhance their learning of mathematics by providing a
computational platform for them to play with. It features
mathematically-inspired notation, property-based testing, equirecursive
algebraic types, subtyping, built-in list, bag, and finite set types, a REPL,
and student-focused documentation. Disco is implemented in Haskell, with source
code available on GitHub [https://github.com/disco-lang/disco], and interactive
web-based REPL available through replit
[https://replit.com/@BrentYorgey/Disco#README.md].
</summary>
    <author>
      <name>Brent A. Yorgey</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Hendrix College</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.382.4</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.382.4" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings TFPIE 2023, arXiv:2308.06110</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 382, 2023, pp. 64-81</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2308.06971v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2308.06971v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DM" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1.1; G.2.0; K.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2308.09481v2</id>
    <updated>2023-09-04T12:50:26Z</updated>
    <published>2023-08-16T14:33:18Z</published>
    <title>Types, equations, dimensions and the Pi theorem</title>
    <summary>  The languages of mathematical physics and modelling are endowed with a rich
"grammar of dimensions" that common abstractions of programming languages fail
to represent. We propose a dependently typed domain-specific language (embedded
in Idris) that captures this grammar. We apply it to explain basic notions of
dimensional analysis and Buckingham's Pi theorem. We hope that the language
makes mathematical physics more accessible to computer scientists and
functional programming more palatable to modelers and physicists.
</summary>
    <author>
      <name>Nicola Botta</name>
    </author>
    <author>
      <name>Patrik Jansson</name>
    </author>
    <author>
      <name>Guilherme Horta Alvares Da Silva</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted for publication in the "Journal of Functional Programming"
  in August 2023</arxiv:comment>
    <link href="http://arxiv.org/abs/2308.09481v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2308.09481v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.01906v1</id>
    <updated>2023-09-05T02:41:47Z</updated>
    <published>2023-09-05T02:41:47Z</published>
    <title>Generalizing Hierarchical Parallelism</title>
    <summary>  Since the days of OpenMP 1.0 computer hardware has become more complex,
typically by specializing compute units for coarse- and fine-grained
parallelism in incrementally deeper hierarchies of parallelism. Newer versions
of OpenMP reacted by introducing new mechanisms for querying or controlling its
individual levels, each time adding another concept such as places, teams, and
progress groups. In this paper we propose going back to the roots of OpenMP in
the form of nested parallelism for a simpler model and more flexible handling
of arbitrary deep hardware hierarchies.
</summary>
    <author>
      <name>Michael Kruse</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">IWOMP'23 preprint</arxiv:comment>
    <link href="http://arxiv.org/abs/2309.01906v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.01906v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.07298v1</id>
    <updated>2023-09-13T20:49:19Z</updated>
    <published>2023-09-13T20:49:19Z</published>
    <title>Deriving Abstract Interpreters from Skeletal Semantics</title>
    <summary>  This paper describes a methodology for defining an executable abstract
interpreter from a formal description of the semantics of a programming
language. Our approach is based on Skeletal Semantics and an abstract
interpretation of its semantic meta-language. The correctness of the derived
abstract interpretation can be established by compositionality provided that
correctness properties of the core language-specific constructs are
established. We illustrate the genericness of our method by defining a Value
Analysis for a small imperative language based on its skeletal semantics.
</summary>
    <author>
      <name>Thomas Jensen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <author>
      <name>Vincent Rébiscoul</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">Universite de Rennes</arxiv:affiliation>
    </author>
    <author>
      <name>Alan Schmitt</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">INRIA</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.387.8</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.387.8" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings EXPRESS/SOS2023, arXiv:2309.05788</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 387, 2023, pp. 97-113</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2309.07298v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.07298v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.08207v1</id>
    <updated>2023-09-15T07:15:00Z</updated>
    <published>2023-09-15T07:15:00Z</published>
    <title>MetaOCaml Theory and Implementation</title>
    <summary>  Quasi-quotation (or, code templates) has long been used as a convenient tool
for code generation, commonly implemented as a pre-processing/translation into
code-generation combinators. The original MetaOCaml was also based on such
translation, done post type checking. BER MetaOCaml employs a significantly
different, efficient (especially in version N114) translation integrated with
type-checking, in the least intrusive way. This paper presents the integrated
efficient translation for the first time.
</summary>
    <author>
      <name>Oleg Kiselyov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Peer-reviewed, accepted for presentation and presented at the ACM
  SIGPLAN OCAML 2023 workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2309.08207v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.08207v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.08673v1</id>
    <updated>2023-09-15T18:04:35Z</updated>
    <published>2023-09-15T18:04:35Z</published>
    <title>A Two-Level Linear Dependent Type Theory</title>
    <summary>  We present a type theory combining both linearity and dependency by
stratifying typing rules into a level for logics and a level for programs. The
distinction between logics and programs decouples their semantics, allowing the
type system to assume tight resource bounds. A natural notion of irrelevancy is
established where all proofs and types occurring inside programs are fully
erasable without compromising their operational behavior. Through a heap-based
operational semantics, we show that extracted programs always make
computational progress and run memory clean. Additionally, programs can be
freely reflected into the logical level for conducting deep proofs in the style
of standard dependent type theories. This enables one to write resource safe
programs and verify their correctness using a unified language.
</summary>
    <author>
      <name>Qiancheng Fu</name>
    </author>
    <author>
      <name>Hongwei Xi</name>
    </author>
    <link href="http://arxiv.org/abs/2309.08673v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.08673v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2309.15724v1</id>
    <updated>2023-09-27T15:32:02Z</updated>
    <published>2023-09-27T15:32:02Z</published>
    <title>Making Logical Relations More Relatable (Proof Pearl)</title>
    <summary>  Mechanical proofs by logical relations often involve tedious reasoning about
substitution. In this paper, we show that this is not necessarily the case, by
developing, in Agda, a proof that all simply typed lambda calculus expressions
evaluate to values. A formalization of the proof is remarkably short (~40 lines
of code), making for an excellent introduction to the technique of proofs by
logical relations not only on paper but also in a mechanized setting. We then
show that this process extends to more sophisticated reasoning by also proving
the totality of normalization by evaluation. Although these proofs are not new,
we believe presenting them will empower both new and experienced programming
language theorists in their use of logical relations.
</summary>
    <author>
      <name>Emmanuel Suárez Acevedo</name>
    </author>
    <author>
      <name>Stephanie Weirich</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Submitted for publication</arxiv:comment>
    <link href="http://arxiv.org/abs/2309.15724v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2309.15724v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.01069v1</id>
    <updated>2023-10-02T10:25:31Z</updated>
    <published>2023-10-02T10:25:31Z</published>
    <title>Fully Abstract Normal Form Bisimulation for Call-by-Value PCF</title>
    <summary>  We present the first fully abstract normal form bisimulation for
call-by-value PCF (PCF$_{\textsf{v}}$). Our model is based on a labelled
transition system (LTS) that combines elements from applicative bisimulation,
environmental bisimulation and game semantics. In order to obtain completeness
while avoiding the use of semantic quotiening, the LTS constructs traces
corresponding to interactions with possible functional contexts. The model
gives rise to a sound and complete technique for checking of PCF$_{\textsf{v}}$
program equivalence, which we implement in a bounded bisimulation checking
tool. We test our tool on known equivalences from the literature and new
examples.
</summary>
    <author>
      <name>Vasileios Koutavas</name>
    </author>
    <author>
      <name>Yu-Yang Lin</name>
    </author>
    <author>
      <name>Nikos Tzevelekos</name>
    </author>
    <link href="http://arxiv.org/abs/2310.01069v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.01069v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.01961v2</id>
    <updated>2024-11-20T17:26:52Z</updated>
    <published>2023-10-03T11:12:51Z</published>
    <title>Soda: An Object-Oriented Functional Language for Specifying
  Human-Centered Problems</title>
    <summary>  We present Soda (Symbolic Objective Descriptive Analysis), a language that
helps to treat qualities and quantities in a natural way and greatly simplifies
the task of checking their correctness. We present key properties for the
language motivated by the design of a descriptive language to encode complex
requirements on computer systems, and we explain how these key properties must
be addressed to model these requirements with simple definitions. We give an
overview of a tool that helps to describe problems in an easy way that we
consider more transparent and less error-prone.
</summary>
    <author>
      <name>Julian Alfredo Mendez</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">https://julianmendez.github.io/soda</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.01961v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.01961v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.AI" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.08262v1</id>
    <updated>2023-10-12T12:07:05Z</updated>
    <published>2023-10-12T12:07:05Z</published>
    <title>Proceedings of The 2023 Scheme and Functional Programming Workshop</title>
    <summary>  This volume contains the articles presented at The 2023 Scheme and Functional
Programming Workshop in Seattle, Washington on September 9, 2023. The program
committee reviewed the articles using current academic standards and selected
four articles for presentation. These proceedings are considered non-archival
and the authors are free to submit revised versions of their articles to other
venues for archival publication.
  Program Committee: Leif Andersen, Northeastern University; Mark Friedman
  Leilani Gilpin, University of California, Santa Cruz; Jason Hemann, Seton
Hall University
  Julia Lawall, Inria; Joe Gibbs Politz, University of California at San Diego;
Marco T Moraz\'an (Chair), Seton Hall University
</summary>
    <author>
      <name>Marco T. Morazán</name>
    </author>
    <link href="http://arxiv.org/abs/2310.08262v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.08262v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.13413v3</id>
    <updated>2024-01-11T11:37:32Z</updated>
    <published>2023-10-20T10:44:33Z</published>
    <title>Scoped and Typed Staging by Evaluation</title>
    <summary>  Using a dependently typed host language, we give a well scoped-and-typed by
construction presentation of a minimal two level simply typed calculus with a
static and a dynamic stage. The staging function partially evaluating the part
of a term that are static is obtained by a model construction inspired by
normalisation by evaluation.
  We then go on to demonstrate how this minimal language can be extended to
provide additional metaprogramming capabilities, and to define a higher order
functional language evaluating to digital circuit descriptions.
</summary>
    <author>
      <name>Guillaume Allais</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">As accepted for publication at PEPM 2024</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.13413v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.13413v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.13441v2</id>
    <updated>2024-04-26T16:18:36Z</updated>
    <published>2023-10-20T12:09:17Z</published>
    <title>Seamless, Correct, and Generic Programming over Serialised Data</title>
    <summary>  In typed functional languages, one can typically only manipulate data in a
type-safe manner if it first has been deserialised into an in-memory tree
represented as a graph of nodes-as-structs and subterms-as-pointers.
  We demonstrate how we can use QTT as implemented in \idris{} to define a
small universe of serialised datatypes, and provide generic programs allowing
users to process values stored contiguously in buffers.
  Our approach allows implementors to prove the full functional correctness by
construction of the IO functions processing the data stored in the buffer.
</summary>
    <author>
      <name>Guillaume Allais</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">As submitted to JFP</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.13441v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.13441v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.2.4; E.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2310.13589v1</id>
    <updated>2023-10-20T15:32:37Z</updated>
    <published>2023-10-20T15:32:37Z</published>
    <title>A R4RS Compliant REPL in 7 KB</title>
    <summary>  The Ribbit system is a compact Scheme implementation running on the Ribbit
Virtual Machine (RVM) that has been ported to a dozen host languages. It
supports a simple Foreign Function Interface (FFI) allowing extensions to the
RVM directly from the program's source code. We have extended the system to
offer conformance to the R4RS standard while staying as compact as possible.
This leads to a R4RS compliant REPL that fits in an 7 KB Linux executable. This
paper explains the various issues encountered and our solutions to make,
arguably, the smallest R4RS conformant Scheme implementation of all time.
</summary>
    <author>
      <name>Léonard Oest O'Leary</name>
    </author>
    <author>
      <name>Mathis Laroche</name>
    </author>
    <author>
      <name>Marc Feeley</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Presented at The 2023 Scheme and Functional Programming Workshop
  (arXiv:cs/0101200)</arxiv:comment>
    <link href="http://arxiv.org/abs/2310.13589v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2310.13589v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.0" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.01302v1</id>
    <updated>2023-11-02T15:17:27Z</updated>
    <published>2023-11-02T15:17:27Z</published>
    <title>Petrification: Software Model Checking for Programs with Dynamic Thread
  Management (Extended Version)</title>
    <summary>  We address the verification problem for concurrent program that dynamically
create (fork) new threads or destroy (join) existing threads. We present a
reduction to the verification problem for concurrent programs with a fixed
number of threads. More precisely, we present petrification, a transformation
from programs with dynamic thread management to an existing, Petri net-based
formalism for programs with a fixed number of threads. Our approach is
implemented in a software model checking tool for C programs that use the
pthreads API.
</summary>
    <author>
      <name>Matthias Heizmann</name>
    </author>
    <author>
      <name>Dominik Klumpp</name>
    </author>
    <author>
      <name>Frank Schüssele</name>
    </author>
    <author>
      <name>Lars Nitzke</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">32 pages, 8 figures, 2 tables, extended version of the paper which is
  to appear at VMCAI 2024</arxiv:comment>
    <link href="http://arxiv.org/abs/2311.01302v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.01302v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.01725v1</id>
    <updated>2023-11-03T05:44:52Z</updated>
    <published>2023-11-03T05:44:52Z</published>
    <title>Quantum Recursive Programming with Quantum Case Statements</title>
    <summary>  We introduce a novel scheme of quantum recursive programming, in which large
unitary transformations, i.e. quantum gates, can be recursively defined using
quantum case statements, which are quantum counterparts of conditionals and
case statements extensively used in classical programming. A simple programming
language for supporting this kind of quantum recursion is defined, and its
semantics is formally described. A series of examples are presented to show
that some quantum algorithms can be elegantly written as quantum recursive
programs.
</summary>
    <author>
      <name>Mingsheng Ying</name>
    </author>
    <author>
      <name>Zhicheng Zhang</name>
    </author>
    <link href="http://arxiv.org/abs/2311.01725v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.01725v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="quant-ph" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.10426v1</id>
    <updated>2023-11-17T10:00:47Z</updated>
    <published>2023-11-17T10:00:47Z</published>
    <title>Polymorphic Type Inference for Dynamic Languages</title>
    <summary>  We present a type system that combines, in a controlled way, first-order
polymorphism with intersectiontypes, union types, and subtyping, and prove its
safety. We then define a type reconstruction algorithm that issound and
terminating. This yields a system in which unannotated functions are given
polymorphic types(thanks to Hindley-Milner) that can express the overloaded
behavior of the functions they type (thanks tothe intersection introduction
rule) and that are deduced by applying advanced techniques of type
narrowing(thanks to the union elimination rule). This makes the system a prime
candidate to type dynamic languages.
</summary>
    <author>
      <name>Giuseppe Castagna</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">CNRS, IRIF, UPCité</arxiv:affiliation>
    </author>
    <author>
      <name>Mickaël Laurent</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">IRIF, UPCité</arxiv:affiliation>
    </author>
    <author>
      <name>Kim Nguyen</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">LMF</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3632882</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3632882" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Proceedings of the ACM on Programming Languages, In press, 8
  (POPL), pp.40</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2311.10426v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.10426v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.10533v2</id>
    <updated>2023-12-09T15:38:42Z</updated>
    <published>2023-11-17T13:57:25Z</published>
    <title>Parsing Millions of URLs per Second</title>
    <summary>  URLs are fundamental elements of web applications. By applying vector
algorithms, we built a fast standard-compliant C++ implementation. Our parser
uses three times fewer instructions than competing parsers following the WHATWG
standard (e.g., Servo's rust-url) and up to eight times fewer instructions than
the popular curl parser. The Node.js environment adopted our C++ library. In
our tests on realistic data, a recent Node.js version (20.0) with our parser is
four to five times faster than the last version with the legacy URL parser.
</summary>
    <author>
      <name>Yagiz Nizipli</name>
    </author>
    <author>
      <name>Daniel Lemire</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1002/spe.3296</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1002/spe.3296" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Software: Practice and Experience 54 (5), 2024</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2311.10533v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.10533v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.DS" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.10577v1</id>
    <updated>2023-11-17T15:25:49Z</updated>
    <published>2023-11-17T15:25:49Z</published>
    <title>Contextual Refinement Types</title>
    <summary>  We develop an extension of the proof environment Beluga with datasort
refinement types and study its impact on mechanized proofs. In particular, we
introduce refinement schemas, which provide fine-grained classification for the
structures of contexts and binders. Refinement schemas are helpful in concisely
representing certain proofs that rely on relations between contexts. Our
formulation of refinements combines the type checking and sort checking phases
into one by viewing typing derivations as outputs of sorting derivations. This
allows us to cleanly state and prove the conservativity of our extension.
</summary>
    <author>
      <name>Antoine Gaulin</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McGill University</arxiv:affiliation>
    </author>
    <author>
      <name>Brigitte Pientka</name>
      <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">McGill University</arxiv:affiliation>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.4204/EPTCS.396.2</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.4204/EPTCS.396.2" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">In Proceedings LFMTP 2023, arXiv:2311.09918</arxiv:comment>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">EPTCS 396, 2023, pp. 4-19</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2311.10577v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.10577v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.1; F.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.11105v1</id>
    <updated>2023-11-18T15:44:44Z</updated>
    <published>2023-11-18T15:44:44Z</published>
    <title>State of structural typing support in Scala 3.3.0</title>
    <summary>  Scala's type system is primarily based on nominal typing. Scala 3 introduces
a special type, Selectable, which provides an infrastructure for structural
typing. Karlsson and Haller proposed improvements to Selectable to support
extensible records. In this paper, we review several Scala 3 projects that
involve structural typing. We find that their implementation or usability would
benefit from the extensible records proposal from Karlsson and Haller. We
investigate the remaining common challenges when working with structural types.
In particular, we identify that a dedicated syntax for both record types and
record literals would be the most beneficial addition to the language.
</summary>
    <author>
      <name>Julien Richard-Foy</name>
    </author>
    <link href="http://arxiv.org/abs/2311.11105v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.11105v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.14347v3</id>
    <updated>2024-07-23T02:50:29Z</updated>
    <published>2023-11-24T08:48:00Z</published>
    <title>Typed compositional quantum computation with lenses</title>
    <summary>  We propose a type-theoretic framework for describing and proving properties
of quantum computations, in particular those presented as quantum circuits. Our
proposal is based on an observation that, in the polymorphic type system of
Coq, currying on quantum states allows us to apply quantum gates directly
inside a complex circuit. By introducing a discrete notion of lens to control
this currying, we are further able to separate the combinatorics of the circuit
structure from the computational content of gates. We apply our development to
define quantum circuits recursively from the bottom up, and prove their
correctness compositionally.
</summary>
    <author>
      <name>Jacques Garrigue</name>
    </author>
    <author>
      <name>Takafumi Saikawa</name>
    </author>
    <link href="http://arxiv.org/abs/2311.14347v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.14347v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2311.16977v1</id>
    <updated>2023-11-28T17:25:16Z</updated>
    <published>2023-11-28T17:25:16Z</published>
    <title>Bidirectional Reactive Programming for Machine Learning</title>
    <summary>  Reactive languages are dedicated to the programming of systems which interact
continuously and concurrently with their environment. Values take the form of
unbounded streams modeling the (discrete) passing of time or the sequence of
concurrent interactions. While conventional reactivity models recurrences
forward in time, we introduce a symmetric reactive construct enabling backward
recurrences. Constraints on the latter allow to make the implementation
practical. Machine Learning (ML) systems provide numerous motivations for all
of this: we demonstrate that reverse-mode automatic differentiation,
backpropagation, batch normalization, bidirectional recurrent neural networks,
training and reinforcement learning algorithms, are all naturally captured as
bidirectional reactive programs.
</summary>
    <author>
      <name>Dumitru Potop Butucaru</name>
    </author>
    <author>
      <name>Albert Cohen</name>
    </author>
    <author>
      <name>Gordon Plotkin</name>
    </author>
    <author>
      <name>Hugo Pompougnac</name>
    </author>
    <link href="http://arxiv.org/abs/2311.16977v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2311.16977v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LG" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3; D.3.1; I.2; I.2.5" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2312.06455v1</id>
    <updated>2023-12-11T15:44:55Z</updated>
    <published>2023-12-11T15:44:55Z</published>
    <title>Ownership Types for Verification of Programs with Pointer Arithmetic</title>
    <summary>  Toman et al. have proposed a type system for automatic verification of
low-level programs, which combines ownership types and refinement types to
enable strong updates of refinement types in the presence of pointer aliases.
We extend their type system to support pointer arithmetic, and prove its
soundness. Based on the proposed type system, we have implemented a prototype
tool for automated verification of the lack of assertion errors of low-level
programs with pointer arithmetic, and confirmed its effectiveness through
experiments.
</summary>
    <author>
      <name>Izumi Tanaka</name>
    </author>
    <author>
      <name>Ken Sakayori</name>
    </author>
    <author>
      <name>Naoki Kobayashi</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">An extended version of the paper to appear in Proceedings of PEPM
  2024</arxiv:comment>
    <link href="http://arxiv.org/abs/2312.06455v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2312.06455v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2312.07946v1</id>
    <updated>2023-12-13T07:51:21Z</updated>
    <published>2023-12-13T07:51:21Z</published>
    <title>Incremental Computation: What Is the Essence?</title>
    <summary>  Incremental computation aims to compute more efficiently on changed input by
reusing previously computed results. We give a high-level overview of works on
incremental computation, and highlight the essence underlying all of them,
which we call incrementalization -- the discrete counterpart of differentiation
in calculus. We review the gist of a systematic method for incrementalization,
and a systematic method centered around it, called
Iterate-Incrementalize-Implement, for program design and optimization, as well
as algorithm design and optimization. At a meta-level, with historical contexts
and for future directions, we stress the power of high-level data, control, and
module abstractions in developing new and better algorithms and programs as
well as their precise complexities.
</summary>
    <author>
      <name>Yanhong A. Liu</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3635800.3637447</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3635800.3637447" rel="related"/>
    <link href="http://arxiv.org/abs/2312.07946v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2312.07946v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2312.12147v1</id>
    <updated>2023-12-19T13:31:17Z</updated>
    <published>2023-12-19T13:31:17Z</published>
    <title>LoKit (revisited): A Toolkit for Building Distributed Collaborative
  Applications</title>
    <summary>  LoKit is a toolkit based on the coordination language LO. It allows to build
distributed collaborative applications by providing a set of generic tools.
This paper briefly introduces the concept of the toolkit, presents a subset of
the LoKit tools, and finally demonstrates its power by discussing a sample
application built with the toolkit.
</summary>
    <author>
      <name>Uwe M. Borghoff</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">20 pages, 3 figures, 1 table. This paper is a reprint of an
  unpublished report on the occasion of the (fictitious) 30th anniversary of
  the Xerox Research Centre Europe, now Naver Labs, Grenoble, France</arxiv:comment>
    <link href="http://arxiv.org/abs/2312.12147v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2312.12147v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2312.16446v1</id>
    <updated>2023-12-27T07:22:03Z</updated>
    <published>2023-12-27T07:22:03Z</published>
    <title>Free Variable as Effect, in Practice</title>
    <summary>  Variable environment is the time-honored way of making sense of free
variables, used in programming language theory as well when writing
interpreters and some compilers. Algebraic effects give another way, as was
pointed already at HOPE 2017. Although a theoretical curiosity, it may have
surprising practical benefits: a new way of writing compilers, with the
incremental type-checking, with easy variable usage, leaf function analyses.
This work-in-progress report prototypes and illustrates the idea.
</summary>
    <author>
      <name>Oleg Kiselyov</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Peer-reviewed, accepted for presentation and presented at the ACM
  SIGPLAN HOPE 2023 workshop</arxiv:comment>
    <link href="http://arxiv.org/abs/2312.16446v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2312.16446v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.4; D.3.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2312.17141v1</id>
    <updated>2023-12-28T17:16:14Z</updated>
    <published>2023-12-28T17:16:14Z</published>
    <title>Probabilistic Programming with Exact Conditions</title>
    <summary>  We spell out the paradigm of exact conditioning as an intuitive and powerful
way of conditioning on observations in probabilistic programs. This is
contrasted with likelihood-based scoring known from languages such as Stan. We
study exact conditioning in the cases of discrete and Gaussian probability,
presenting prototypical languages for each case and giving semantics to them.
We make use of categorical probability (namely Markov and CD categories) to
give a general account of exact conditioning which avoids limits and measure
theory, instead focusing on restructuring dataflow and program equations. The
correspondence between such categories and a class of programming languages is
made precise by defining the internal language of a CD category.
</summary>
    <author>
      <name>Dario Stein</name>
    </author>
    <author>
      <name>Sam Staton</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted for JACM</arxiv:comment>
    <link href="http://arxiv.org/abs/2312.17141v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2312.17141v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.LO" scheme="http://arxiv.org/schemas/atom"/>
    <category term="math.PR" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2401.01114v1</id>
    <updated>2024-01-02T09:09:48Z</updated>
    <published>2024-01-02T09:09:48Z</published>
    <title>Static Deadlock Detection for Rust Programs</title>
    <summary>  Rust relies on its unique ownership mechanism to ensure thread and memory
safety. However, numerous potential security vulnerabilities persist in
practical applications. New language features in Rust pose new challenges for
vulnerability detection. This paper proposes a static deadlock detection method
tailored for Rust programs, aiming to identify various deadlock types,
including double lock, conflict lock, and deadlock associated with conditional
variables. With due consideration for Rust's ownership and lifetimes, we first
complete the pointer analysis. Then, based on the obtained points-to
information, we analyze dependencies among variables to identify potential
deadlocks. We develop a tool and conduct experiments based on the proposed
method. The experimental results demonstrate that our method outperforms
existing deadlock detection methods in precision.
</summary>
    <author>
      <name>Yu Zhang</name>
    </author>
    <author>
      <name>Kaiwen Zhang</name>
    </author>
    <author>
      <name>Guanjun Liu</name>
    </author>
    <link href="http://arxiv.org/abs/2401.01114v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2401.01114v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.CR" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2401.07726v2</id>
    <updated>2024-07-09T06:56:30Z</updated>
    <published>2024-01-15T14:40:28Z</published>
    <title>Preserving Power Optimizations Across the High Level Synthesis of
  Distinct Application-Specific Circuits</title>
    <summary>  We evaluate the use of software interpretation to push High Level Synthesis
of application-specific accelerators toward a higher level of abstraction. Our
methodology is supported by a formal power consumption model that computes the
power consumption of accelerator components, accurately predicting the power
consumption on new designs from prior optimization estimations. We demonstrate
how our approach simplifies the re-use of power optimizations across distinct
designs, by leveraging the higher level of design abstraction, using two
accelerators representative of the robotics domain, implemented through the
Bambu High Level Synthesis tool. Results support the research hypothesis,
achieving predictions accurate within +/- 1%.
</summary>
    <author>
      <name>Paulo Garcia</name>
    </author>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">Accepted at IEEE 10th International Conference on Communications and
  Electronics (ICCE) 2024</arxiv:comment>
    <link href="http://arxiv.org/abs/2401.07726v2" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2401.07726v2" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.RO" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2401.11029v1</id>
    <updated>2024-01-19T21:04:45Z</updated>
    <published>2024-01-19T21:04:45Z</published>
    <title>Optimization of the Context-Free Language Reachability Matrix-Based
  Algorithm</title>
    <summary>  Various static analysis problems are reformulated as instances of the
Context-Free Language Reachability (CFL-r) problem. One promising way to make
solving CFL-r more practical for large-scale interprocedural graphs is to
reduce CFL-r to linear algebra operations on sparse matrices, as they are
efficiently executed on modern hardware. In this work, we present five
optimizations for a matrix-based CFL-r algorithm that utilize the specific
properties of both the underlying semiring and the widely-used linear algebra
library SuiteSparse:GraphBlas. Our experimental results show that these
optimizations result in orders of magnitude speedup, with the optimized
matrix-based CFL-r algorithm consistently outperforming state-of-the-art CFL-r
solvers across four considered static analyses.
</summary>
    <author>
      <name>Ilia Muravev</name>
    </author>
    <link href="http://arxiv.org/abs/2401.11029v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2401.11029v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2402.04811v1</id>
    <updated>2024-02-07T13:01:28Z</updated>
    <published>2024-02-07T13:01:28Z</published>
    <title>Accurate Coverage Metrics for Compiler-Generated Debugging Information</title>
    <summary>  Many debugging tools rely on compiler-produced metadata to present a
source-language view of program states, such as variable values and source line
numbers. While this tends to work for unoptimised programs, current compilers
often generate only partial debugging information in optimised programs.
Current approaches for measuring the extent of coverage of local variables are
based on crude assumptions (for example, assuming variables could cover their
whole parent scope) and are not comparable from one compilation to another. In
this work, we propose some new metrics, computable by our tools, which could
serve as motivation for language implementations to improve debugging quality.
</summary>
    <author>
      <name>J. Ryan Stinnett</name>
    </author>
    <author>
      <name>Stephen Kell</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3640537.3641578</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3640537.3641578" rel="related"/>
    <link href="http://arxiv.org/abs/2402.04811v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2402.04811v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.SE" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2402.12108v1</id>
    <updated>2024-02-19T12:56:44Z</updated>
    <published>2024-02-19T12:56:44Z</published>
    <title>Weak-Linear Types</title>
    <summary>  Computational interpretations of linear logic allow static control of memory
resources: the data produced by the program are endowed through its type with
attributes that determine its life cycle, and guarantee safe deallocation. The
use of linear types encounters limitations in practice, since linear data, in
the traditional sense, do not so often appear in actual programs. Several
alternatives have been proposed in the attempt to relax the condition of
linearity, adding coercions to the language to allow linear objects to be
temporarily aliased. In this work we propose a new alternative, whose virtue is
to preserve the simplicity and elegance of the original system.
</summary>
    <author>
      <name>Hector Gramaglia</name>
    </author>
    <link href="http://arxiv.org/abs/2402.12108v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2402.12108v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="F.3.2; F.3.3; D.3.3" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2402.16741v3</id>
    <updated>2024-05-02T12:20:09Z</updated>
    <published>2024-02-26T17:05:11Z</published>
    <title>Less is More Revisited</title>
    <summary>  Multiparty session types (MPST) provide a type discipline where a programmer
or architect specifies a whole view of communications as a global protocol, and
each distributed program is locally type-checked against its end-point
projection. After 10 years from the birth of MPST, Scalas and Yoshida
discovered that the proofs of type safety in the literature which use the
end-point projection with mergeability are flawed. After this paper,
researchers wrongly believed that the end-point projection (with mergeability)
was unsound. We correct this misunderstanding, proposing a new general proof
technique for type soundness of multiparty session $\pi$-calculus, which uses
an association relation between a global type and its end-point projection.
</summary>
    <author>
      <name>Nobuko Yoshida</name>
    </author>
    <author>
      <name>Ping Hou</name>
    </author>
    <link href="http://arxiv.org/abs/2402.16741v3" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2402.16741v3" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2403.01335v1</id>
    <updated>2024-03-02T22:53:06Z</updated>
    <published>2024-03-02T22:53:06Z</published>
    <title>Making Hybrid Languages: A Recipe</title>
    <summary>  The dominant programming languages support only linear text to express ideas.
Visual languages offer graphical representations for entire programs, when
viewed with special tools. Hybrid languages, with support from existing tools,
allow developers to express their ideas with a mix of textual and graphical
syntax tailored to an application domain. This mix puts both kinds of syntax on
equal footing and, importantly, the enriched language does not disrupt a
programmer's typical workflow. This paper presents a recipe for equipping
existing textual programming languages as well as accompanying IDEs with a
mechanism for creating and using graphical interactive syntax. It also presents
the first hybrid language and IDE created using the recipe.
</summary>
    <author>
      <name>Leif Andersen</name>
    </author>
    <author>
      <name>Cameron Moy</name>
    </author>
    <author>
      <name>Stephen Chang</name>
    </author>
    <author>
      <name>Matthias Felleisen</name>
    </author>
    <link href="http://arxiv.org/abs/2403.01335v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2403.01335v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.HC" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2403.01866v1</id>
    <updated>2024-03-04T09:21:10Z</updated>
    <published>2024-03-04T09:21:10Z</published>
    <title>Circular Programs and Self-Referential Structures</title>
    <summary>  A circular program creates a data structure whose computation depends upon
itself or refers to itself. The technique is used to implement the classic data
structures circular and doubly-linked lists, threaded trees and queues, in a
functional programming language. These structures are normally thought to
require updatable variables found in imperative languages. For example, a
functional program to perform the breadth-first traversal of a tree is given.
Some of the examples result in circular data structures when evaluated. Some
examples are particularly space-efficient by avoiding the creation of
intermediate temporary structures which would otherwise later become garbage.
Lastly, the technique can be applied in an imperative language to give an
elegant program.
</summary>
    <author>
      <name>Lloyd Allison</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1002/spe.4380190202</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1002/spe.4380190202" rel="related"/>
    <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">Software Practice and Experience, 19(2), 99-109, 1989</arxiv:journal_ref>
    <link href="http://arxiv.org/abs/2403.01866v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2403.01866v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.1; E.1" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
  <entry>
    <id>http://arxiv.org/abs/2403.04633v1</id>
    <updated>2024-03-07T16:16:39Z</updated>
    <published>2024-03-07T16:16:39Z</published>
    <title>Message-Observing Sessions</title>
    <summary>  We present Most, a process language with message-observing session types.
Message-observing session types extend binary session types with type-level
computation to specify communication protocols that vary based on messages
observed on other channels. Hence, Most allows us to express global invariants
about processes, rather than just local invariants, in a bottom-up,
compositional way. We give Most a semantic foundation using traces with
binding, a semantic approach for compositionally reasoning about traces in the
presence of name generation. We use this semantics to prove type soundness and
compositionality for Most processes. We see this as a significant step towards
capturing message-dependencies and providing more precise guarantees about
processes.
</summary>
    <author>
      <name>Ryan Kavanagh</name>
    </author>
    <author>
      <name>Brigitte Pientka</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3649859</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3649859" rel="related"/>
    <link href="http://arxiv.org/abs/2403.04633v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2403.04633v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="D.3.3; F.3.2" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
</feed>
